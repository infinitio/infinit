#!/usr/bin/env python3

import sys
import os
import subprocess
import shutil
import stat

def cmd(*args, **kwargs):
    return subprocess.check_output(list(args), **kwargs)

def error(*args):
    sys.stderr.write(' '.join(str(a) for a in args))

def fatal(*args):
    error(*args)
    sys.exit(1)

def which(executable):
    path = os.environ["PATH"]
    for d in path.split(":"):
        file = os.path.join(d,executable)
        if os.path.exists(file):
            return file

DIR_SOURCE = os.path.abspath(os.environ["DIR_SOURCE"])
DIR_BUILD = os.path.abspath(os.environ["DIR_BUILD"])
DIR_INSTALL = os.path.abspath(os.environ["DIR_INSTALL"])
DEBUG = os.environ.get("MAKE_DEBUG_INSTALL", False)

for d in [DIR_SOURCE, DIR_BUILD]:
    if not os.path.isdir(d):
        fatal(d, "is not a directory")

name = cmd("git", "describe", cwd=DIR_SOURCE).decode("utf-8").strip()
rev = cmd("git", "rev-parse", "--short", "HEAD", cwd=DIR_SOURCE).decode("utf-8").strip()

version = name.split("-")[0]
major = version.split(".")[0]
minor = version.split(".")[1]

DIR_INSTALL_CLIENT = "%s/client" % DIR_INSTALL

shutil.rmtree(DIR_INSTALL_CLIENT, True)
os.makedirs(DIR_INSTALL_CLIENT)


def to_add(lib):

    patterns_exclude = {
        'startswith': [
            "/usr/lib/libstdc++",
        ],

        'contains': [
            "/lib64/ld-linux-x86-64",
            "/lib/ld-linux-x86-64",
            "libICE",
            "libSM",
            "libX",
            "libaudio",
            "libbz2",
            "libffi",
            "libfontconfig",
            "libfreetype",
            "libglib",
            "libgobject",
            "libgthread",
            "libpcre",
            "librt",
            "libtinfo",
            "libuuid",
            "libxcb",
            "linux-vdso",
            "linux-gate",
            "libSystem",
            "SystemConfiguration",
            "CoreFoundation",
            "ApplicationServices",
            "Security",
            "CoreServices",
            "CoreText",
            "ImageIO",
            "Carbon",
            "AppKit",
            "libobjc",
            "Foundation",
            "libfuse.so.",
            "libutil.so",
            "libpthread.",
            "libc.",
            "libm.",
            "libdl.",
            "Cocoa",
            "libcache",
            "libcommonCrypto",
            "libcompiler_rt",
            "libcopyfile",
            "libdispatch",
            "libdnsinfo",
            "libdyld",
            "libkeymgr",
            "liblaunch",
            "libmacho",
            "libquarantine",
            "libremovefile",
            "libsystem",
            "libunc",
            "libunwind",
            "libxpc",
            "libfuse4x",
        ]
    }
    if 'linux' in sys.platform.lower():
        patterns_exclude['contains'].extend([
            'libQt',
        ])

    patterns_include = {
        'startswith': [
        ],
        'contains': [
            "libetoile.",
            "libelle.",
            "libhole.",
            "libnucleus.",
            "libinfinit.",
            "liblune.",

            "libgcc_s",
            "libstdc++",
            "libpth.",
            "libz.",
            "libboost",
            "libcrypto",
            "libQt",
            "libexpat",
            "libpng",
            "libncurses",
            "libssl",
            "libpython",
            "Python",
            "libgap",
            "_gap.so",
            "libintl.",
            "libiconv.",
        ]
    }
    if any(lib.startswith(p) for p in patterns_exclude['startswith']) or \
       any(p in lib for p in patterns_exclude['contains']):
        return False
    elif any(lib.startswith(p) for p in patterns_include['startswith']) or \
         any(p in lib for p in patterns_include['contains']):
        return True
    else:
        raise Exception("lib not specified: %s" % lib)

DIR_INSTALL_CLIENT_BIN = os.path.join(DIR_INSTALL_CLIENT, "bin")
DIR_INSTALL_CLIENT_LIB = os.path.join(DIR_INSTALL_CLIENT, "lib")


if which("otool"):
    def get_binary_dependencies(arg):
        deps = cmd('otool', '-L', arg).decode("utf-8")
        deps = deps.split("\n")[:-1]
        if not deps:
            return []
        return (
            dep.strip().split(" ")[0] for dep in deps[1:]
        )
elif which("ldd"):
    def get_binary_dependencies(arg):
        deps = cmd('ldd', arg).decode("utf-8")
        deps = deps.split('\n')
        if not deps:
            return
        for dep in deps[1:]:
            dep = dep.strip()
            if not dep or '=>' not in dep:
                return
            yield dep.split('=>')[1].strip().split(' ')[0].strip()
else:
    raise Exception("otool or ldd needed")

if 'darwin' in sys.platform:
    if not  which("install_name_tool"):
        raise Exception("You need install_name_tool !")
    def patch_binary_for(binary, dependency, from_="@loader_path", real_dependency_path=None):
        if real_dependency_path is None:
            real_dependency_path = dependency
        relpath = os.path.relpath(
            real_dependency_path,
            start=os.path.dirname(binary)
        )
        cmd(
            "install_name_tool",
            "-change", dependency,
            os.path.join(from_, relpath),
            binary
        )
else:
    def patch_binary_for(*args, **kwargs):
        pass

if 'linux' in sys.platform:
    if not which("patchelf"):
        raise Exception("patchelf needed on linux")
    def patch_binary(binary, lib_dir):
        reldir = os.path.relpath(lib_dir, start=os.path.dirname(binary))
        cmd(
            'patchelf',
            #'--debug',
            '--set-rpath', os.path.join('$ORIGIN', reldir),
            dst
        )
else:
    def patch_binary(binary, lib_dir):
        pass

def is_binary(path):
    if not stat.S_IXUSR & os.stat(src)[stat.ST_MODE]:
        return False
    with open(path, 'rb') as f:
        if f.read(2) == b'#!':
            return False
    return True

def fill_dependencies(dependencies, binary_path, kind, indent=1):
    print('-' * indent, binary_path)
    node = dependencies.setdefault(binary_path, {})
    node['kind'] = kind
    childs = node.setdefault('childs', set())
    node['is_binary'] = is_binary(binary_path)
    if not node['is_binary']:
        return
    for dependency in get_binary_dependencies(binary_path):
        if '@executable_path' in dependency:
            continue
        print('-'*indent + '> dep', dependency)
        if not to_add(dependency):
            #print('-'*indent + '> IGNORE', dependency)
            continue
        childs.add(dependency)
        if dependency not in dependencies:
            fill_dependencies(dependencies, dependency, 'lib', indent + 1)

LIBRARY_EXT = "darwin" in sys.platform and "dylib" or "so"

infinit_files = [
    ("bin/8infinit", "bin"),
    ("bin/8access", "bin"),
    ("bin/8group", "bin"),
    ("bin/8chmod", "bin"),
    ("bin/infinit-cli", "bin"),
    ("lib/libgap." + LIBRARY_EXT, "lib"),
    ("lib/python/_gap.so", "python"),
    ("lib/python/gap.py", "python"),
]

dependencies = {}
for src_rel, kind in infinit_files:
    src = os.path.join(DIR_BUILD, src_rel)
    fill_dependencies(dependencies, src, kind)

for src, node in dependencies.items():
    dst_dir = os.path.join(DIR_INSTALL_CLIENT, node['kind'])
    if not os.path.exists(dst_dir):
        os.makedirs(dst_dir)
    dst = os.path.join(DIR_INSTALL_CLIENT, node['kind'], os.path.basename(src))
    shutil.copy(src, dst)
    if not node['is_binary']:
        continue
    os.chmod(dst, stat.S_IRWXU)
    if not DEBUG:
        print("Strip", dst)
        cmd('strip', '-S', dst)
    else:
        print("DO NOT STRIP", dst)
    patch_binary(dst, DIR_INSTALL_CLIENT_LIB)
    for child in node['childs']:
        patch_binary_for(
            dst,
            child,
            real_dependency_path=os.path.join(
                DIR_INSTALL_CLIENT_LIB,
                os.path.basename(child)
            )
        )

infinit_app = os.path.join(DIR_BUILD, "surface/macosx/Infinit.app")
if os.path.exists(infinit_app):
    #shutil.copytree(
    #    "/Library/Extensions/fuse4x.kext",
    #    os.path.join(DIR_INSTALL_CLIENT_LIB, "fuse4x.kext")
    #)
    patch_binary_for(os.path.join(DIR_INSTALL_CLIENT_LIB, "libgap.dylib"), "/opt/local/lib/libfuse4x.2.dylib")
    dst_app = os.path.join(DIR_INSTALL_CLIENT, os.path.basename(infinit_app))

    shutil.copytree(infinit_app, dst_app, symlinks=True)

    phone_lib = os.path.join(
        dst_app,
        "Contents/Frameworks/Phone.framework/Versions/A/Phone",
    )
    rel_gap_lib = os.path.join(DIR_INSTALL_CLIENT, "Infinit.app/Contents/Resources/lib", "libgap.dylib")
    gap_lib = os.path.join(DIR_BUILD, "surface/gap/libgap.dylib")
    patch_binary_for(phone_lib, gap_lib, real_dependency_path=rel_gap_lib)


print("Prepare the manifest")
cmd(os.path.join(DIR_SOURCE,'farm/make_manifest'), DIR_INSTALL_CLIENT, major, minor, rev)

DIR_INSTALL_SERVER = os.path.join(DIR_INSTALL, "server")
shutil.rmtree(DIR_INSTALL_SERVER, True)
os.makedirs(DIR_INSTALL_SERVER)

server_scripts = [
    "metalib/__init__.py",
    "metalib/_metalib.so",
    "pythia",
    "meta",
    "creosus",
    "troll",
    "static",
    "meta-server",
    "meta-tests",
    "creosus-server",
    "trophonius-server",
    "trophonius",
    "longinus-server.py",
    "longinus",
    "erginus-server"
]

if os.path.isdir(os.path.join(DIR_BUILD, "oracle")): # oracle is built
    for f in server_scripts:
        src = os.path.join(DIR_BUILD, "lib/python", f)
        dst = os.path.join(DIR_INSTALL_SERVER, f)
        if os.path.isdir(src):
            shutil.copytree(src, dst)
        else:
            if not os.path.isdir(os.path.dirname(dst)):
                os.makedirs(os.path.dirname(dst))
            shutil.copy(src, dst)
