#!/usr/bin/env python3

import os
import subprocess
import sys

arch, osyst, compiler = os.environ['BUILDFARM_NAME'].split('-')
os.chdir(os.environ['DIR_BUILD'])
if subprocess.call(['python3', 'drake', '//check']) != 0:
  exit(1)

# import io
# import os
# import re
# import sys
# import stat
# import copy
# import html
# import time
# import email
# import runpy
# import pprint
# import argparse
# import datetime
# import threading
# import email.mime
# import smtplib as sml
# import subprocess as sp
#
# from higgs import pool
# from higgs import infinitools
#
# from higgs import watchers
# from higgs.constants import BUILD, SOURCE
# from higgs.watchers import StatusCode
# from collections import namedtuple
# from collections import OrderedDict
#
# pattern = re.compile(r"^(?P<name>.*)\.(?P<nb>\d+)\.(?P<ext>py|sh)$")
#
# os.environ['INFINIT_CRYPTOGRAPHY_RANDOM_SOURCE'] = '/dev/urandom'
#
# WATCHERS = (
#     watchers.Timing,
#     watchers.Environ,
#     watchers.Result,
#     watchers.Memory,
#     watchers.Graph,
# )
#
#
# def launch_script(engine, script_report, script_path, script_name, nb_instance):
#     script_report["Script path"] = script_path
#
#     # Skip the script if it's not executable
#     if not os.stat(script_path)[stat.ST_MODE] & stat.S_IXUSR:
#         script_report["Error"] = "The script is not executable"
#         script_report["result"] = "FAILURE"
#         return
#
#     script_report["Number of peers"] = nb_instance
#
#     print("launch the test [\033[32m", script_path,
#             "\033[0m] with",
#             nb_instance, "instances")
#     homes = {}
#     with pool.Pool(engine, number_of_networks=nb_instance) as p:
#
#         # Fill the report for the networks used by the script
#         script_report["home"] = OrderedDict()
#         home_report = script_report["home"]
#
#         for i, H in enumerate(p.l_home):
#             home_report["home[{0}]".format(i)] = OrderedDict()
#             curr_rep = home_report["home[{0}]".format(i)]
#             curr_rep["home"] = H.home
#             curr_rep["user"] = H.user
#             curr_rep["conf"] = H.conf.to_dict()
#             curr_rep["network"] = H.network
#             curr_rep["mode"] = H.mode
#
#             # Dump the .set files
#             with open(os.path.join(
#                     H.home,
#                     "users",
#                     H.user,
#                     "networks",
#                     H.network,
#                     "{net}.set".format(net=H.network)), "r") \
#             as setfile:
#                 curr_rep["set"] = setfile.read().split()
#
#
#         # Prepare the Watchers for this test
#         watchers = list(type_(script_name, report["scripts"]) for type_ in WATCHERS)
#
#         # Save the environ to add some stuff inside
#         environ_save = copy.deepcopy(os.environ)
#
#         # Wait for the mountpoints to be ready
#         p.wait_ready()
#         print("\033[32mAll the filesystems are effectivly mounted, start the testing...\033[0m")
#
#         # The scripts needs MNT$i variables to point to the
#         # mountpoints
#         for (i, mountpoint) in enumerate(p.mountpoints):
#             os.environ["MNT{0}".format(i + 1)] = mountpoint
#             print("export MNT{0}={1}".format(i + 1, mountpoint))
#
#         for (i, pid) in enumerate(p.pids):
#             os.environ["INFINIT_PID{0}".format(i + 1)] = str(pid)
#
#         for w in watchers:
#             w.pre_run(os.environ)
#
#         s = StatusCode()
#
#         out = ""
#         try:
#             p1 = sp.Popen([script_path], stdout=sp.PIPE, stderr=sp.STDOUT)
#             out, _ = p1.communicate()
#             if p1.returncode == 0:
#                     s.status = StatusCode.SUCCESS
#                     print("\033[32mtest", script_name,"success\033[0m")
#             else:
#                     s.status = StatusCode.FAILURE
#                     print("\033[31mtest", script_name,"failed\033[0m")
#         except BaseException as e:
#             s.status = StatusCode.FAILURE
#             print(e)
#             script_report["Reason"] = str(e)
#             print("\033[31mtest", script_name, "failed\033[0m")
#         finally:
#             print(out, end='', file=sys.stderr)
#             import html
#             if "std" not in script_report:
#                 script_report["std"] = OrderedDict()
#             if out:
#                 script_report["std"]["out"] = html.escape(out.decode("utf8"))
#             else:
#                 script_report["std"]["out"] = ""
#             for w in watchers:
#                 w.post_run(s)
#     for w in watchers:
#         w.post_shutdown(report)
#     for r, stderr in zip(home_report.values(), p.stderrs):
#         r['output'] = html.escape(stderr.read().decode('utf8'))
#     os.environ = environ_save
#     return watchers
#
# def launch_scripts(engine, scriptdir, report, scripts_to_run):
#     for root, dirs, scripts in os.walk(scriptdir):
#         for script in scripts:
#             m = pattern.match(script)
#             if m == None:
#                 continue
#
#             script_data = m.groupdict()
#
#             nb_instance = int(script_data["nb"])
#             script_name = script_data["name"]
#
#             if scripts_to_run != None and not script_name in scripts_to_run:
#                 continue
#
#             report["scripts"][script_name] = OrderedDict()
#             script_report = report["scripts"][script_name]
#
#             script_path = os.path.join(root, script)
#
#             launch_script(engine, script_report, script_path, script_name, nb_instance)
#
# def functionals_tests(scriptdir, report, scripts_to_run=None):
#     import pprint
#     print("functionals_tests working on", scriptdir, ",\n".join(os.listdir(scriptdir)))
#     with pool.PoolEngine(low_port=5656, high_port=5660) as engine:
#         report["engine"] = OrderedDict()
#         engine_report = report["engine"]
#         report["scripts"] = OrderedDict()
#
#         # Fill the engine report
#         engine_report["home"] = engine._base.home
#         engine_report["user"] = engine._base.user
#         engine_report["mode"] = engine._base.mode
#         engine_report["network"] = engine._base.network
#         engine_report["conf"] = engine._base.conf.to_dict()
#
#         os.environ["PYTHONPATH"] = scriptdir
#         launch_scripts(engine, scriptdir, report, scripts_to_run)
#     return all(test["result"] == "SUCCESS" for test in report["scripts"].values())
#
# def unit_tests(report):
#     report["unit_tests"] = OrderedDict()
#     ret = True
#     out, err = "", ""
#     try:
#         s1 = sp.Popen(["make", "test"], cwd=BUILD, stdout=sp.PIPE, stderr=sp.STDOUT)
#         out, err = s1.communicate()
#         print(out.decode("utf8"))
#         report["unit_tests"]["result"] = "SUCCESS"
#     except Exception as e:
#         print(e)
#         report["unit_tests"]["result"] = "FAILURE"
#         ret = False
#     finally:
#         import html
#         report["unit_tests"]["stdout"] = html.escape(out.decode("utf8"))
#     return ret
#
# def clean_the_fuck_up():
#     """
#     For some reasons, infinit does not clean itself correctly.
#
#     We know that we create the dirs in /tmp/infinit.*
#     """
#
#     # Shut the fuck up
#     sp.call(['sudo', 'pkill', '-9', '8infinit'])
#
#     mount_p = sp.Popen(['sudo', 'mount',
#         '-t', 'fuse.infinit'], stdout=sp.PIPE)
#
#     cut_p = sp.Popen(['cut',
#         '-d', ' ',
#         '-f', '3'], stdin=mount_p.stdout, stdout=sp.PIPE)
#     mount_p.stdout.close()
#     mountpoints = cut_p.communicate()[0].split()
#     if mountpoints:
#         sp.call([b'sudo', b'umount'] + mountpoints)
#     sp.call('rm -rf /tmp/infinit.*', shell=True)
#
# if __name__ == "__main__":
#     parser = argparse.ArgumentParser(description="Run the infinit test suite")
#
#     parser.add_argument('--scriptdir', '-d', metavar="DIR",
#             default=os.path.join(SOURCE, "tests", "functional", "scripts"),
#             help="the dir containing the scripts to be run")
#
#     parser.add_argument('--scripts', '-s',
#             help="the scripts to be run")
#
#     parser.add_argument('--sendmail', '-M', action="store_true",
#             help="send a mail")
#
#     parser.add_argument('--source ', '-r', default=SOURCE,
#             help="the source directory")
#
#     parser.add_argument('--builddir', '-b', default=BUILD,
#             help="the build directory containing the binaries")
#
#     parser.add_argument('--no-unit', action="store_true", default=False,
#             help="do not run the unit tests")
#
#     args = parser.parse_args()
#
#     # Update the env and paths for compatibility purpose
#     os.environ["INFINIT_BUILD"] = args.builddir
#     infinitools.patch_satellites_path(args.builddir)
#
#     functional_success = False
#     unit_success = False
#     report = OrderedDict()
#     # Run the functionals tests
#     if not args.scripts:
#         functional_success = functionals_tests(args.scriptdir, report)
#     else:
#         functional_success = functionals_tests(args.scriptdir, report, args.scripts.split(","))
#
#     # Run the unit tests (if no script was specified explicitly)
#     if not args.scripts and not args.no_unit:
#         unit_success = unit_tests(report)
#     else:
#         unit_success = True
#
#     with open("report", "w") as reportfile:
#         import pprint
#         pprint.pprint(report, stream=reportfile)
#
#     if args.sendmail:
#         m = watchers.Mail()
#         m.send_mail(report)
#
#     if functional_success == False \
#         or unit_success == False:
#         sys.exit(1)
