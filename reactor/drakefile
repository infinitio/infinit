import drake
import drake.cxx
import drake.cxx.boost

config = None
lib_static = None
lib_dynamic = None

def configure(cxx_toolkit, cxx_config, elle_config, boost = None, enable_tests = True):

  global config, lib_static, lib_dynamic

  config = drake.cxx.Config()
  config.add_local_include_path('src')
  config.standard = drake.cxx.Config.cxx_0x
  config.lib_path('lib')

  cxx_config += config
  cxx_config += elle_config

  sources = drake.nodes(
    'src/reactor/logger.cc',
    'src/reactor/signal.cc',
    'src/reactor/storage.cc',
    'src/reactor/sleep.cc',
    'src/reactor/waitable.cc',
    'src/reactor/exception.cc',
    'src/reactor/lockable.cc',
    'src/reactor/rw-mutex.cc',
    'src/reactor/thread.cc',
    'src/reactor/backend/pthread/pthread.cc',
    'src/reactor/backend/coro_io/thread.cc',
    'src/reactor/backend/coro_io/libcoroutine/asm.S',
    'src/reactor/backend/coro_io/libcoroutine/context.cc',
    'src/reactor/backend/coro_io/libcoroutine/coroutine.cc',
    'src/reactor/semaphore.cc',
    'src/reactor/mutex.cc',
    # 'src/reactor/network/udp-server-socket.cc',
    'src/reactor/network/exception.cc',
    'src/reactor/network/udp-socket.cc',
    'src/reactor/network/tcp-socket.cc',
    'src/reactor/network/udt-socket.cc',
    'src/reactor/network/resolve.cc',
    'src/reactor/network/tcp-server.cc',
    'src/reactor/network/udt-server.cc',
    'src/reactor/network/socket.cc',
    'src/reactor/network/server.cc',
    # 'src/reactor/network/udp-server.cc',
    'src/reactor/operation.cc',
    'src/reactor/scheduler.cc',
    'src/reactor/duration.cc',
    )

  lib_static = drake.cxx.StaticLib('lib/reactor', sources, cxx_toolkit, cxx_config)
  lib_dynamic = drake.cxx.DynLib('lib/reactor', sources, cxx_toolkit, cxx_config)

  tests = drake.nodes(
    'tests/backend.cc',
    'tests/network.cc',
    'tests/reactor.cc',
    )

  # Tests

  check = drake.Rule('check')

  tests = [
    'backend',
    'network',
    'reactor',
    ]

  class TestRunner(drake.Builder):

    def __init__(self, test):
      self.__test = test
      self.__out = drake.node('%s.out' % test.name())
      self.__err = drake.node('%s.err' % test.name())
      self.__status = drake.node('%s.status' % test.name())
      drake.Builder.__init__(self, [test], [self.__out, self.__err, self.__status])

    @property
    def status(self):
      return self.__status

    def execute(self):
      import subprocess
      path = str(self.__test.path())
      with open(str(self.__out.path()), 'w') as out, \
           open(str(self.__err.path()), 'w') as err, \
           open(str(self.__status.path()), 'w') as rv:
        self.output(path, 'Test %s' % self.__test)
        p = subprocess.Popen(path, stdout = out, stderr = err)
        p.wait()
        status = p.returncode
        print(status, file = rv)
      return status == 0

  boost = boost or drake.cxx.boost.Boost()

  cxx_config_tests = cxx_config + config
  cxx_config_tests += boost.config()
  cxx_config_tests += boost.config_filesystem()
  cxx_config_tests += boost.config_system()
  cxx_config_tests += boost.config_test()
  cxx_config_tests.lib('elle')
  cxx_config_tests.lib_path_runtime('../../lib')

  if enable_tests:
      for test in tests:
        config = drake.cxx.Config(cxx_config_tests)
        config.lib_path_runtime('%s../lib' % ('../' * test.count('/')))
        test = drake.cxx.Executable('tests/%s' % test,
                                    drake.nodes('tests/%s.cc' % test) + [lib_dynamic],
                                    cxx_toolkit, config)
        runner = TestRunner(test)
        check << runner.status
