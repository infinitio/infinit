import drake
import drake.cxx
import drake.cxx.boost
import drake.cxx.qt
import drake.git
import drake.templating

import os
import sys
import platform

with open(str(drake.path_source('elle/drake-utils.py')), 'r') as f:
  exec(f.read(), globals(), globals())

def configure(cxx_toolkit = None,
              cxx_config = None,
              enable_horizon = False,
              optimization = True,
              prefix = '/usr',
              boost = None,
              python3 = None,
              build_type = "Development",
              enable_debug = True,
      	      qt = None,
              valgrind = None):

  ## ----- ##
  ## Rules ##
  ## ----- ##


  build = drake.Rule('build')
  check = drake.TestSuite('check')
  install = drake.Rule('install')
  python_build = drake.Rule('python')
  tests = drake.Rule('tests')

  prefix = drake.Path(os.path.abspath(prefix))

  ## ----------------- ##
  ## C++ Configuration ##
  ## ----------------- ##

  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()
  cxx_config = cxx_config or drake.cxx.Config()

  if cxx_toolkit.os == drake.os.windows:
    Library = drake.cxx.StaticLib
  else:
    Library = drake.cxx.DynLib

  if enable_debug:
    cxx_config.define("DEBUG")
    cxx_config.enable_debug_symbols()
  else:
    cxx_config.enable_optimization(True)
    cxx_config.define("NDEBUG")

  build_types = {
    'Development': (),
    'Production': ("INFINIT_PRODUCTION_BUILD",)
  }

  if build_type == 'Production':
    cxx_config.enable_optimization(2)

  if not build_type in build_types.keys():
    raise Exception(
      'build type %s is unknown, candidates are: %s' %
      (build_type, ', '.join(str(t) for t in build_types)))

  for define in build_types[build_type]:
    if isinstance(define, str):
      cxx_config.define(define, 1)
    else:
      cxx_config.define(define[0], define[1])

  platform_defines = ()
  if cxx_toolkit.os == drake.os.linux:
    platform_defines = ("INFINIT_LINUX",)
  elif cxx_toolkit.os == drake.os.windows:
    platform_defines = ("INFINIT_WINDOWS",)
    cxx_config.define('INFINIT_WINDOWS')
    cxx_config.lib('shlwapi')
    cxx_config.lib('ws2_32')
    cxx_config.lib('gdi32')
    cxx_config.lib('mswsock')
  elif cxx_toolkit.os == drake.os.macos:
    platform_defines = ("INFINIT_MACOSX", "HAVE_STATFS")
  else:
    raise Exception("platform %s not supported" % sys.platform)
  for define in platform_defines:
    cxx_config.define(define)

  cxx_config.define("HAVE_SETXATTR")

  # Warnings

  cxx_config.warnings.parentheses = False
  cxx_config.warnings.empty_body = False
  # Clang/GCC disagree on std::hash struct versus class.
  cxx_config.warnings.mismatched_tags = False
  cxx_config.warnings.missing_declarations = \
    drake.cxx.Config.Warnings.Error
  cxx_config.warnings.return_type = \
    drake.cxx.Config.Warnings.Error
  cxx_config.warnings.delete_non_virtual_dtor = \
    drake.cxx.Config.Warnings.Error

  ## ----- ##
  ## Boost ##
  ## ----- ##

  boost = boost or drake.cxx.boost.Boost(cxx_toolkit = cxx_toolkit)
  cxx_config += boost.config()

  ## -------------------- ##
  ## Python configuration ##
  ## -------------------- ##

  try:
    python3 = drake.cxx.find_library(
      'pyconfig.h',
      prefix = python3,
      include_dir = [
        'include',
        'include/python3.2',
        'include/python3.2m',
      ],
      name = 'python3',
      libs = ('python3.2',),
      toolkit = cxx_toolkit)
  except:
    try:
      python3 = drake.cxx.find_library(
        'pyconfig.h',
        prefix = python3,
        include_dir = [
          'include',
          'include/python3.3',
          'include/python3.3m',
        ],
        name = 'python3',
        libs = ('python3.3',),
        toolkit = cxx_toolkit)
    except:
      python3 = drake.cxx.find_library(
        'pyconfig.h',
        prefix = python3,
        include_dir = [
          'include',
          'include/python3.4',
          'include/python3.4m',
        ],
        name = 'python3',
        libs = ('python3.4',),
        toolkit = cxx_toolkit)

  ## ------- ##
  ## Version ##
  ## ------- ##

  git = drake.git.Git()
  class CxxVersionGenerator(VersionGenerator):
    def _prologue(self):
      yield '#ifndef INFINIT_VERSION_HH'
      yield '# define INFINIT_VERSION_HH'
    def _epilogue(self):
      yield '#endif'
    def _variable(self, name, value):
      if name == 'version':
        name = 'INFINIT_VERSION'
      else:
        name = 'INFINIT_VERSION_%s' % name.upper()
      value = repr(value).replace("'", '"')
      return '# define %s %s' % (name, value)
  version = drake.node('version.hh')
  CxxVersionGenerator(version, git = git)

  architecture = platform.architecture()[0]
  if architecture == "32bit":
    architecture_wordsize = 32
  elif architecture == "64bit":
    architecture_wordsize = 64
  else:
    raise Exception("architecture %s not supported" % architecture)

  ## ---- ##
  ## Elle ##
  ## ---- ##

  elle = drake.include('elle',
                       cxx_toolkit,
                       drake.cxx.Config(cxx_config),
                       python3 = python3,
                       prefix = prefix,
                       boost = boost,
                       valgrind = valgrind)

  def copy_lib(lib, where = 'lib'):
    return drake.copy(lib, where, lib.path().dirname())

  elle_lib = copy_lib(elle.elle.library)
  cryptography_lib = copy_lib(elle.cryptography.library)
  reactor_lib = copy_lib(elle.reactor.library)
  if python3 is not None:
    reactor_python_lib = copy_lib(elle.reactor.python_lib, where='lib/python')
    python_build << reactor_python_lib
  protocol_lib = copy_lib(elle.protocol.library)
  aws_lib = copy_lib(elle.aws.library)

  cxx_config += elle.config
  cxx_config.add_local_include_path('.')

  cxx_config_libs = drake.cxx.Config(cxx_config)
  cxx_config_libs.lib_path_runtime('.')

  ## ------- ##
  ## Metrics ##
  ## ------- ##

  metrics = drake.include(
    'metrics',
    elle = elle.elle,
    reactor = elle.reactor,
    boost = boost,
    prefix = prefix,
    cxx_toolkit = cxx_toolkit,
    cxx_config = cxx_config,
    valgrind = valgrind,
  )

  metrics_lib = drake.copy(
    metrics.lib, 'lib',
    metrics.lib.name().dirname()
  )

  ## ------ ##
  ## Papier ##
  ## ------ ##

  papier_sources = drake.nodes(
    'papier/Authority.cc',
    'papier/Authority.hh',
    'papier/Authority.hxx',
    'papier/Identity.cc',
    'papier/Identity.hh',
    'papier/Identity.hxx',
    'papier/Passport.cc',
    'papier/Passport.hh',
    'papier/Passport.hxx',
  )

  papier_cxx_config = drake.cxx.Config(cxx_config_libs)

  papier_lib = Library(
    'lib/papier',
    papier_sources + [elle_lib, cryptography_lib],
    cxx_toolkit,
    papier_cxx_config
  )

  papier_python_lib = None
  if python3 is not None:
    papier_python_cxx_config = drake.cxx.Config(cxx_config)
    papier_python_sources = drake.nodes('papier/python.cc')
    papier_python_sources.append(papier_lib)
    papier_python_cxx_config += boost.config_filesystem(
      static = (cxx_toolkit.os is drake.os.macos and True or None))
    papier_python_cxx_config += python3
    if cxx_toolkit.os is drake.os.windows:
      papier_python_cxx_config.define('BOOST_PYTHON_STATIC_LIB')
      papier_python_cxx_config += boost.config_python(static = True)
      papier_python_cxx_config.flag('-Wl,-Bdynamic')
    else:
      papier_python_cxx_config += boost.config_python(link = False)
      papier_python_cxx_config.library_add(
        drake.copy(boost.python_dynamic, 'lib', strip_prefix = True))

    papier_python_cxx_config.lib_path_runtime('..')
    papier_python_lib = drake.cxx.Module(
      'lib/python/papier',
      papier_python_sources + [elle_lib, cryptography_lib],
      cxx_toolkit,
      papier_python_cxx_config)

  ## ------- ##
  ## Station ##
  ## ------- ##

  station_build = drake.Rule('station/build')
  station_sources = drake.nodes(
    'station/src/station/AlreadyConnected.cc',
    'station/src/station/AlreadyConnected.hh',
    'station/src/station/ConnectionFailure.hh',
    'station/src/station/InvalidPassport.cc',
    'station/src/station/InvalidPassport.hh',
    'station/src/station/NetworkError.cc',
    'station/src/station/NetworkError.hh',
    'station/src/station/Host.cc',
    'station/src/station/Host.hh',
    'station/src/station/Station.cc',
    'station/src/station/Station.hh',
  )
  cxx_config.add_local_include_path('station/src')
  cxx_config_libs.add_local_include_path('station/src')
  station_cxx_config = drake.cxx.Config(cxx_config_libs)

  station_lib = Library(
    'lib/station',
    station_sources + [papier_lib, cryptography_lib,
                       reactor_lib, elle_lib],
    cxx_toolkit,
    station_cxx_config
  )

  station_build << station_lib
  station_tests = drake.Rule('station/tests')
  station_check = drake.Rule('station/check')
  station_install = drake.Rule('station/install')
  station_cxx_config_tests = drake.cxx.Config(station_cxx_config)
  station_cxx_config_tests += boost.config_test()
  station_cxx_config_tests += boost.config_system()
  station_cxx_config_tests.lib_path_runtime('../../lib')
  for name in ['station']:
    test = drake.cxx.Executable(
      'station/tests/%s' % name,
      [
        drake.node('station/tests/%s.cc' % name),
        station_lib,
        papier_lib,
        cryptography_lib,
        reactor_lib,
        elle_lib,
      ],
      cxx_toolkit, station_cxx_config_tests)
    station_tests << test
    runner = drake.Runner(exe = test)
    station_check << runner.status

  ## ----- ##
  ## Frete ##
  ## ----- ##

  frete_build = drake.Rule('frete/build')
  frete_sources = drake.nodes(
    'frete/src/frete/Frete.hh',
    'frete/src/frete/Frete.cc',
    'frete/src/frete/TransferSnapshot.hh',
    'frete/src/frete/TransferSnapshot.cc',
    'frete/src/frete/RPCFrete.hh',
    'frete/src/frete/RPCFrete.cc',
    'frete/src/frete/fwd.hh',
  )
  cxx_config.add_local_include_path('frete/src')
  cxx_config_libs.add_local_include_path('frete/src')
  frete_cxx_config = drake.cxx.Config(cxx_config_libs)
  frete_lib = Library(
    'lib/frete',
    frete_sources + [protocol_lib, reactor_lib, elle_lib, cryptography_lib],
    cxx_toolkit,
    frete_cxx_config
  )

  frete_build << frete_lib
  frete_tests = drake.Rule('frete/tests')
  frete_check = drake.Rule('frete/check')
  frete_install = drake.Rule('frete/install')
  frete_cxx_config_tests = drake.cxx.Config(frete_cxx_config)
  frete_cxx_config_tests += boost.config_test()
  frete_cxx_config_tests += boost.config_system()
  frete_cxx_config_tests += boost.config_filesystem()
  frete_cxx_config_tests.lib_path_runtime('../../lib')
  for name in ['frete']:
    test = drake.cxx.Executable(
      'frete/tests/%s' % name,
      [
        drake.node('frete/tests/%s.cc' % name),
        frete_lib,
        protocol_lib,
        reactor_lib,
        elle_lib,
        cryptography_lib,
      ],
      cxx_toolkit, frete_cxx_config_tests)
    frete_tests << test
    runner = drake.Runner(exe = test)
    frete_check << runner.status

  ## ----- ##
  ## Crash ##
  ## ----- ##

  crash_sources = drake.nodes(
    'CrashReporter.cc',
    'CrashReporter.hh'
  )
  crash_cxx_config = drake.cxx.Config(cxx_config_libs)
  crash_lib = Library(
    'lib/crash',
    crash_sources + [elle_lib, reactor_lib],
    cxx_toolkit,
    crash_cxx_config
  )

  ## ----- ##
  ## Tests ##
  ## ----- ##

  tests << elle.rule_tests


  ## ----- ##
  ## Check ##
  ## ----- ##

  check << elle.rule_check

  ## ------- ##
  ## Oracles ##
  ## ------- ##

  oracles = drake.include(
    'oracles',
    elle = elle,
    papier_python = papier_python_lib,
    boost = boost,
    python3 = python3,
    prefix = prefix,
    cxx_toolkit = cxx_toolkit,
    cxx_config = cxx_config,
    valgrind = valgrind,
  )

  trophonius_client_lib = drake.copy(
    oracles.trophonius.client.lib, 'lib',
    oracles.trophonius.client.lib.name().dirname())
  meta_client_lib = drake.copy(
    oracles.meta.client.lib, 'lib',
    oracles.meta.client.lib.name().dirname())

  # oracles_enabled = cxx_toolkit.os != drake.os.windows

  ## --- ##
  ## GAP ##
  ## --- ##

  templating_context = drake.templating.Context(
    sources = oracles.meta.server.python,
    pythonpath = ('oracles/meta/server/lib/python',), # XXX
  )

  raw_gap_sources = [
    'surface/gap/Device.hh',
    'surface/gap/Exception.hh',
    'surface/gap/FilesystemTransferBufferer.cc',
    'surface/gap/FilesystemTransferBufferer.hh',
    'surface/gap/ReceiveMachine.cc',
    'surface/gap/ReceiveMachine.hh',
    'surface/gap/Rounds.cc',
    'surface/gap/Rounds.hh',
    # 'surface/gap/S3TransferBufferer.cc',
    # 'surface/gap/S3TransferBufferer.hh',
    'surface/gap/Self.hh',
    'surface/gap/SendMachine.cc',
    'surface/gap/SendMachine.hh',
    'surface/gap/State.cc',
    'surface/gap/State.hh',
    'surface/gap/Transaction.cc',
    'surface/gap/Transaction.hh',
    'surface/gap/Transaction.hxx',
    'surface/gap/TransactionMachine.cc',
    'surface/gap/TransactionMachine.hh',
    'surface/gap/TransactionMachine.hxx',
    'surface/gap/TransferBufferer.cc',
    'surface/gap/TransferBufferer.hh',
    'surface/gap/TransferMachine.cc',
    'surface/gap/TransferMachine.hh',
    'surface/gap/TransferMachine.hxx',
    'surface/gap/_detail/Network.cc',
    'surface/gap/_detail/Papiers.cc',
    'surface/gap/_detail/Transaction.cc',
    'surface/gap/_detail/User.cc',
    'surface/gap/enums.hh.tmpl',
    'surface/gap/gap.cc',
    'surface/gap/gap.hh',
    'surface/gap/gap_bridge.hh',
    'surface/gap/onboarding/fwd.hh',
    'surface/gap/onboarding/ReceiveMachine.cc',
    'surface/gap/onboarding/ReceiveMachine.hh',
    'surface/gap/onboarding/Transaction.cc',
    'surface/gap/onboarding/Transaction.hh',
    'surface/gap/onboarding/TransferMachine.cc',
    'surface/gap/onboarding/TransferMachine.hh',
    'surface/gap/status.hh.tmpl',
    # Get rid of common asap.
    'common/common.hh',
    'common/common.cc',
  ]

  with templating_context:
    gap_sources = drake.nodes(*raw_gap_sources)

  gap_build = drake.Rule('gap/build')
  gap_tests = drake.Rule('gap/tests')
  gap_check = drake.TestSuite('gap/check')
  gap_install = drake.TestSuite('gap/install')
  build << gap_build
  install << gap_install

  gap_cxx_config = drake.cxx.Config(cxx_config_libs)
  gap_cxx_config.add_local_include_path('metrics/src')
  gap_cxx_config.add_local_include_path('oracles/src')
  gap_cxx_config.add_local_include_path('oracles/meta/client/src')
  gap_cxx_config.add_local_include_path('oracles/trophonius/client/src')

  gap_cxx_config_libs = drake.cxx.Config(gap_cxx_config)
  gap_cxx_config_libs += boost.config_filesystem(
    static = (cxx_toolkit.os is drake.os.macos and True or None))
  gap_cxx_config_libs += boost.config_system()
  gap_cxx_config_libs += boost.config_signals()
  gap_cxx_config_libs += boost.config_thread()
  if cxx_toolkit.os == drake.os.windows:
    gap_cxx_config_libs.lib('shlwapi')
    gap_cxx_config_libs.lib('ws2_32')
    gap_cxx_config_libs.lib('gdi32')
    gap_cxx_config_libs.lib('mswsock')
  gap_lib = Library(
    'lib/gap',
    gap_sources + [
      aws_lib,
      trophonius_client_lib,
      meta_client_lib,
      frete_lib,
      station_lib,
      metrics_lib,
      crash_lib,
      papier_lib,
      protocol_lib,
      elle_lib,
      reactor_lib,
      cryptography_lib,
    ],
    cxx_toolkit,
    gap_cxx_config_libs
  )

  gap_build << gap_lib

  ## --- ##
  ## CLI ##
  ## --- ##

  cli_build = drake.Rule('cli/build')
  cli_cxx_config = drake.cxx.Config(cxx_config)
  cli_cxx_config.lib_path_runtime('../lib')
  cli_cxx_config.add_local_include_path('metrics/src')
  cli_cxx_config.add_local_include_path('oracles/src')
  cli_cxx_config.add_local_include_path('oracles/meta/client/src')
  cli_cxx_config.add_local_include_path('oracles/trophonius/client/src')
  if cxx_toolkit.os is drake.os.windows:
    cli_cxx_config += boost.config_program_options(static = True)
    cli_cxx_config += boost.config_system(static = True)
  else:
    cli_cxx_config += boost.config_program_options(link = False)
    cli_cxx_config.library_add(
      drake.copy(boost.program_options_dynamic,
                 'lib', strip_prefix = True))
    cli_cxx_config += boost.config_system(link = False)
    cli_cxx_config.library_add(
      drake.copy(boost.system_dynamic,
                 'lib', strip_prefix = True))

  cli_send_sources = drake.nodes(
    'satellites/send/Send.cc',
  )
  cli_send_bin = drake.cxx.Executable(
    'bin/8send',
    cli_send_sources + [gap_lib, elle_lib, reactor_lib, crash_lib],
    cxx_toolkit,
    cli_cxx_config
  )
  cli_build << cli_send_bin

  cli_recv_sources = drake.nodes(
    'satellites/recv/Recv.cc',
  )
  cli_recv_bin = drake.cxx.Executable(
    'bin/8recv',
    cli_recv_sources + [gap_lib, elle_lib, reactor_lib, crash_lib],
    cxx_toolkit,
    cli_cxx_config
  )
  cli_build << cli_recv_bin

  cli_onboard_sources = drake.nodes(
    'satellites/onboard/Onboard.cc',
  )
  cli_onboard_bin = drake.cxx.Executable(
    'bin/8onboard',
    cli_onboard_sources + [gap_lib, elle_lib, reactor_lib, crash_lib],
    cxx_toolkit,
    cli_cxx_config
  )
  cli_build << cli_onboard_bin

  build << cli_build

  ## ----- ##
  ## State ##
  ## ----- ##

  templating_context = drake.templating.Context(
    sources = oracles.meta.server.python,
    pythonpath = ('oracles/meta/server/lib/python',), # XXX
  )

  with templating_context:
    state_sources = drake.nodes(*raw_gap_sources)

  state_build = drake.Rule('state/build')
  state_tests = drake.Rule('state/tests')
  state_check = drake.TestSuite('state/check')
  state_install = drake.TestSuite('state/install')

  state_cxx_config = drake.cxx.Config(cxx_config_libs)
  state_cxx_config.add_local_include_path('metrics/src')
  state_cxx_config.add_local_include_path('oracles/src')
  state_cxx_config.add_local_include_path('oracles/meta/client/src')
  state_cxx_config.add_local_include_path('oracles/trophonius/client/src')

  state_cxx_config_libs = drake.cxx.Config(gap_cxx_config)
  state_cxx_config_libs += boost.config_filesystem(
    static = (cxx_toolkit.os is drake.os.macos and True or None))
  state_cxx_config_libs += boost.config_system()
  state_cxx_config_libs += boost.config_signals()
  state_cxx_config_libs += boost.config_thread()
  if cxx_toolkit.os == drake.os.windows:
    state_cxx_config_libs.lib('shlwapi')
    state_cxx_config_libs.lib('ws2_32')
    state_cxx_config_libs.lib('gdi32')
    state_cxx_config_libs.lib('mswsock')
  state_lib = Library(
    'lib/state',
    state_sources + [
      aws_lib,
      trophonius_client_lib,
      meta_client_lib,
      frete_lib,
      station_lib,
      metrics_lib,
      crash_lib,
      papier_lib,
      protocol_lib,
      elle_lib,
      reactor_lib,
      cryptography_lib,
    ],
    cxx_toolkit,
    state_cxx_config_libs
  )

  ## ------------ ##
  ## State python ##
  ## ------------ ##

  state_python_lib = None
  if python3 is not None:
    state_python_cxx_config = drake.cxx.Config(gap_cxx_config)
    state_python_cxx_config += python3
    state_python_cxx_config += boost.config_python()
    state_python_cxx_config.lib_path_runtime('..')
    state_python_sources = drake.nodes(
      'surface/gap/python/State.cc',
    )
    state_python_lib = drake.cxx.Module(
      'lib/python/state',
      state_python_sources + [
        state_lib,
      ],
      cxx_toolkit,
      state_python_cxx_config
    )
    python_build << state_python_lib

  ## ---------- ##
  ## GAP python ##
  ## ---------- ##

  gap_python_lib = None
  if python3 is not None:
    gap_python_cxx_config = drake.cxx.Config(gap_cxx_config)
    gap_python_cxx_config += python3
    gap_python_cxx_config.lib_path_runtime('..')
    if cxx_toolkit.os is drake.os.windows:
      gap_python_cxx_config.define('BOOST_PYTHON_STATIC_LIB')
      gap_python_cxx_config += boost.config_python(static = True)
      gap_python_cxx_config.flag('-Wl,-Bdynamic')
    else:
      gap_python_cxx_config += boost.config_python(link = False)
      gap_python_cxx_config.library_add(
        drake.copy(boost.python_dynamic, 'lib', strip_prefix = True))
    with templating_context:
      gap_python_sources = drake.nodes(
        'surface/gap/python/pygap.cc.tmpl',
      )

    gap_python_lib = drake.cxx.Module(
      'lib/python/_gap',
      gap_python_sources + [
        gap_lib,
      ],
      cxx_toolkit,
      gap_python_cxx_config
    )

    gap_python_pyfiles = drake.nodes(
      'surface/gap/python/gap.py',
    )

    gap_python_pyfile_copy = drake.copy(gap_python_pyfiles,
                                        'lib/python',
                                        'surface/gap/python')

    infinit_cli_sources = drake.nodes(
      'surface/cli/infinit-cli'
      )

    infinit_cli_copy = drake.copy(infinit_cli_sources,
                                  'bin',
                                  'surface/cli')

    gap_build << gap_python_lib
    gap_build << gap_python_pyfile_copy
    gap_build << infinit_cli_copy

    python_build << gap_python_lib

    # Top-level tests
    python_env = {
      'PYTHONPATH': 'oracles/lib/python:lib/python',
      'DUMPS': str(drake.path_source('tests/dumps')),
    }
    functional_check = drake.Rule('functional/check')
    functional_test_lib = drake.nodes(
    )
    for name in [
        'basic.py',
        'login',
    ]:
      test_node = drake.Node('tests/%s' % name)
      test_node.dependencies_add(oracles.oracles)
      test_node.dependencies_add(functional_test_lib)
      test_node.dependency_add(state_python_lib)
      runner = drake.Runner(exe = test_node, env = python_env)
      check << runner.status
      functional_check << runner.status

  if qt is not None:
    fist_cxx_config = drake.cxx.Config(cxx_config)
    if cxx_toolkit.os == drake.os.windows:
      libraries = [gap_lib]
    else:
      libraries = [gap_lib, elle_lib]
    fist_cxx_config += boost.config_filesystem(
      static = (cxx_toolkit.os is drake.os.macos and True or None))
    fist_cxx_config += boost.config_system()
    application = drake.include('fist-gui-qt',
                                cxx_toolkit = cxx_toolkit,
                                cxx_config = fist_cxx_config,
                                qt = qt,
                                prefix = prefix,
                                libraries = libraries)
    build << application.build
