import drake
import drake.cxx
import drake.cxx.boost
import drake.git
import drake.templating

import os
import sys
import platform

with open(str(drake.path_source('elle/drake-utils.py')), 'r') as f:
  exec(f.read(), globals(), globals())

def configure(cxx_toolkit = None,
              cxx_config = None,
              enable_horizon = False,
              optimization = True,
              prefix = '/usr',
              boost = None,
              python3 = None,
              build_type = "Development",
              enable_debug = True,
              valgrind = None):

  ## ----- ##
  ## Rules ##
  ## ----- ##

  build = drake.Rule('build')
  check = drake.TestSuite('check')
  install = drake.Rule('install')
  tests = drake.Rule('tests')

  prefix = drake.Path(os.path.abspath(prefix))

  ## ----------------- ##
  ## C++ Configuration ##
  ## ----------------- ##

  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()
  cxx_config = cxx_config or drake.cxx.Config()

  if cxx_toolkit.os == drake.os.windows:
    Library = drake.cxx.StaticLib
  else:
    Library = drake.cxx.DynLib

  if enable_debug:
    cxx_config.define("DEBUG")
    cxx_config.enable_debug_symbols()
  else:
    cxx_config.enable_optimization(True)
    cxx_config.define("NDEBUG")

  build_types = {
    'Development': (),
    'Production': ("INFINIT_PRODUCTION_BUILD",)
  }

  if build_type == 'Production':
    cxx_config.enable_optimization(2)

  if not build_type in build_types.keys():
    raise Exception(
      'build type %s is unknown, candidates are: %s' %
      (build_type, ', '.join(str(t) for t in build_types)))

  for define in build_types[build_type]:
    if isinstance(define, str):
      cxx_config.define(define, 1)
    else:
      cxx_config.define(define[0], define[1])

  platform_defines = ()
  if sys.platform.startswith('linux'):
    platform_defines = ("INFINIT_LINUX",)
  elif sys.platform == 'win32' or sys.platform == 'cygwin':
    platform_defines = ("INFINIT_WINDOWS",)
    cxx_config.define('INFINIT_WINDOWS')
    cxx_config.lib('shlwapi')
    cxx_config.lib('ws2_32')
    cxx_config.lib('gdi32')
    cxx_config.lib('mswsock')
  elif sys.platform == 'darwin':
    platform_defines = ("INFINIT_MACOSX", "HAVE_STATFS")
  else:
    raise Exception("platform %s not supported" % sys.platform)
  for define in platform_defines:
    cxx_config.define(define)

  cxx_config.define("HAVE_SETXATTR")

  # Warnings

  cxx_config.warnings.parentheses = False
  cxx_config.warnings.empty_body = False
  # Clang/GCC disagree on std::hash struct versus class.
  cxx_config.warnings.mismatched_tags = False
  cxx_config.warnings.missing_declarations = \
    drake.cxx.Config.Warnings.Error
  cxx_config.warnings.return_type = \
    drake.cxx.Config.Warnings.Error
  cxx_config.warnings.delete_non_virtual_dtor = \
    drake.cxx.Config.Warnings.Error

  ## ----- ##
  ## Boost ##
  ## ----- ##

  boost = boost or drake.cxx.boost.Boost(cxx_toolkit = cxx_toolkit)
  cxx_config += boost.config()

  ## -------------------- ##
  ## Python configuration ##
  ## -------------------- ##

  python_enabled = cxx_toolkit.os != drake.os.windows
  if python_enabled:
    python3 = drake.cxx.find_library(
      'pyconfig.h', prefix = python3,
      include_dir = ['include',
                     'include/python3.2',
                     'include/python3.2m',
                     'include/python3.3m'])

  ## ------- ##
  ## Version ##
  ## ------- ##

  git = drake.git.Git()
  class CxxVersionGenerator(VersionGenerator):
    def _prologue(self):
      yield '#ifndef INFINIT_VERSION_HH'
      yield '# define INFINIT_VERSION_HH'
    def _epilogue(self):
      yield '#endif'
    def _variable(self, name, value):
      if name == 'version':
        name = 'INFINIT_VERSION'
      else:
        name = 'INFINIT_VERSION_%s' % name.upper()
      value = repr(value).replace("'", '"')
      return '# define %s %s' % (name, value)
  version = drake.node('version.hh')
  CxxVersionGenerator(version, git = git)

  architecture = platform.architecture()[0]
  if architecture == "32bit":
    architecture_wordsize = 32
  elif architecture == "64bit":
    architecture_wordsize = 64
  else:
    raise Exception("architecture %s not supported" % architecture)

  ## ---- ##
  ## Elle ##
  ## ---- ##

  elle = drake.include('elle',
                       cxx_toolkit,
                       drake.cxx.Config(cxx_config),
                       python3 = python3,
                       prefix = prefix,
                       boost = boost,
                       valgrind = valgrind)

  def copy_lib(lib, where = 'lib'):
    return drake.copy(lib, where, lib.path().dirname())

  elle_lib = copy_lib(elle.elle.library)
  cryptography_lib = copy_lib(elle.cryptography.library)
  reactor_lib = copy_lib(elle.reactor.library)
  protocol_lib = copy_lib(elle.protocol.library)

  cxx_config += elle.config
  cxx_config.add_local_include_path('.')

  cxx_config_libs = drake.cxx.Config(cxx_config)
  cxx_config_libs.lib_path_runtime('.')

  ## ------- ##
  ## Metrics ##
  ## ------- ##

  metrics = drake.include(
    'metrics',
    elle = elle.elle,
    reactor = elle.reactor,
    boost = boost,
    prefix = prefix,
    cxx_toolkit = cxx_toolkit,
    cxx_config = cxx_config,
    valgrind = valgrind,
  )

  metrics_lib = drake.copy(
    metrics.lib, 'lib',
    metrics.lib.name().dirname()
  )

  ## ------ ##
  ## Papier ##
  ## ------ ##

  papier_sources = drake.nodes(
    'papier/Authority.cc',
    'papier/Authority.hh',
    'papier/Authority.hxx',
    'papier/Identity.cc',
    'papier/Identity.hh',
    'papier/Identity.hxx',
    'papier/Passport.cc',
    'papier/Passport.hh',
    'papier/Passport.hxx',
  )

  papier_cxx_config = drake.cxx.Config(cxx_config_libs)

  papier_lib = Library(
    'lib/papier',
    papier_sources + [elle_lib, cryptography_lib],
    cxx_toolkit,
    papier_cxx_config
  )

  papier_python_lib = None
  if python_enabled:
    papier_python_cxx_config = drake.cxx.Config(cxx_config)
    papier_python_sources = drake.nodes('papier/python.cc')
    papier_python_sources.append(papier_lib)
    if cxx_toolkit.os is drake.os.windows:
      papier_python_cxx_config += boost.config_python(static = True)
    else:
      papier_python_cxx_config += boost.config_python(link = False)
      papier_python_cxx_config.library_add(
        drake.copy(boost.python_dynamic, 'lib', strip_prefix = True))
    papier_python_cxx_config += python3
    papier_python_cxx_config.lib_path_runtime('..')
    papier_python_lib = drake.cxx.Module(
      'lib/python/papier',
      papier_python_sources,
      cxx_toolkit,
      papier_python_cxx_config)

  ## ------- ##
  ## Station ##
  ## ------- ##

  station_build = drake.Rule('station/build')
  station_sources = drake.nodes(
    'station/src/station/AlreadyConnected.cc',
    'station/src/station/AlreadyConnected.hh',
    'station/src/station/ConnectionFailure.hh',
    'station/src/station/InvalidPassport.cc',
    'station/src/station/InvalidPassport.hh',
    'station/src/station/NetworkError.cc',
    'station/src/station/NetworkError.hh',
    'station/src/station/Host.cc',
    'station/src/station/Host.hh',
    'station/src/station/Station.cc',
    'station/src/station/Station.hh',
  )
  cxx_config.add_local_include_path('station/src')
  cxx_config_libs.add_local_include_path('station/src')
  station_cxx_config = drake.cxx.Config(cxx_config_libs)

  station_lib = Library(
    'lib/station',
    station_sources + [papier_lib, cryptography_lib,
                       reactor_lib, elle_lib],
    cxx_toolkit,
    station_cxx_config
  )

  station_build << station_lib
  station_tests = drake.Rule('station/tests')
  station_check = drake.Rule('station/check')
  station_cxx_config_tests = drake.cxx.Config(station_cxx_config)
  station_cxx_config_tests += boost.config_test()
  station_cxx_config_tests += boost.config_system()
  station_cxx_config_tests.lib_path_runtime('../../lib')
  for name in ['station']:
    test = drake.cxx.Executable(
      'station/tests/%s' % name,
      [
        drake.node('station/tests/%s.cc' % name),
        station_lib,
        papier_lib,
        cryptography_lib,
        reactor_lib,
        elle_lib,
      ],
      cxx_toolkit, station_cxx_config_tests)
    station_tests << test
    runner = drake.Runner(exe = test)
    station_check << runner.status

  ## ----- ##
  ## Frete ##
  ## ----- ##

  frete_build = drake.Rule('frete/build')
  frete_sources = drake.nodes(
    'frete/src/frete/Frete.hh',
    'frete/src/frete/Frete.cc',
  )
  cxx_config.add_local_include_path('frete/src')
  cxx_config_libs.add_local_include_path('frete/src')
  frete_cxx_config = drake.cxx.Config(cxx_config_libs)
  frete_lib = Library(
    'lib/frete',
    frete_sources + [protocol_lib, reactor_lib, elle_lib, cryptography_lib],
    cxx_toolkit,
    frete_cxx_config
  )

  frete_build << frete_lib
  frete_tests = drake.Rule('frete/tests')
  frete_check = drake.Rule('frete/check')
  frete_cxx_config_tests = drake.cxx.Config(frete_cxx_config)
  frete_cxx_config_tests += boost.config_test()
  frete_cxx_config_tests += boost.config_system()
  frete_cxx_config_tests += boost.config_filesystem()
  frete_cxx_config_tests.lib_path_runtime('../../lib')
  for name in ['frete']:
    test = drake.cxx.Executable(
      'frete/tests/%s' % name,
      [
        drake.node('frete/tests/%s.cc' % name),
        frete_lib,
        protocol_lib,
        reactor_lib,
        elle_lib,
        cryptography_lib,
      ],
      cxx_toolkit, frete_cxx_config_tests)
    frete_tests << test
    runner = drake.Runner(exe = test)
    frete_check << runner.status

  ## ----- ##
  ## Crash ##
  ## ----- ##

  crash_sources = drake.nodes(
    'CrashReporter.cc',
    'CrashReporter.hh'
  )
  crash_cxx_config = drake.cxx.Config(cxx_config_libs)
  crash_lib = Library(
    'lib/crash',
    crash_sources + [elle_lib, reactor_lib],
    cxx_toolkit,
    crash_cxx_config
  )

  ## ----- ##
  ## Tests ##
  ## ----- ##

  tests << elle.rule_tests

  ## ----- ##
  ## Check ##
  ## ----- ##

  check << elle.rule_check

  ## ------- ##
  ## Oracles ##
  ## ------- ##

  oracles = drake.include(
    'oracles',
    elle = elle,
    papier_python = papier_python_lib,
    boost = boost,
    python3 = python3,
    enable_python_bindings = False,
    prefix = prefix,
    cxx_toolkit = cxx_toolkit,
    cxx_config = cxx_config,
    valgrind = valgrind,
  )

  trophonius_client_lib = drake.copy(
    oracles.trophonius.client.lib, 'lib',
    oracles.trophonius.client.lib.name().dirname())
  meta_client_lib = drake.copy(
    oracles.meta.client.lib, 'lib',
    oracles.meta.client.lib.name().dirname())

  # oracles_enabled = cxx_toolkit.os != drake.os.windows

  ## --- ##
  ## GAP ##
  ## --- ##

  templating_context = drake.templating.Context(
    sources = oracles.meta.server.python,
    pythonpath = ('oracles/meta/server/lib/python',), # XXX
  )
  with templating_context:
    gap_sources = drake.nodes(
      'surface/gap/Exception.hh',
      'surface/gap/Transaction.hh',
      'surface/gap/Transaction.cc',
      'surface/gap/Transaction.hxx',
      'surface/gap/gap.cc',
      'surface/gap/gap.h',
      'surface/gap/gap_bridge.hh',
      'surface/gap/enums.hh.tmpl',
      'surface/gap/TransferMachine.cc',
      'surface/gap/TransferMachine.hh',
      'surface/gap/TransferMachine.hxx',
      'surface/gap/SendMachine.cc',
      'surface/gap/SendMachine.hh',
      'surface/gap/ReceiveMachine.cc',
      'surface/gap/ReceiveMachine.hh',
      'surface/gap/State.cc',
      'surface/gap/State.hh',
      'surface/gap/status.hh.tmpl',
      'surface/gap/Transaction.hh',
      'surface/gap/Device.hh',
      'surface/gap/Self.hh',
      'surface/gap/Rounds.cc',
      'surface/gap/Rounds.hh',
      'surface/gap/_detail/Papiers.cc',
      'surface/gap/_detail/Network.cc',
      'surface/gap/_detail/Transaction.cc',
      'surface/gap/_detail/User.cc',
      # Get rid of common asap.
      'common/common.hh',
      'common/common.cc',
    )

  gap_build = drake.Rule('gap/build')
  gap_tests = drake.Rule('gap/tests')
  gap_check = drake.TestSuite('gap/check')
  gap_install = drake.TestSuite('gap/install')
  build << gap_build
  install << gap_install

  gap_cxx_config = drake.cxx.Config(cxx_config_libs)
  gap_cxx_config.add_local_include_path('metrics/src')
  gap_cxx_config.add_local_include_path('oracles/src')
  gap_cxx_config.add_local_include_path('oracles/meta/client/src')
  gap_cxx_config.add_local_include_path('oracles/trophonius/client/src')

  gap_cxx_config_libs = drake.cxx.Config(gap_cxx_config)
  gap_cxx_config_libs += boost.config_filesystem(
    static = (cxx_toolkit.os is drake.os.macos and True or None))
  gap_cxx_config_libs += boost.config_system()
  gap_cxx_config_libs += boost.config_signals()
  gap_cxx_config_libs += boost.config_thread()
  if cxx_toolkit.os == drake.os.windows:
    gap_cxx_config_libs.lib('shlwapi')
    gap_cxx_config_libs.lib('ws2_32')
    gap_cxx_config_libs.lib('gdi32')
    gap_cxx_config_libs.lib('mswsock')
  gap_lib = drake.cxx.DynLib(
    'lib/gap',
    gap_sources + [
      trophonius_client_lib,
      meta_client_lib,
      frete_lib,
      station_lib,
      metrics_lib,
      crash_lib,
      papier_lib,
      protocol_lib,
      elle_lib,
      reactor_lib,
      cryptography_lib,
    ],
    cxx_toolkit,
    gap_cxx_config_libs
  )

  gap_build << gap_lib

  ## ---------- ##
  ## GAP python ##
  ## ---------- ##

  gap_python_lib = None
  if python_enabled:
    gap_python_cxx_config = drake.cxx.Config(gap_cxx_config)
    gap_python_cxx_config += python3
    gap_python_cxx_config += boost.config_python()
    gap_python_cxx_config.lib_path_runtime('..')
    with templating_context:
      gap_python_sources = drake.nodes(
        'surface/gap/python/pygap.cc.tmpl',
      )

    gap_python_lib = drake.cxx.Module(
      'lib/python/_gap',
      gap_python_sources + [
        gap_lib,
      ],
      cxx_toolkit,
      gap_python_cxx_config
    )

    gap_python_pyfiles = drake.nodes(
      'surface/gap/python/gap.py',
    )

    gap_python_pyfile_copy = drake.copy(gap_python_pyfiles,
                                        'lib/python',
                                        'surface/gap/python')

    infinit_cli_sources = drake.nodes(
      'surface/cli/infinit-cli'
      )

    infinit_cli_copy = drake.copy(infinit_cli_sources,
                                  'bin',
                                  'surface/cli')

    gap_build << gap_python_lib
    gap_build << gap_python_pyfile_copy
    gap_build << infinit_cli_copy
