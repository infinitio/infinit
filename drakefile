import drake
import drake.cxx
import drake.cxx.boost
import drake.git

import os
import sys
import platform

def configure(cxx_toolkit = None,
              cxx_config = None,
              enable_horizon = True,
              optimization = True,
              prefix = '/usr',
              boost = None,
              python2 = None,
              python3 = None,
              build_type = "Development",
              enable_debug = True,
              valgrind = None):

  prefix = drake.Path(prefix)

  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()
  cxx_config = cxx_config or drake.cxx.Config()

  if cxx_toolkit.os == drake.os.windows:
    Library = drake.cxx.StaticLib
  else:
    Library = drake.cxx.DynLib

  if enable_debug:
    cxx_config.define("DEBUG")
    cxx_config.enable_debug_symbols()
  else:
    cxx_config.enable_optimization(True)
    cxx_config.define("NDEBUG")

  build_types = {
    'Development': (),
    'Production': ("INFINIT_PRODUCTION_BUILD",)
  }

  if build_type == 'Production':
    cxx_config.enable_optimization(2)

  if not build_type in build_types.keys():
    raise Exception("build type {} is unknown. Candidates are {}.".format(
        build_type, ", ".join("{}".format(t) for t in build_types.keys())))

  for define in build_types[build_type]:
    if isinstance(define, str):
      cxx_config.define(define, 1)
    else:
      cxx_config.define(define[0], define[1])

  platform_defines = ()
  if sys.platform.startswith('linux'):
    platform_defines = ("INFINIT_LINUX",)
  elif sys.platform == 'win32' or sys.platform == 'cygwin':
    platform_defines = ("INFINIT_WINDOWS",)
    cxx_config.define('INFINIT_WINDOWS')
    cxx_config.lib('Shlwapi')
    cxx_config.lib('ws2_32')
    cxx_config.lib('Gdi32')
    cxx_config.lib('mswsock')
  elif sys.platform == 'darwin':
    platform_defines = ("INFINIT_MACOSX", "HAVE_STATFS")
  else:
    raise Exception("platform %s not supported" % sys.platform)
  for define in platform_defines:
    cxx_config.define(define)

  cxx_config.define("HAVE_SETXATTR")

  # Version
  git = drake.git.Git()
  version = drake.node('version.hh')

  class VersionGenerator(drake.Builder):

    def __init__(self, git, output):
      drake.Builder.__init__(self, [git], [output])
      self.__git = git
      self.__output = output

    def execute(self):
      self.output('Generate %s' % self.__output.path())
      version = git.version()
      major, minor, subminor = map(int, version.split('-')[0].split('.'))
      defines = {
        'INFINIT_VERSION_MAJOR': major,
        'INFINIT_VERSION_MINOR': minor,
        'INFINIT_VERSION_SUBMINOR': subminor,
        'INFINIT_VERSION': version,
      }
      with open(str(self.__output.path()), 'w') as f:
        print('#ifndef INFINIT_VERSION_HH', file = f)
        print('# define INFINIT_VERSION_HH', file = f)
        for name, value in defines.items():
          print('# define %s %s' % (name, repr(value).replace("'", '"')), file = f)
        print('#endif', file = f)
      return True

  VersionGenerator(git, version)

  architecture = platform.architecture()[0]
  if architecture == "32bit":
    architecture_wordsize = 32
  elif architecture == "64bit":
    architecture_wordsize = 64
  else:
    raise Exception("architecture %s not supported" % architecture)

  # Boost
  boost = boost or drake.cxx.boost.Boost(cxx_toolkit = cxx_toolkit)
  cxx_config += boost.config()

  # Python
  python_enabled = cxx_toolkit.os != drake.os.windows
  if python_enabled:
    python2 = drake.cxx.find_library('pyconfig.h', prefix = python2,
                                     include_dir = ['include',
                                                    'include/python2.7',
                                                    'include/python2.7m'])
    python3 = drake.cxx.find_library('pyconfig.h', prefix = python3,
                                     include_dir = ['include',
                                                    'include/python3.2',
                                                    'include/python3.2m',
                                                    'include/python3.3m'])

  # Elle
  elle = drake.include('elle',
                       cxx_toolkit,
                       drake.cxx.Config(cxx_config),
                       prefix = prefix,
                       boost = boost,
                       valgrind = valgrind)

  def copy_lib(lib, where = 'lib'):
    return drake.copy(lib, where, lib.path().dirname())

  elle_lib = copy_lib(elle.elle.library)
  cryptography_lib = copy_lib(elle.cryptography.library)
  reactor_lib = copy_lib(elle.reactor.library)
  curly_lib = copy_lib(elle.curly.library)
  curly_asio_lib = copy_lib(elle.curly.library_asio)
  curly_sched_lib = copy_lib(elle.curly.library_sched)
  protocol_lib = copy_lib(elle.protocol.library)

  cxx_config += elle.config
  cxx_config.add_local_include_path('.')

  # Warnings
  cxx_config.warnings.parentheses = False
  cxx_config.warnings.empty_body = False
  # Clang/GCC disagree on std::hash struct versus class.
  cxx_config.warnings.mismatched_tags = False
  cxx_config.warnings.missing_declarations = \
    drake.cxx.Config.Warnings.Error
  cxx_config.warnings.return_type = \
    drake.cxx.Config.Warnings.Error
  cxx_config.warnings.delete_non_virtual_dtor = \
    drake.cxx.Config.Warnings.Error

  curly_libs = [
    curly_lib,
    curly_asio_lib,
    curly_sched_lib,
  ]

  # Fuse
  if enable_horizon:
    cxx_config.define('_FILE_OFFSET_BITS', 64) # FIXME: only needed for horizon
    cxx_config.define('INFINIT_HORIZON')
  cxx_config.define('BOOST_PP_VARIADICS')

  cxx_config_libs = drake.cxx.Config(cxx_config)
  cxx_config_libs.lib_path_runtime('.')

  # Lune
  lune_sources = drake.nodes(
    'lune/Configuration.cc',
    'lune/Configuration.hh',
    'lune/Dictionary.cc',
    'lune/Dictionary.hh',
    'lune/Dictionary.hxx',
    'lune/Lune.cc',
    'lune/Lune.hh',
    'lune/Map.hh',
    'lune/Map.hxx',
    'lune/Phrase.cc',
    'lune/Phrase.hh',
    'lune/Phrase.hxx',
    'lune/Set.cc',
    'lune/Set.hh',
    'lune/Set.hxx',
    'lune/fwd.hh',
    'common/common.cc',
    'common/common.hh',
  )
  lune_cxx_config = drake.cxx.Config(cxx_config_libs)
  lune_lib = Library(
    'lib/lune',
    lune_sources + [elle_lib, cryptography_lib],
    cxx_toolkit,
    lune_cxx_config
  )

  # Nucleus
  nucleus_sources = drake.nodes(
    'nucleus/Derivable.hh',
    'nucleus/Derivable.hxx',
    'nucleus/Exception.hh',
    'nucleus/Exception.cc',
    'nucleus/all.hh',
    'nucleus/factory.cc',
    'nucleus/factory.hh',
    'nucleus/fwd.hh',
    'nucleus/neutron/Access.cc',
    'nucleus/neutron/Access.hh',
    'nucleus/neutron/Access.hxx',
    'nucleus/neutron/Attributes.cc',
    'nucleus/neutron/Attributes.hh',
    'nucleus/neutron/Attributes.hxx',
    'nucleus/neutron/Author.cc',
    'nucleus/neutron/Author.hh',
    'nucleus/neutron/Author.hxx',
    'nucleus/neutron/Catalog.cc',
    'nucleus/neutron/Catalog.hh',
    'nucleus/neutron/Catalog.hxx',
    'nucleus/neutron/Component.cc',
    'nucleus/neutron/Component.hh',
    'nucleus/neutron/Data.cc',
    'nucleus/neutron/Data.hh',
    'nucleus/neutron/Data.hxx',
    'nucleus/neutron/Ensemble.cc',
    'nucleus/neutron/Ensemble.hh',
    'nucleus/neutron/Ensemble.hxx',
    'nucleus/neutron/Entry.cc',
    'nucleus/neutron/Entry.hh',
    'nucleus/neutron/Entry.hxx',
    'nucleus/neutron/Fellow.cc',
    'nucleus/neutron/Fellow.hh',
    'nucleus/neutron/Fellow.hxx',
    'nucleus/neutron/Genre.cc',
    'nucleus/neutron/Genre.hh',
    'nucleus/neutron/Group.cc',
    'nucleus/neutron/Group.hh',
    'nucleus/neutron/Group.hxx',
    'nucleus/neutron/Index.hh',
    'nucleus/neutron/Object.cc',
    'nucleus/neutron/Object.hh',
    'nucleus/neutron/Object.hxx',
    'nucleus/neutron/Offset.hh',
    'nucleus/neutron/Permissions.cc',
    'nucleus/neutron/Permissions.hh',
    'nucleus/neutron/Range.hh',
    'nucleus/neutron/Range.hxx',
    'nucleus/neutron/Record.cc',
    'nucleus/neutron/Record.hh',
    'nucleus/neutron/Record.hxx',
    'nucleus/neutron/Reference.cc',
    'nucleus/neutron/Reference.hh',
    'nucleus/neutron/Reference.hxx',
    'nucleus/neutron/Size.hh',
    'nucleus/neutron/Subject.cc',
    'nucleus/neutron/Subject.hh',
    'nucleus/neutron/Subject.hxx',
    'nucleus/neutron/Token.cc',
    'nucleus/neutron/Token.hh',
    'nucleus/neutron/Token.hxx',
    'nucleus/neutron/Trait.cc',
    'nucleus/neutron/Trait.hh',
    'nucleus/neutron/Trait.hxx',
    'nucleus/neutron/User.hh',
    'nucleus/neutron/all.hh',
    'nucleus/neutron/fwd.hh',
    'nucleus/nucleus.hh',
    'nucleus/proton/Address.cc',
    'nucleus/proton/Address.hh',
    'nucleus/proton/Address.hxx',
    'nucleus/proton/Ambit.hh',
    'nucleus/proton/Ambit.hxx',
    'nucleus/proton/Balancing.hh',
    'nucleus/proton/Base.cc',
    'nucleus/proton/Base.hh',
    'nucleus/proton/Base.hxx',
    'nucleus/proton/Block.cc',
    'nucleus/proton/Block.hh',
    'nucleus/proton/Block.hxx',
    'nucleus/proton/Capacity.hh',
    'nucleus/proton/Clef.cc',
    'nucleus/proton/Clef.hh',
    'nucleus/proton/Clef.hxx',
    'nucleus/proton/ContentHashBlock.cc',
    'nucleus/proton/ContentHashBlock.hh',
    'nucleus/proton/ContentHashBlock.hxx',
    'nucleus/proton/Contention.hh',
    'nucleus/proton/Contents.cc',
    'nucleus/proton/Contents.hh',
    'nucleus/proton/Contents.hxx',
    'nucleus/proton/Door.hh',
    'nucleus/proton/Door.hxx',
    'nucleus/proton/Egg.cc',
    'nucleus/proton/Egg.hh',
    'nucleus/proton/Extent.hh',
    'nucleus/proton/Family.cc',
    'nucleus/proton/Family.hh',
    'nucleus/proton/Flags.cc',
    'nucleus/proton/Flags.hh',
    'nucleus/proton/Footprint.hh',
    'nucleus/proton/Handle.cc',
    'nucleus/proton/Handle.hh',
    'nucleus/proton/Handle.hxx',
    'nucleus/proton/Height.hh',
    'nucleus/proton/History.cc',
    'nucleus/proton/History.hh',
    'nucleus/proton/History.hxx',
    'nucleus/proton/ImmutableBlock.cc',
    'nucleus/proton/ImmutableBlock.hh',
    'nucleus/proton/ImmutableBlock.hxx',
    'nucleus/proton/ImprintBlock.cc',
    'nucleus/proton/ImprintBlock.hh',
    'nucleus/proton/ImprintBlock.hxx',
    'nucleus/proton/Inlet.hh',
    'nucleus/proton/Inlet.hxx',
    'nucleus/proton/Limits.cc',
    'nucleus/proton/Limits.hh',
    'nucleus/proton/Location.cc',
    'nucleus/proton/Location.hh',
    'nucleus/proton/Location.hxx',
    'nucleus/proton/Mode.cc',
    'nucleus/proton/Mode.hh',
    'nucleus/proton/MutableBlock.cc',
    'nucleus/proton/MutableBlock.hh',
    'nucleus/proton/MutableBlock.hxx',
    'nucleus/proton/Nature.cc',
    'nucleus/proton/Nature.hh',
    'nucleus/proton/Nest.cc',
    'nucleus/proton/Nest.hh',
    'nucleus/proton/Network.cc',
    'nucleus/proton/Network.hh',
    'nucleus/proton/Network.hxx',
    'nucleus/proton/Node.cc',
    'nucleus/proton/Node.hh',
    'nucleus/proton/Node.hxx',
    'nucleus/proton/Nodule.hh',
    'nucleus/proton/Nodule.hxx',
    'nucleus/proton/OwnerKeyBlock.cc',
    'nucleus/proton/OwnerKeyBlock.hh',
    'nucleus/proton/OwnerKeyBlock.hxx',
    'nucleus/proton/Porcupine.hh',
    'nucleus/proton/Porcupine.hxx',
    'nucleus/proton/PublicKeyBlock.cc',
    'nucleus/proton/PublicKeyBlock.hh',
    'nucleus/proton/PublicKeyBlock.hxx',
    'nucleus/proton/Quill.hh',
    'nucleus/proton/Quill.hxx',
    'nucleus/proton/Radix.cc',
    'nucleus/proton/Radix.hh',
    'nucleus/proton/Radix.hxx',
    'nucleus/proton/Revision.cc',
    'nucleus/proton/Revision.hh',
    'nucleus/proton/Revision.hxx',
    'nucleus/proton/Root.cc',
    'nucleus/proton/Root.hh',
    'nucleus/proton/Root.hxx',
    'nucleus/proton/Seam.hh',
    'nucleus/proton/Seam.hxx',
    'nucleus/proton/Stamp.cc',
    'nucleus/proton/Stamp.hh',
    'nucleus/proton/Stamp.hxx',
    'nucleus/proton/State.cc',
    'nucleus/proton/State.hh',
    'nucleus/proton/Statistics.cc',
    'nucleus/proton/Statistics.hh',
    'nucleus/proton/Strategy.cc',
    'nucleus/proton/Strategy.hh',
    'nucleus/proton/Tree.hh',
    'nucleus/proton/Tree.hxx',
    'nucleus/proton/Value.cc',
    'nucleus/proton/Value.hh',
    'nucleus/proton/Value.hxx',
    'nucleus/proton/all.hh',
    'nucleus/proton/fwd.hh',
  )
  nucleus_cxx_config = drake.cxx.Config(cxx_config_libs)
  nucleus_lib = Library(
    'lib/nucleus',
    nucleus_sources + [elle_lib, cryptography_lib],
    cxx_toolkit,
    nucleus_cxx_config
  )

  ## ------- ##
  ## Metrics ##
  ## ------- ##

  metrics_sources = drake.nodes(
    'metrics/Key.cc',
    'metrics/Key.hh',
    'metrics/Key.hxx',
    'metrics/Kind.cc',
    'metrics/Kind.hh',
    'metrics/Metric.hh',
    'metrics/Reporter.cc',
    'metrics/Reporter.hh',
    'metrics/Reporter.hxx',
    'metrics/Service.cc',
    'metrics/Service.hh',
    'metrics/services/Google.cc',
    'metrics/services/Google.hh',
    'metrics/services/KISSmetrics.cc',
    'metrics/services/KISSmetrics.hh',
    'metrics/services/Infinit.cc',
    'metrics/services/Infinit.hh',
    'metrics/services/Mixpanel.cc',
    'metrics/services/Mixpanel.hh',)

  metrics_cxx_config = drake.cxx.Config(cxx_config_libs)
  metrics_lib = Library(
    'lib/metrics',
    metrics_sources + curly_libs + [elle_lib, cryptography_lib],
    cxx_toolkit,
    metrics_cxx_config
  )

  ## ------ ##
  ## Plasma ##
  ## ------ ##
  plasma_sources = drake.nodes(
    'plasma/meta/Client.cc',
    'plasma/meta/Client.hh',
    'plasma/meta/Client.hxx',
    'plasma/trophonius/Client.cc',
    'plasma/trophonius/Client.hh',
    'plasma/plasma.hh',
    'plasma/plasma.hxx',
    'plasma/plasma.cc',
    )

  plasma_cxx_config = drake.cxx.Config(cxx_config_libs)
  plasma_lib = Library(
    'lib/plasma',
    plasma_sources + curly_libs + [reactor_lib, elle_lib],
    cxx_toolkit,
    plasma_cxx_config
  )

  rule_plasma = drake.Rule('plasma')
  rule_plasma << plasma_lib

  if python_enabled:
    plasma_python_cxx_config = drake.cxx.Config(cxx_config)
    plasma_python_sources = plasma_sources + [
      drake.node('plasma/python.cc'),
      drake.node('plasma/trophonius/python.cc'),
      drake.node('plasma/meta/python.cc'),
    ]
    plasma_python_cxx_config += python3
    plasma_python_cxx_config += boost.config_python()
    plasma_python_cxx_config.lib_path_runtime('..')
    plasma_python_lib = drake.cxx.Module(
      'lib/python/plasma',
      plasma_python_sources + [plasma_lib],
      cxx_toolkit,
      plasma_python_cxx_config)
    rule_plasma << plasma_python_lib

  # Papier
  papier_sources = drake.nodes(
    'papier/Authority.cc',
    'papier/Authority.hh',
    'papier/Authority.hxx',
    'papier/Descriptor.cc',
    'papier/Descriptor.hh',
    'papier/Descriptor.hxx',
    'papier/Identity.cc',
    'papier/Identity.hh',
    'papier/Identity.hxx',
    'papier/Passport.cc',
    'papier/Passport.hh',
    'papier/Passport.hxx',
    'hole/Openness.cc',
    'hole/Openness.hh',
    'hole/Model.cc',
    'hole/Model.hh',
    'hole/Model.hxx',
    'horizon/Policy.cc',
    'horizon/Policy.hh',
    'common/common.cc', # FIXME: papier must not use common.
  )

  papier_cxx_config = drake.cxx.Config(cxx_config_libs)
  papier_lib = Library(
    'lib/papier',
    papier_sources + [nucleus_lib, elle_lib, cryptography_lib],
    cxx_toolkit,
    papier_cxx_config
  )

  if python_enabled:
    papier_python_cxx_config = drake.cxx.Config(cxx_config)
    papier_python_sources = drake.nodes('papier/python.cc')
    papier_python_cxx_config += python3
    papier_python_cxx_config += boost.config_python()
    papier_python_cxx_config.lib_path_runtime('..')
    papier_python_lib = drake.cxx.Module(
      'lib/python/papier',
      papier_python_sources + [papier_lib],
      cxx_toolkit,
      papier_python_cxx_config)

  # Agent
  agent_sources = drake.nodes(
    'agent/Agent.hh',
    'agent/Agent.cc',
    'common/common.cc',
    'common/common.hh',
    )
  agent_cxx_config = drake.cxx.Config(cxx_config_libs)
  agent_lib = Library(
    'lib/agent',
    agent_sources + [elle_lib, papier_lib, nucleus_lib, lune_lib],
    cxx_toolkit,
    agent_cxx_config
  )

  # Station
  station_build = drake.Rule('station/build')
  station_sources = drake.nodes(
    'station/src/station/AlreadyConnected.cc',
    'station/src/station/AlreadyConnected.hh',
    'station/src/station/ConnectionFailure.hh',
    'station/src/station/InvalidPassport.cc',
    'station/src/station/InvalidPassport.hh',
    'station/src/station/NetworkError.cc',
    'station/src/station/NetworkError.hh',
    'station/src/station/Host.cc',
    'station/src/station/Host.hh',
    'station/src/station/Station.cc',
    'station/src/station/Station.hh',
  )
  cxx_config.add_local_include_path('station/src')
  cxx_config_libs.add_local_include_path('station/src')
  station_cxx_config = drake.cxx.Config(cxx_config_libs)

  station_lib = Library(
    'lib/station',
    station_sources + [papier_lib, cryptography_lib, reactor_lib, elle_lib],
    cxx_toolkit,
    station_cxx_config
  )

  station_build << station_lib
  station_tests = drake.Rule('station/tests')
  station_check = drake.Rule('station/check')
  station_cxx_config_tests = drake.cxx.Config(station_cxx_config)
  station_cxx_config_tests += boost.config_test()
  station_cxx_config_tests += boost.config_system()
  station_cxx_config_tests.lib_path_runtime('../../lib')
  for name in ['station']:
    test = drake.cxx.Executable(
      'station/tests/%s' % name,
      [
        drake.node('station/tests/%s.cc' % name),
        station_lib,
        papier_lib,
        cryptography_lib,
        reactor_lib,
        elle_lib,
        nucleus_lib,
      ],
      cxx_toolkit, station_cxx_config_tests)
    station_tests << test
    runner = drake.Runner(exe = test)
    station_check << runner.status

  # Frete
  frete_build = drake.Rule('frete/build')
  frete_sources = drake.nodes(
    'frete/src/frete/Frete.hh',
    'frete/src/frete/Frete.cc',
  )
  cxx_config.add_local_include_path('frete/src')
  cxx_config_libs.add_local_include_path('frete/src')
  frete_cxx_config = drake.cxx.Config(cxx_config_libs)
  frete_lib = Library(
    'lib/frete',
    frete_sources + [protocol_lib, reactor_lib, elle_lib],
    cxx_toolkit,
    frete_cxx_config
  )

  frete_build << frete_lib
  frete_tests = drake.Rule('frete/tests')
  frete_check = drake.Rule('frete/check')
  frete_cxx_config_tests = drake.cxx.Config(frete_cxx_config)
  frete_cxx_config_tests += boost.config_test()
  frete_cxx_config_tests += boost.config_system()
  frete_cxx_config_tests.lib_path_runtime('../../lib')
  for name in ['frete']:
    test = drake.cxx.Executable(
      'frete/tests/%s' % name,
      [
        drake.node('frete/tests/%s.cc' % name),
        frete_lib,
        protocol_lib,
        reactor_lib,
        elle_lib,
      ],
      cxx_toolkit, frete_cxx_config_tests)
    frete_tests << test
    runner = drake.Runner(exe = test)
    frete_check << runner.status

  # Crash
  crash_sources = drake.nodes(
    'CrashReporter.cc',
    'CrashReporter.hh'
  )
  crash_cxx_config = drake.cxx.Config(cxx_config_libs)
  crash_lib = Library(
    'lib/crash',
    crash_sources + curly_libs + [elle_lib, reactor_lib],
    cxx_toolkit,
    crash_cxx_config
  )

  # Infinit
  infinit_sources = drake.nodes(
    # 'HoleFactory.cc',
    #'heartbeat.cc',
    #'heartbeat.hh',
    'Infinit.cc',
    'Program.cc',
    'Program.hh',
    'common/common.hh',
    'common/common.cc',
    ) + [version]
  infinit_cxx_config = drake.cxx.Config(cxx_config_libs)
  infinit_lib = Library(
    'lib/infinit',
    infinit_sources + [
      lune_lib,
      cryptography_lib,
      elle_lib,
      crash_lib,
      metrics_lib,
      reactor_lib
    ],
    cxx_toolkit,
    infinit_cxx_config
  )

  # Hole
  hole_sources = drake.nodes(
    'hole/Exception.cc',
    'hole/Exception.hh',
    'hole/Hole.cc',
    'hole/Hole.hh',
    'hole/Label.cc',
    'hole/Label.hh',
    'hole/Label.hxx',
    'hole/Openness.cc',
    'hole/Openness.hh',
    'hole/algorithms/assignment/Assignment.hh',
    'hole/fwd.hh',
    'hole/implementations/Implementations.hh',
    # 'hole/implementations/cirkle/Cirkle.cc',
    # 'hole/implementations/cirkle/Cirkle.hh',
    # 'hole/implementations/cirkle/Cluster.cc',
    # 'hole/implementations/cirkle/Cluster.hh',
    # 'hole/implementations/cirkle/Cluster.hxx',
    # 'hole/implementations/cirkle/Implementation.cc',
    # 'hole/implementations/cirkle/Implementation.hh',
    # 'hole/implementations/cirkle/Machine.cc',
    # 'hole/implementations/cirkle/Machine.hh',
    # 'hole/implementations/cirkle/Manifest.hh',
    # 'hole/implementations/cirkle/Neighbour.cc',
    # 'hole/implementations/cirkle/Neighbour.hh',
    # 'hole/implementations/cirkle/Neighbourhood.cc',
    # 'hole/implementations/cirkle/Neighbourhood.hh',
    # 'hole/implementations/cirkle/RoutingTable.cc',
    # 'hole/implementations/cirkle/RoutingTable.hh',
    'hole/implementations/local/Implementation.cc',
    'hole/implementations/local/Implementation.hh',
    'hole/implementations/local/Local.cc',
    'hole/implementations/local/Local.hh',
    'hole/implementations/local/Machine.cc',
    'hole/implementations/local/Machine.hh',
    'hole/implementations/local/fwd.hh',
    'hole/implementations/remote/Client.cc',
    'hole/implementations/remote/Client.hh',
    'hole/implementations/remote/Customer.cc',
    'hole/implementations/remote/Customer.hh',
    'hole/implementations/remote/Implementation.cc',
    'hole/implementations/remote/Implementation.hh',
    'hole/implementations/remote/Machine.cc',
    'hole/implementations/remote/Machine.hh',
    'hole/implementations/remote/Manifest.cc',
    'hole/implementations/remote/Manifest.hh',
    'hole/implementations/remote/Remote.cc',
    'hole/implementations/remote/Remote.hh',
    'hole/implementations/remote/Server.cc',
    'hole/implementations/remote/Server.hh',
    'hole/implementations/remote/fwd.hh',
    'hole/implementations/slug/Host.cc',
    'hole/implementations/slug/Host.hh',
    'hole/implementations/slug/Slug.cc',
    'hole/implementations/slug/Slug.hh',
    'hole/implementations/slug/Manifest.cc',
    'hole/implementations/slug/Manifest.hh',
    'hole/implementations/slug/fwd.hh',
    'hole/storage/Storage.cc',
    'hole/storage/Storage.hh',
    'hole/storage/Directory.cc',
    'hole/storage/Directory.hh',
    'hole/storage/Memory.cc',
    'hole/storage/Memory.hh',
    'common/common.hh',
    'common/common.cc',
    )
  hole_cxx_config = drake.cxx.Config(cxx_config_libs)
  hole_lib = Library(
    'lib/hole',
    hole_sources + [
      elle_lib,
      nucleus_lib,
      cryptography_lib,
      papier_lib,
      lune_lib,
      reactor_lib
    ],
    cxx_toolkit,
    hole_cxx_config
  )

# XXX
#  hole_tests_root = drake.Path('hole/tests')
#  for test in ['slug']:
#    drake.cxx.Executable(hole_tests_root / test,
#                         drake.nodes(hole_tests_root / ('%s.cc' % test)) +
#                         [reactor.lib_dynamic, elle.lib_dynamic, cryptography_lib,
#                          hole_lib, nucleus_lib, protocol_lib],
#                         cxx_toolkit, cxx_config + boost.config_test())

  # Etoile
  etoile_sources = drake.nodes(
    'etoile/Etoile.cc',
    'etoile/Etoile.hh',
    'etoile/Exception.hh',
    'etoile/Exception.cc',
    'etoile/Manifest.cc',
    'etoile/Manifest.hh',
    'etoile/abstract/Group.cc',
    'etoile/abstract/Group.hh',
    'etoile/abstract/Group.hxx',
    'etoile/abstract/Object.cc',
    'etoile/abstract/Object.hh',
    'etoile/abstract/Object.hxx',
    'etoile/abstract/fwd.hh',
    'etoile/automaton/Access.cc',
    'etoile/automaton/Access.hh',
    'etoile/automaton/Attributes.cc',
    'etoile/automaton/Attributes.hh',
    'etoile/automaton/Author.cc',
    'etoile/automaton/Author.hh',
    'etoile/automaton/Automaton.hh',
    'etoile/automaton/Contents.hh',
    'etoile/automaton/Contents.hxx',
    'etoile/automaton/Directory.cc',
    'etoile/automaton/Directory.hh',
    'etoile/automaton/Ensemble.cc',
    'etoile/automaton/Ensemble.hh',
    'etoile/automaton/File.cc',
    'etoile/automaton/File.hh',
    'etoile/automaton/Group.cc',
    'etoile/automaton/Group.hh',
    'etoile/automaton/Link.cc',
    'etoile/automaton/Link.hh',
    'etoile/automaton/Object.cc',
    'etoile/automaton/Object.hh',
    'etoile/automaton/Rights.cc',
    'etoile/automaton/Rights.hh',
    'etoile/automaton/Rights.hxx',
    'etoile/depot/Depot.cc',
    'etoile/depot/Depot.hh',
    'etoile/depot/Depot.hxx',
    'etoile/fwd.hh',
    'etoile/gear/Action.cc',
    'etoile/gear/Action.hh',
    'etoile/gear/Action.hxx',
    'etoile/gear/Actor.cc',
    'etoile/gear/Actor.hh',
    'etoile/gear/Chronicle.hh',
    'etoile/gear/Context.cc',
    'etoile/gear/Context.hh',
    'etoile/gear/Directory.cc',
    'etoile/gear/Directory.hh',
    'etoile/gear/File.cc',
    'etoile/gear/File.hh',
    'etoile/gear/Group.cc',
    'etoile/gear/Group.hh',
    'etoile/gear/Guard.cc',
    'etoile/gear/Guard.hh',
    'etoile/gear/Identifier.cc',
    'etoile/gear/Identifier.hh',
    'etoile/gear/Identifier.hxx',
    'etoile/gear/Link.cc',
    'etoile/gear/Link.hh',
    'etoile/gear/Nature.hh',
    'etoile/gear/Object.cc',
    'etoile/gear/Object.hh',
    'etoile/gear/Operation.hh',
    'etoile/gear/Scope.cc',
    'etoile/gear/Scope.hh',
    'etoile/gear/Scope.hxx',
    'etoile/gear/Transcript.cc',
    'etoile/gear/Transcript.hh',
    'etoile/gear/fwd.hh',
    'etoile/journal/Journal.cc',
    'etoile/journal/Journal.hh',
    'etoile/nest/Nest.cc',
    'etoile/nest/Nest.hh',
    'etoile/nest/Pod.cc',
    'etoile/nest/Pod.hh',
    'etoile/nest/fwd.hh',
    'etoile/path/Chemin.cc',
    'etoile/path/Chemin.hh',
    'etoile/path/Chemin.hxx',
    'etoile/path/Length.hh',
    'etoile/path/Path.cc',
    'etoile/path/Path.hh',
    'etoile/path/Route.cc',
    'etoile/path/Route.hh',
    'etoile/path/Route.hxx',
    'etoile/path/Slice.hh',
    'etoile/path/Venue.cc',
    'etoile/path/Venue.hh',
    'etoile/path/Venue.hxx',
    'etoile/path/fwd.hh',
    'etoile/shrub/Riffle.cc',
    'etoile/shrub/Riffle.hh',
    'etoile/shrub/Shrub.cc',
    'etoile/shrub/Shrub.hh',
    'etoile/wall/Access.cc',
    'etoile/wall/Access.hh',
    'etoile/wall/Attributes.cc',
    'etoile/wall/Attributes.hh',
    'etoile/wall/Directory.cc',
    'etoile/wall/Directory.hh',
    'etoile/wall/File.cc',
    'etoile/wall/File.hh',
    'etoile/wall/Group.cc',
    'etoile/wall/Group.hh',
    'etoile/wall/Link.cc',
    'etoile/wall/Link.hh',
    'etoile/wall/Object.cc',
    'etoile/wall/Object.hh',
    'etoile/wall/Object.hxx',
    'etoile/wall/Path.cc',
    'etoile/wall/Path.hh',
    'etoile/wall/Wall.hh',
    )
  etoile_cxx_config = drake.cxx.Config(cxx_config_libs)
  etoile_lib = Library(
    'lib/etoile',
    etoile_sources + [hole_lib],
    cxx_toolkit,
    etoile_cxx_config
  )

  # Horizon
  if enable_horizon:
    horizon_sources = drake.nodes(
      'horizon/Crib.cc',
      'horizon/Crib.hh',
      # 'horizon/Crux.cc',
      'horizon/Handle.cc',
      'horizon/Handle.hh',
      'horizon/Horizon.cc',
      'horizon/Horizon.hh',
      'horizon/operations.hh',
      'horizon/Policy.cc',
      'horizon/Policy.hh',
      )
    if cxx_toolkit.os == drake.os.linux:
      horizon_sources += drake.nodes(
        'horizon/linux/FUSE.cc',
        'horizon/linux/FUSE.hh',
        'horizon/linux/FUker.cc',
        'horizon/linux/FUker.hh',
        'horizon/linux/Linux.cc',
        'horizon/linux/Linux.hh',
        'horizon/linux/fwd.hh',
        )
    elif cxx_toolkit.os == drake.os.macos:
      horizon_sources += drake.nodes(
        'horizon/macosx/Crux.hh',
        'horizon/macosx/Crux.cc',
        'horizon/macosx/FUSE.hh',
        'horizon/macosx/FUSE.cc',
        'horizon/macosx/FUker.hh',
        'horizon/macosx/FUker.cc',
        'horizon/macosx/MacOSX.hh',
        'horizon/macosx/MacOSX.cc',
        'horizon/macosx/fwd.hh',
        )
    else:
      raise Exception('cannot compile horizon: unsupported os')

    horizon_lib = Library(
      'lib/horizon',
      horizon_sources,
      cxx_toolkit,
      cxx_config
    )

  ## ----- ##
  ## Tests ##
  ## ----- ##

  tests = drake.Rule('tests')
  tests << elle.rule_tests

  ## ----- ##
  ## Check ##
  ## ----- ##

  check = drake.TestSuite('check')
  check << elle.rule_check

  ## ----- ##
  ## Build ##
  ## ----- ##

  build = drake.Rule('build')
  if python_enabled:
    build << plasma_python_lib

  ## -------- ##
  ## Programs ##
  ## -------- ##

  infinit_libs = [
    # asio_fs_lib,
    agent_lib,
    etoile_lib,
    hole_lib,
    papier_lib,
    infinit_lib,
    lune_lib,
    nucleus_lib,
    plasma_lib,
    cryptography_lib,
    protocol_lib,
    reactor_lib,
    elle_lib,
    metrics_lib,
  ]
  infinit_libs += curly_libs

  if enable_horizon:
    infinit_libs.append(horizon_slib)

  # 8infinit
  infinit_bin_config = drake.cxx.Config(cxx_config)
  infinit_bin_config += boost.config_thread()
  infinit_bin_config += boost.config_program()
  infinit_bin_config += boost.config_system()
  infinit_bin_config += boost.config_filesystem()
  infinit_bin_config.lib_path_runtime('../lib')
  if enable_horizon:
    infinit_bin_config.lib('fuse')
    infinit_bin_config.lib('pthread')

  infinit_sources = drake.nodes(
      '_infinit.cc',
      'satellites/satellite.cc',
      'satellites/satellite.hh'
  )
  infinit_bin = drake.cxx.Executable('bin/8infinit',
                                     infinit_sources + infinit_libs,
                                     cxx_toolkit, infinit_bin_config)
  # build << infinit_bin

  # GdbMacro
  gdbmacro_files = drake.nodes(
    'default/gdbmacro.py',
    )
  macro_copy = drake.copy(gdbmacro_files, 'bin', 'default')

  build << macro_copy

  # 8hole
  hole_cxx_config = drake.cxx.Config(cxx_config)
  hole_cxx_config.lib('fuse')
  hole_bin = drake.cxx.Executable('bin/8hole',
                                  drake.nodes('hole/_hole.cc') + infinit_libs,
                                  cxx_toolkit, hole_cxx_config)
  # build << hole_bin

  # Trophonius

  tropho_sources = drake.nodes(
    'plasma/trophonius/Client.cc',
    'plasma/trophonius/Client.hh',
    )
  tropho_lib = drake.cxx.DynLib(
    'lib/trophonius',
    tropho_sources,
    cxx_toolkit, cxx_config)

  ## GAP:
  gap_sources = drake.nodes(
    'surface/gap/Exception.hh',
    'surface/gap/Transaction.hh',
    'surface/gap/Transaction.cc',
    'surface/gap/Transaction.hxx',
    'surface/gap/gap.cc',
    'surface/gap/gap.h',
    'surface/gap/gap_bridge.hh',
    'surface/gap/enums.hh',
    'surface/gap/TransferMachine.cc',
    'surface/gap/TransferMachine.hh',
    'surface/gap/TransferMachine.hxx',
    'surface/gap/SendMachine.cc',
    'surface/gap/SendMachine.hh',
    'surface/gap/ReceiveMachine.cc',
    'surface/gap/ReceiveMachine.hh',
    'surface/gap/metrics.hh',
    'surface/gap/State.cc',
    'surface/gap/State.hh',
    'surface/gap/status.hh',
    'surface/gap/Transaction.hh',
    'surface/gap/Device.hh',
    'surface/gap/Self.hh',
    'surface/gap/Rounds.cc',
    'surface/gap/Rounds.hh',
    'surface/gap/_detail/Papiers.cc',
    'surface/gap/_detail/Network.cc',
    'surface/gap/_detail/Transaction.cc',
    'surface/gap/_detail/User.cc',
    # Get rid of common asap.
    'common/common.hh',
    'common/common.cc',
  )

  # GAP
  gap_generator = drake.node('surface/gap/metrics_generator.py')
  class GAPGenerator(drake.Builder):
    def __init__(self, script, path, python_exe = 'python3'):
      self.__script = script
      self.__path = path
      self.__targets = drake.nodes('%s.hh' % path, '%s.h' % path)
      self.__python_exe = python_exe
      drake.Builder.__init__(self, [self.__script], self.__targets)

    def execute(self):
      return self.cmd(
        'Generate %s' % ', '.join(map(str, self.__targets)),
        [self.__python_exe, self.__script.path(), self.__path]
      )

    @property
    def generated(self):
      return self.__targets

  gap_sources += GAPGenerator(
    gap_generator,
    'surface/gap/gen_metrics',
    python_exe = cxx_toolkit.os is drake.os.windows and 'python' or 'python3',
  ).generated

  gap_cxx_config_libs = drake.cxx.Config(cxx_config_libs)
  gap_cxx_config_libs.lib_path_runtime('../../lib/_gap')
  gap_cxx_config_libs += boost.config_filesystem(
    static = (cxx_toolkit.os is drake.os.macos and True or None))
  gap_cxx_config_libs += boost.config_system()
  gap_cxx_config_libs += boost.config_signals()
  gap_cxx_config_libs += boost.config_thread()
  if cxx_toolkit.os == drake.os.windows:
    gap_cxx_config_libs.lib('Gdi32')
    gap_cxx_config_libs.lib('Mswsock')
  gap_lib = drake.cxx.DynLib(
    'lib/gap',
    gap_sources + [
      elle_lib,
      plasma_lib,
      reactor_lib,
      lune_lib,
      papier_lib,
      station_lib,
      frete_lib,
      metrics_lib,
      crash_lib,
      hole_lib,
      curly_lib,
      elle.curly.library_sched,
      elle.curly.library_asio,
      elle.curly.library_curl,
      elle.reactor.library_coroutine,
      nucleus_lib,
      protocol_lib,
      cryptography_lib,
      elle.elle.library_zlib,
    ] + elle.cryptography.openssl_libs,
    cxx_toolkit,
    gap_cxx_config_libs
  )

  build << gap_lib

  # GAP python
  if python_enabled:
    gap_python_cxx_config = cxx_config + python3
    gap_python_cxx_config += boost.config_python()
    gap_python_cxx_config.lib_path_runtime('..')
    gap_python_sources = drake.nodes(
      'surface/gap/python/pygap.cc',
      )
    gap_python_lib = drake.cxx.Module(
      'lib/python/_gap',
      gap_python_sources + [
        gap_lib,
        tropho_lib,
        plasma_lib,
        protocol_lib
      ] + infinit_libs,
      cxx_toolkit,
      gap_python_cxx_config
    )

    gap_python_pyfiles = drake.nodes(
      'surface/gap/python/gap.py',
    )

    gap_python_pyfile_copy = drake.copy(gap_python_pyfiles,
                                        'lib/python',
                                        'surface/gap/python')

    infinit_cli_sources = drake.nodes(
      'surface/cli/infinit-cli'
      )

    infinit_cli_copy = drake.copy(infinit_cli_sources,
                                  'bin',
                                  'surface/cli')

    build << gap_python_lib
    build << gap_python_pyfile_copy
    build << infinit_cli_copy

  # Satellites

  def satellite(name, dependencies):
    fmt = (name, name.capitalize())
    sources = [
      'satellites/%s/%s.cc' % fmt,
      'satellites/%s/%s.hh' % fmt,
      'satellites/%s/%s.hxx' % fmt,
      'satellites/satellite.cc',
      'satellites/satellite.hh',
    ]
    sources = filter(lambda p: drake.path_source(p).exists(), sources)
    sources = map(drake.node, sources)
    bin = drake.cxx.Executable(
      'bin/8%s' % name,
      # XXX: not every satellite needs GAP.
      list(sources) + list(dependencies) + [crash_lib],
      cxx_toolkit, infinit_bin_config)
    build << bin

  for name, dependencies in [
    # 'access',
    # 'authority',
    # 'group',
    # 'network',
    # 'passport',
    # 'progress',
    # 'send',
    # 'transfer',
    # 'user',
    # 'dump',
    ('recv', (gap_lib, elle_lib, reactor_lib, lune_lib, crash_lib)),
    ('send', (gap_lib, elle_lib, reactor_lib, lune_lib, crash_lib)),
    ]:
    satellite(name, dependencies)

  # infinit-agent
  agent_sources = drake.nodes(
    'satellites/agent/infinit-agent.py'
    )
  agent_copy = drake.copy(agent_sources, 'bin', 'satellites/agent')
  build << agent_copy

  # 8search
  search_sources = drake.nodes(
    'satellites/search/8search.py',
    )
  search_copy = drake.copy(search_sources, 'bin', 'satellites/search')
  build << search_copy

  # 8d00m
  d00m_sources = drake.nodes(
    'satellites/d00m/8d00m.py'
    )
  d00m_copy = drake.copy(d00m_sources, 'bin', 'satellites/d00m')
  build << d00m_copy

  # 8sendto
  sendto_sources = drake.nodes(
    'satellites/sendto/8sendto.py',
    )
  sendto_copy = drake.copy(sendto_sources, 'bin', 'satellites/sendto')
  build << sendto_copy

  # 8recvfrom
  recvfrom_sources = drake.nodes(
    'satellites/recvfrom/8recvfrom.py',
    )
  recvfrom_copy = drake.copy(recvfrom_sources, 'bin', 'satellites/recvfrom')
  build << recvfrom_copy

  # Oracles

  oracles_enabled = cxx_toolkit.os != drake.os.windows
  if oracles_enabled:
    oracles = drake.Rule('oracle')

    oracle_sources = drake.nodes(
      'oracle/disciples/erginus-server',
      'oracle/disciples/longinus-server',
      'oracle/disciples/meta-server',
      'oracle/disciples/admin-console',
      'oracle/disciples/apertus-server',
      'oracle/disciples/services',
      )

    oracle_source_copy = drake.copy(oracle_sources,
                                    'bin',
                                    'oracle/disciples')
    oracle_lib = drake.nodes(
      'oracle/disciples/longinus/application.py',
      'oracle/disciples/longinus/__init__.py',
      'oracle/disciples/longinus/longinus.py',
      )

    # PYTHONPATH for oracle and functional tests.
    pythonpath = [
      drake.path_source('tests/functional/lib'),
      drake.path_build('lib/python'),
    ]
    env = {
      'PYTHONPATH': ':'.join(map(str, pythonpath)),
      'PATH': os.environ['PATH']
    }

    # Oracle/metalib
    if python_enabled:
      metalib_config = cxx_config_libs + python2
      metalib_config.lib_path_runtime('..')
      metalib_sources = drake.nodes(
        'oracle/disciples/metalib/identity.cc',
        'oracle/disciples/metalib/identity.hh',
        'oracle/disciples/metalib/metalib.cc',
        'oracle/disciples/metalib/metalib.hh',
        'oracle/disciples/metalib/network.cc',
        'oracle/disciples/metalib/network.hh',
        'oracle/disciples/metalib/passport.cc',
        'oracle/disciples/metalib/passport.hh',
        # XXX
        'common/common.cc',
        'common/common.hh',
        )
      metalib_libs = [
        nucleus_lib,
        papier_lib,
        cryptography_lib,
        elle_lib,
      ]
      metalib_lib = drake.cxx.Module('lib/python/metalib',
                                     metalib_sources + metalib_libs,
                                     cxx_toolkit, metalib_config)

      oracles << metalib_lib

    def oracle(name):
      root = drake.Path('oracle/disciples/%s' % name)
      rule = drake.Rule('oracle/%s/build' % name)
      oracle_sources = drake.nodes(*git.ls_files(root / 'src' / name))
      server = drake.node('oracle/disciples/%s-server' % name)
      rule << drake.copy(oracle_sources,
                         'lib/python', root / 'src')
      rule << drake.copy(server, 'bin', 'oracle/disciples')

      rule_check = drake.TestSuite('oracle/%s/check' % name)
      for test in git.ls_files(root / 'tests'):
        test = drake.node(test)
        if not test.path().executable:
          continue
        runner = drake.Runner(test, env = env)
        # Manually build the oracles beforehand
        runner.add_src(drake.Rule('oracle/apertus/build'))
        runner.add_src(drake.Rule('oracle/meta/build'))
        runner.add_src(drake.Rule('oracle/pythia/build'))
        runner.add_src(drake.Rule('oracle/trophonius/build'))
        runner.add_src(drake.Rule('oracle/walrus/build'))
        runner.add_src(metalib_lib)
        runner.reporting = drake.Runner.Reporting.on_failure
        rule_check << runner.status
      oracles << rule
      check << rule_check
      return rule, rule_check

    ## ------- ##
    ## Oracles ##
    ## ------- ##

    from os import path
    destination = drake.Path(path.expandvars(path.curdir) + '/lib/python')

    meta = drake.include('oracles/meta',
                         elle = elle.elle,
                         reactor = elle.reactor,
                         curly = elle.curly,
                         papier = papier_python_lib,
                         python3 = python_enabled and python3 or None,
                         boost = boost,
                         prefix = prefix,
                         destination = destination,
                         cxx_toolkit = cxx_toolkit,
                         cxx_config = cxx_config,)

    assert meta.server.lib is not None
    assert meta.client.lib is not None
    assert meta.check is not None

    rule_meta = drake.Rule('meta')
    rule_meta_client = drake.Rule('meta/client')
    rule_meta_client << meta.client.lib
    rule_meta << rule_meta_client
    rule_meta_server = drake.Rule('meta/server')
    rule_meta_server << meta.server.lib
    rule_meta << rule_meta_server
    rule_meta_check = drake.Rule('meta/check')
    rule_meta_check << meta.check

    rule_trophonius, rule_trophonius_check = oracle('trophonius')
    rule_apertus, rule_apertus_check = oracle('apertus')
    rule_meta, rule_meta_check = oracle('meta')
    rule_walrus, rule_walrus_check = oracle('walrus')
    authority = drake.node('oracle/infinit.auth')
    rule_meta << drake.copy(authority, 'oracle/meta', 'oracle')

    oracle_lib_copy = drake.copy(oracle_lib,
                                 'lib/python',
                                 'oracle/disciples')
    pythia = drake.Rule('oracle/pythia/build')
    pythia_sources = drake.nodes(
      'oracle/disciples/pythia/admin.py',
      'oracle/disciples/pythia/client.py',
      'oracle/disciples/pythia/constants.py',
      'oracle/disciples/pythia/__init__.py',
      )
    pythia << drake.copy(pythia_sources,
                         'lib/python',
                         'oracle/disciples')
    oracle_lib_copy.append(pythia)

    # heartbeat_config = drake.cxx.Config(cxx_config)
    # heartbeat_config += boost.config_program()
    # heartbeat_config.lib('udt')
    # heartbeat_config.lib_path_runtime('../lib')
    # heartbeat_config.add_local_include_path('oracle/disciples/')
    # heartbeat_config.add_local_include_path('.')
    # heartbeat_config.lib('reactor')
    # heartbeat_config.lib('elle')

    # heartbeat_sources = drake.nodes(
    #   'oracle/disciples/heartbeat/heartbeat.cc',
    #   'satellites/satellite.cc',
    #   'satellites/satellite.hh',
    #   'common/common.cc',
    #   'common/common.hh',
    #   'CrashReporter.cc',
    #   'CrashReporter.hh',
    #   )

    # heartbeat = drake.cxx.Executable('bin/heartbeat-server',
    #     heartbeat_sources + [reactor_lib, elle_lib, curly_lib] + udt_libs,
    #     cxx_toolkit, heartbeat_config)

    # oracles << heartbeat

    oracles << oracle_source_copy
    oracles << oracle_lib_copy

    build << oracles

  # Install
  install = drake.Rule('install')
  install << drake.copy(infinit_bin, prefix)
  install << drake.copy(infinit_libs, prefix)

  # Tests
  tests_cxx_config = drake.cxx.Config(cxx_config)
  tests_cxx_config.lib_path_runtime('../../../../lib')
  tests_cxx_config.lib_path_runtime('../../../lib')
  tests_cxx_config.lib_path_runtime('../../lib')
  tests_cxx_config.lib_path_runtime('../lib')
  tests_cxx_config += boost.config_test()
  nucleus_test_libs = [cryptography_lib, elle_lib, nucleus_lib, reactor_lib]

  tests_src_n_lib = [
    ('tests/testing_tests.cc', []),
    ('tests/unit/etoile/Etoile.cc', infinit_libs),
    ('tests/unit/etoile/Shrub.cc', infinit_libs),
    ('tests/unit/nucleus/neutron/nn_Group.cc', nucleus_test_libs),
    ('tests/unit/nucleus/neutron/nn_Object.cc', nucleus_test_libs),
    ('tests/unit/nucleus/neutron/nn_Record.cc', nucleus_test_libs),
    ('tests/unit/nucleus/proton/ImprintBlock.cc', nucleus_test_libs),
    #('tests/unit/nucleus/proton/Porcupine.cc', infinit_libs + [elle_lib, hole_lib]),
    (('tests/unit/plasma/trophonius/test.cc',),  [elle_lib, plasma_lib, curly_lib, curly_sched_lib, reactor_lib]),
    (('tests/unit/plasma/meta/test.cc',),  [elle_lib, plasma_lib, curly_lib, curly_sched_lib, reactor_lib]),
    (('tests/unit/CrashReporter.cc', 'CrashReporter.cc', 'CrashReporter.hh'), [elle_lib, reactor_lib, curly_lib]),
    ('tests/unit/surface/gap/gap.cc', infinit_libs + [elle_lib, metrics_lib, gap_lib, frete_lib, station_lib, crash_lib]),
    ('tests/unit/surface/gap/gap_metrics.cc', infinit_libs + [elle_lib, lune_lib, plasma_lib, metrics_lib, gap_lib, frete_lib, station_lib, metrics_lib, crash_lib]),
    ('tests/unit/surface/gap/gap_state_destruction.cc', [gap_lib, elle_lib, reactor_lib, lune_lib, crash_lib]),
    (('tests/unit/surface/gap/Metrics.cc', 'common/common.cc'), infinit_libs + [elle_lib, plasma_lib, metrics_lib, reactor_lib, cryptography_lib, curly_lib, crash_lib]),
    #('tests/unit/surface/gap/state_connect.cc', [elle_lib, lune_lib, plasma_lib, metrics_lib, gap_lib, metrics_lib]),
    #('tests/unit/surface/gap/state_ctor.cc', [elle_lib, lune_lib, plasma_lib, metrics_lib, gap_lib, metrics_lib] + infinit_libs),
    ('tests/unit/hole/slug.cc', infinit_libs),
    #(('tests/unit/heartbeat.cc', 'heartbeat.cc', 'heartbeat.hh', 'common/common.cc'), [reactor_lib, elle_lib]),
    ('tests/unit/signal_handling.cc', infinit_libs + [crash_lib]),
  ]

  for test, deps in tests_src_n_lib:
    if isinstance(test, str):
      bin_name, ext = os.path.splitext(test)
      sources = [test]
    else:
      first, *others = test
      bin_name, ext = os.path.splitext(first)
      sources = test
    test_bin = drake.cxx.Executable(bin_name,
                                    drake.nodes(*sources) + deps,
                                    cxx_toolkit, tests_cxx_config)
    tests << test_bin
    runner = drake.Runner(test_bin)
    runner.reporting = drake.Runner.Reporting.on_failure
    check << runner.status

  check_functional = drake.Rule('check/functional')
  for test in ['servers/genocide',
               'servers/pingpong-notifications.py',
               'servers/online-offline',
               'servers/swaggers.py',
               'sharing/send-file/send-file.py',
               'sharing/send-file/forwarder.py',
               'sharing/send-file/invitation.py',
               'sharing/send-file/sender-cancel.py',
               'sharing/send-file/sender-early-cancel.py',
               'sharing/send-file/recipient-early-cancel.py',
               'sharing/send-file/recipient-cancel.py',
             ]:
    test = drake.node('tests/functional/%s' % test)
    tests << test
    pythonpath = [
      drake.path_source('tests/functional/lib'),
      drake.path_build('lib/python'),
    ]
    env = {
      'PYTHONPATH': ':'.join(map(str, pythonpath)),
      'PATH': os.environ['PATH']
    }
    runner = drake.Runner(test, env = env)
    runner.reporting = drake.Runner.Reporting.on_failure
    check_functional << runner.status

  # build << drake.cxx.Executable("bin/pass",
  #         drake.nodes('tests/unit/pass.cc', 'common/common.cc') + [reactor_lib,
  #             elle_lib] + udt_libs,
  #         cxx_toolkit, tests_cxx_config)
