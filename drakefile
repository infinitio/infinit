import drake.cxx
import drake.cxx.boost
import drake

import os
import sys
import platform

satellite_path = str(drake.path_src("satellites"))
satellite_default = [s for s in os.listdir(satellite_path) \
                     if os.path.isdir(os.path.join(satellite_path, s))]

def configure(cxx_toolkit,
              cxx_config,
              enable_horizon = True,
              satellites = satellite_default,
              optimization = True,
              prefix = '/usr',
              boost = None,
              qt = None,
              python2 = None,
              python3 = None,
              build_type = "Development",
              enable_debug = True):

  prefix = drake.Path(prefix)

  if enable_debug:
    cxx_config.define("DEBUG")
  else:
    cxx_config.define("NDEBUG")

  build_types = {'Development': (),
                 'Production': ("INFINIT_PRODUCTION_BUILD",)}

  if not build_type in build_types.keys():
    raise Exception("build type {} is unknown. Candidates are {}.".format(
        build_type, ", ".join("{}".format(t) for t in build_types.keys())))

  for define in build_types[build_type]:
    if isinstance(define, str):
      cxx_config.define(define, 1)
    else:
      cxx_config.define(define[0], define[1])

  platform_defines = ()
  if sys.platform.startswith('linux'):
    platform_defines = ("INFINIT_LINUX",)
  elif sys.platform == 'win32' or sys.platform == 'cygwin':
    platform_defines = ("INFINIT_WINDOWS",)
  elif sys.platform == 'darwin':
    platform_defines = ("INFINIT_MACOSX", "HAVE_STATFS")
  else:
    raise Exception("platform {} not supported".format(sys.platform))
  for define in platform_defines:
    cxx_config.define(define)

  cxx_config.define("HAVE_SETXATTR")

  # Version
  version_major = '0'
  version_minor = '1'

  cxx_config.define('INFINIT_VERSION_MAJOR', version_major)
  cxx_config.define('INFINIT_VERSION_MINOR', version_minor)
  cxx_config.define('INFINIT_VERSION', '%s.%s' % (version_major, version_minor))
  cxx_config.define('BOOST_PP_VARIADICS')

  # OpenSSL
  openssl = None

  architecture = platform.architecture()[0]
  if architecture == "32bit":
    architecture_wordsize = 32
  elif architecture == "64bit":
    architecture_wordsize = 64
  else:
    raise Exception("architecture {} not supported".format(architecture))

  if cxx_toolkit.os == drake.os.linux:
    if architecture_wordsize == 32:
      openssl_prefix = 'dependencies/platforms/linux32/work/'
    elif architecture_wordsize == 64:
      openssl_prefix = 'dependencies/platforms/linux64/work/'
    else:
      raise Exception("architecture {} not supported".format(architecture))
  elif cxx_toolkit.os == drake.os.macos:
    if architecture_wordsize == 32:
      openssl_prefix = 'dependencies/platforms/macosx32/work/'
    elif architecture_wordsize == 64:
      openssl_prefix = 'dependencies/platforms/macosx64/work/'
    else:
      raise Exception("architecture {} not supported".format(architecture))
  else:
    raise Exception("operating system {} not supported".format(cxx_toolkit.os))

  #assert os.path.isdir(
  #  os.path.join(
  #    os.path.abspath(os.path.dirname(__file__)),
  #    openssl_prefix
  #  )
  #)

  openssl = drake.cxx.LibraryConfiguration(
    'openssl/opensslconf.h',
    prefix = openssl_prefix,
  )

  if cxx_toolkit.os == drake.os.macos:
    suffix = '.1.0.0.dylib'
  elif cxx_toolkit.os == drake.os.windows:
    suffix = '.dll'
  else:
    suffix = '.so.1.0.0'

  openssl_lib = drake.copy(
    drake.nodes(
      openssl.libraries_path / ('libssl%s' % suffix),
      openssl.libraries_path / ('libcrypto%s' % suffix),
    ),
    'lib',
    openssl.libraries_path
  )
  cxx_config += openssl.config()

  # Boost
  boost = boost or drake.cxx.boost.Boost()
  cxx_config += boost.config()
  cxx_config += boost.config_signals()
  cxx_config += boost.config_system()
  cxx_config += boost.config_filesystem()
  cxx_config.define('BOOST_FILESYSTEM_DYN_LINK', '1')
  cxx_config.define('BOOST_FILESYSTEM_NO_DEPRECATED', '1')
  cxx_config += boost.config_thread()

  # Python
  python2 = drake.cxx.find_library('pyconfig.h', python2,
                                   include_dir = ['include/python2.7',
                                                  'include/python2.7m'])
  python3 = drake.cxx.find_library('pyconfig.h', python3,
                                   include_dir = ['include/python3.2',
                                                  'include/python3.2m',
                                                  'include/python3.3m'])

  # Elle
  elle = drake.include('elle', cxx_toolkit, cxx_config, boost = boost)
  elle_lib = drake.copy(elle.elle_dynamic, 'lib', elle.elle_dynamic.path().dirname())
  cryptography_lib = drake.copy(elle.cryptography_dynamic, 'lib', elle.cryptography_dynamic.path().dirname())
  reactor_lib = drake.copy(elle.reactor_dynamic, 'lib', elle.reactor_dynamic.path().dirname())
  cxx_config += elle.config
  asio_udt_lib = drake.copy(elle.reactor.asio_udt.library,'lib', 'elle/reactor/asio-udt/lib')
  udt_lib = drake.copy(elle.reactor.asio_udt.udt.library,'lib', 'elle/reactor/asio-udt/udt/lib')
  cxx_config.add_local_include_path('.')

  # Fuse
  if enable_horizon:
    cxx_config.define('_FILE_OFFSET_BITS', 64) # FIXME: only needed for horizon
    cxx_config.define('INFINIT_HORIZON')
  cxx_config.define('BOOST_PP_VARIADICS')

  cxx_config_libs = drake.cxx.Config(cxx_config)
  cxx_config_libs.lib_path_runtime('.')

  # Lune
  lune_sources = drake.nodes(
    'lune/Configuration.cc',
    'lune/Configuration.hh',
    'lune/Descriptor.cc',
    'lune/Descriptor.hh',
    'lune/Descriptor.hxx',
    'lune/Dictionary.cc',
    'lune/Dictionary.hh',
    'lune/Dictionary.hxx',
    'lune/Identity.cc',
    'lune/Identity.hh',
    'lune/Identity.hxx',
    'lune/Lune.cc',
    'lune/Lune.hh',
    'lune/Map.hh',
    'lune/Map.hxx',
    'lune/Phrase.cc',
    'lune/Phrase.hh',
    'lune/Phrase.hxx',
    'lune/Policy.cc',
    'lune/Policy.hh',
    'lune/Set.cc',
    'lune/Set.hh',
    'lune/Set.hxx',
    'lune/fwd.hh',
    )
  lune_lib = drake.cxx.DynLib('lib/lune', lune_sources,
                              cxx_toolkit, cxx_config)

  # Nucleus
  nucleus_sources = drake.nodes(
    'nucleus/Derivable.hh',
    'nucleus/Derivable.hxx',
    'nucleus/Exception.hh',
    'nucleus/Exception.cc',
    'nucleus/all.hh',
    'nucleus/factory.cc',
    'nucleus/factory.hh',
    'nucleus/fwd.hh',
    'nucleus/neutron/Access.cc',
    'nucleus/neutron/Access.hh',
    'nucleus/neutron/Access.hxx',
    'nucleus/neutron/Attributes.cc',
    'nucleus/neutron/Attributes.hh',
    'nucleus/neutron/Attributes.hxx',
    'nucleus/neutron/Author.cc',
    'nucleus/neutron/Author.hh',
    'nucleus/neutron/Author.hxx',
    'nucleus/neutron/Catalog.cc',
    'nucleus/neutron/Catalog.hh',
    'nucleus/neutron/Catalog.hxx',
    'nucleus/neutron/Component.cc',
    'nucleus/neutron/Component.hh',
    'nucleus/neutron/Data.cc',
    'nucleus/neutron/Data.hh',
    'nucleus/neutron/Data.hxx',
    'nucleus/neutron/Ensemble.cc',
    'nucleus/neutron/Ensemble.hh',
    'nucleus/neutron/Ensemble.hxx',
    'nucleus/neutron/Entry.cc',
    'nucleus/neutron/Entry.hh',
    'nucleus/neutron/Entry.hxx',
    'nucleus/neutron/Fellow.cc',
    'nucleus/neutron/Fellow.hh',
    'nucleus/neutron/Fellow.hxx',
    'nucleus/neutron/Genre.cc',
    'nucleus/neutron/Genre.hh',
    'nucleus/neutron/Group.cc',
    'nucleus/neutron/Group.hh',
    'nucleus/neutron/Group.hxx',
    'nucleus/neutron/Index.hh',
    'nucleus/neutron/Object.cc',
    'nucleus/neutron/Object.hh',
    'nucleus/neutron/Object.hxx',
    'nucleus/neutron/Offset.hh',
    'nucleus/neutron/Permissions.cc',
    'nucleus/neutron/Permissions.hh',
    'nucleus/neutron/Range.hh',
    'nucleus/neutron/Range.hxx',
    'nucleus/neutron/Record.cc',
    'nucleus/neutron/Record.hh',
    'nucleus/neutron/Record.hxx',
    'nucleus/neutron/Reference.cc',
    'nucleus/neutron/Reference.hh',
    'nucleus/neutron/Reference.hxx',
    'nucleus/neutron/Size.hh',
    'nucleus/neutron/Subject.cc',
    'nucleus/neutron/Subject.hh',
    'nucleus/neutron/Subject.hxx',
    'nucleus/neutron/Token.cc',
    'nucleus/neutron/Token.hh',
    'nucleus/neutron/Token.hxx',
    'nucleus/neutron/Trait.cc',
    'nucleus/neutron/Trait.hh',
    'nucleus/neutron/Trait.hxx',
    'nucleus/neutron/User.hh',
    'nucleus/neutron/all.hh',
    'nucleus/neutron/fwd.hh',
    'nucleus/nucleus.hh',
    'nucleus/proton/Address.cc',
    'nucleus/proton/Address.hh',
    'nucleus/proton/Address.hxx',
    'nucleus/proton/Ambit.hh',
    'nucleus/proton/Ambit.hxx',
    'nucleus/proton/Balancing.hh',
    'nucleus/proton/Base.cc',
    'nucleus/proton/Base.hh',
    'nucleus/proton/Base.hxx',
    'nucleus/proton/Block.cc',
    'nucleus/proton/Block.hh',
    'nucleus/proton/Block.hxx',
    'nucleus/proton/Capacity.hh',
    'nucleus/proton/Clef.cc',
    'nucleus/proton/Clef.hh',
    'nucleus/proton/Clef.hxx',
    'nucleus/proton/ContentHashBlock.cc',
    'nucleus/proton/ContentHashBlock.hh',
    'nucleus/proton/ContentHashBlock.hxx',
    'nucleus/proton/Contention.hh',
    'nucleus/proton/Contents.cc',
    'nucleus/proton/Contents.hh',
    'nucleus/proton/Contents.hxx',
    'nucleus/proton/Door.hh',
    'nucleus/proton/Door.hxx',
    'nucleus/proton/Egg.cc',
    'nucleus/proton/Egg.hh',
    'nucleus/proton/Extent.hh',
    'nucleus/proton/Family.cc',
    'nucleus/proton/Family.hh',
    'nucleus/proton/Flags.cc',
    'nucleus/proton/Flags.hh',
    'nucleus/proton/Footprint.hh',
    'nucleus/proton/Handle.cc',
    'nucleus/proton/Handle.hh',
    'nucleus/proton/Handle.hxx',
    'nucleus/proton/Height.hh',
    'nucleus/proton/History.cc',
    'nucleus/proton/History.hh',
    'nucleus/proton/History.hxx',
    'nucleus/proton/ImmutableBlock.cc',
    'nucleus/proton/ImmutableBlock.hh',
    'nucleus/proton/ImmutableBlock.hxx',
    'nucleus/proton/ImprintBlock.cc',
    'nucleus/proton/ImprintBlock.hh',
    'nucleus/proton/ImprintBlock.hxx',
    'nucleus/proton/Inlet.hh',
    'nucleus/proton/Inlet.hxx',
    'nucleus/proton/Limits.cc',
    'nucleus/proton/Limits.hh',
    'nucleus/proton/Location.cc',
    'nucleus/proton/Location.hh',
    'nucleus/proton/Location.hxx',
    'nucleus/proton/Mode.cc',
    'nucleus/proton/Mode.hh',
    'nucleus/proton/MutableBlock.cc',
    'nucleus/proton/MutableBlock.hh',
    'nucleus/proton/MutableBlock.hxx',
    'nucleus/proton/Nature.cc',
    'nucleus/proton/Nature.hh',
    'nucleus/proton/Nest.cc',
    'nucleus/proton/Nest.hh',
    'nucleus/proton/Network.cc',
    'nucleus/proton/Network.hh',
    'nucleus/proton/Network.hxx',
    'nucleus/proton/Node.cc',
    'nucleus/proton/Node.hh',
    'nucleus/proton/Node.hxx',
    'nucleus/proton/Nodule.hh',
    'nucleus/proton/Nodule.hxx',
    'nucleus/proton/OwnerKeyBlock.cc',
    'nucleus/proton/OwnerKeyBlock.hh',
    'nucleus/proton/OwnerKeyBlock.hxx',
    'nucleus/proton/Porcupine.hh',
    'nucleus/proton/Porcupine.hxx',
    'nucleus/proton/PublicKeyBlock.cc',
    'nucleus/proton/PublicKeyBlock.hh',
    'nucleus/proton/PublicKeyBlock.hxx',
    'nucleus/proton/Quill.hh',
    'nucleus/proton/Quill.hxx',
    'nucleus/proton/Radix.cc',
    'nucleus/proton/Radix.hh',
    'nucleus/proton/Radix.hxx',
    'nucleus/proton/Revision.cc',
    'nucleus/proton/Revision.hh',
    'nucleus/proton/Revision.hxx',
    'nucleus/proton/Root.cc',
    'nucleus/proton/Root.hh',
    'nucleus/proton/Root.hxx',
    'nucleus/proton/Seam.hh',
    'nucleus/proton/Seam.hxx',
    'nucleus/proton/Stamp.cc',
    'nucleus/proton/Stamp.hh',
    'nucleus/proton/Stamp.hxx',
    'nucleus/proton/State.cc',
    'nucleus/proton/State.hh',
    'nucleus/proton/Statistics.cc',
    'nucleus/proton/Statistics.hh',
    'nucleus/proton/Strategy.cc',
    'nucleus/proton/Strategy.hh',
    'nucleus/proton/Tree.hh',
    'nucleus/proton/Tree.hxx',
    'nucleus/proton/Value.cc',
    'nucleus/proton/Value.hh',
    'nucleus/proton/Value.hxx',
    'nucleus/proton/all.hh',
    'nucleus/proton/fwd.hh',
    )
  nucleus_lib = drake.cxx.DynLib('lib/nucleus', nucleus_sources,
                                 cxx_toolkit, cxx_config)

  # Protocol
  protocol_sources = drake.nodes(
    'protocol/ChanneledStream.hh',
    'protocol/Packet.hh',
    'protocol/RPC.hxx',
    'protocol/Packet.cc',
    'protocol/Stream.hh',
    'protocol/Serializer.hh',
    'protocol/Channel.cc',
    'protocol/RPC.hh',
    'protocol/ChanneledStream.cc',
    'protocol/Stream.cc',
    'protocol/Channel.hh',
    'protocol/Serializer.cc',
    'protocol/RPC.cc',
    'protocol/fwd.hh',
    )
  protocol_lib = drake.cxx.DynLib('lib/protocol', protocol_sources,
                                  cxx_toolkit, cxx_config)

  # RCP caller
  rpc_sources = drake.nodes(
    'protocol/8rpc.cc'
    )


  # Plasma
  plasma_sources = drake.nodes(
    'plasma/meta/Client.cc',
    'plasma/meta/Client.hh',
    'plasma/meta/Client.hxx',
    'plasma/trophonius/Client.cc',
    'plasma/trophonius/Client.hh',
    'plasma/plasma.cc',
    # 'plasma/watchdog/ClientActions.hh',
    )
  plasma_lib = drake.cxx.DynLib('lib/plasma', plasma_sources,
                                cxx_toolkit, cxx_config)

  # Agent
  agent_sources = drake.nodes(
    'agent/Agent.hh',
    'agent/Agent.cc',
    )
  agent_lib = drake.cxx.DynLib('lib/agent', agent_sources,
                               cxx_toolkit, cxx_config)

  # Infinit
  infinit_sources = drake.nodes(
    'CrashReporter.cc',
    'CrashReporter.hh',
    'HoleFactory.cc',
    'Infinit.cc',
    'Program.cc',
    'Program.hh',
    'Scheduler.cc',
    'Scheduler.hh',
    'common/common.cc',
    )
  infinit_lib = drake.cxx.DynLib('lib/infinit', infinit_sources,
                                 cxx_toolkit, cxx_config)

  # Hole
  hole_sources = drake.nodes(
    'hole/Exception.cc',
    'hole/Exception.hh',
    'hole/Authority.cc',
    'hole/Authority.hh',
    'hole/Authority.hxx',
    'hole/Passport.cc',
    'hole/Passport.hh',
    'hole/Passport.hxx',
    'hole/Hole.cc',
    'hole/Hole.hh',
    'hole/Label.cc',
    'hole/Label.hh',
    'hole/Label.hxx',
    'hole/Model.cc',
    'hole/Model.hh',
    'hole/Model.hxx',
    'hole/Openness.cc',
    'hole/Openness.hh',
    'hole/algorithms/assignment/Assignment.hh',
    'hole/fwd.hh',
    'hole/implementations/Implementations.hh',
    # 'hole/implementations/cirkle/Cirkle.cc',
    # 'hole/implementations/cirkle/Cirkle.hh',
    # 'hole/implementations/cirkle/Cluster.cc',
    # 'hole/implementations/cirkle/Cluster.hh',
    # 'hole/implementations/cirkle/Cluster.hxx',
    # 'hole/implementations/cirkle/Implementation.cc',
    # 'hole/implementations/cirkle/Implementation.hh',
    # 'hole/implementations/cirkle/Machine.cc',
    # 'hole/implementations/cirkle/Machine.hh',
    # 'hole/implementations/cirkle/Manifest.hh',
    # 'hole/implementations/cirkle/Neighbour.cc',
    # 'hole/implementations/cirkle/Neighbour.hh',
    # 'hole/implementations/cirkle/Neighbourhood.cc',
    # 'hole/implementations/cirkle/Neighbourhood.hh',
    # 'hole/implementations/cirkle/RoutingTable.cc',
    # 'hole/implementations/cirkle/RoutingTable.hh',
    'hole/implementations/local/Implementation.cc',
    'hole/implementations/local/Implementation.hh',
    'hole/implementations/local/Local.cc',
    'hole/implementations/local/Local.hh',
    'hole/implementations/local/Machine.cc',
    'hole/implementations/local/Machine.hh',
    'hole/implementations/local/fwd.hh',
    'hole/implementations/remote/Client.cc',
    'hole/implementations/remote/Client.hh',
    'hole/implementations/remote/Customer.cc',
    'hole/implementations/remote/Customer.hh',
    'hole/implementations/remote/Implementation.cc',
    'hole/implementations/remote/Implementation.hh',
    'hole/implementations/remote/Machine.cc',
    'hole/implementations/remote/Machine.hh',
    'hole/implementations/remote/Manifest.cc',
    'hole/implementations/remote/Manifest.hh',
    'hole/implementations/remote/Remote.cc',
    'hole/implementations/remote/Remote.hh',
    'hole/implementations/remote/Server.cc',
    'hole/implementations/remote/Server.hh',
    'hole/implementations/remote/fwd.hh',
    'hole/implementations/slug/Host.cc',
    'hole/implementations/slug/Host.hh',
    'hole/implementations/slug/Slug.cc',
    'hole/implementations/slug/Slug.hh',
    'hole/implementations/slug/Manifest.cc',
    'hole/implementations/slug/Manifest.hh',
    'hole/implementations/slug/fwd.hh',
    'hole/storage/Storage.cc',
    'hole/storage/Storage.hh',
    'hole/storage/Directory.cc',
    'hole/storage/Directory.hh',
    'hole/storage/Memory.cc',
    'hole/storage/Memory.hh',
    )
  hole_lib = drake.cxx.DynLib('lib/hole', hole_sources,
                              cxx_toolkit, cxx_config)

# XXX
#  hole_tests_root = drake.Path('hole/tests')
#  for test in ['slug']:
#    drake.cxx.Executable(hole_tests_root / test,
#                         drake.nodes(hole_tests_root / ('%s.cc' % test)) +
#                         [reactor.lib_dynamic, elle.lib_dynamic, cryptography_lib,
#                          hole_lib, nucleus_lib, protocol_lib],
#                         cxx_toolkit, cxx_config + boost.config_test())

  # Etoile
  etoile_sources = drake.nodes(
    'etoile/Etoile.cc',
    'etoile/Etoile.hh',
    'etoile/Exception.hh',
    'etoile/Exception.cc',
    'etoile/abstract/Group.cc',
    'etoile/abstract/Group.hh',
    'etoile/abstract/Group.hxx',
    'etoile/abstract/Object.cc',
    'etoile/abstract/Object.hh',
    'etoile/abstract/Object.hxx',
    'etoile/abstract/fwd.hh',
    'etoile/automaton/Access.cc',
    'etoile/automaton/Access.hh',
    'etoile/automaton/Attributes.cc',
    'etoile/automaton/Attributes.hh',
    'etoile/automaton/Author.cc',
    'etoile/automaton/Author.hh',
    'etoile/automaton/Automaton.hh',
    'etoile/automaton/Contents.hh',
    'etoile/automaton/Contents.hxx',
    'etoile/automaton/Directory.cc',
    'etoile/automaton/Directory.hh',
    'etoile/automaton/Ensemble.cc',
    'etoile/automaton/Ensemble.hh',
    'etoile/automaton/File.cc',
    'etoile/automaton/File.hh',
    'etoile/automaton/Group.cc',
    'etoile/automaton/Group.hh',
    'etoile/automaton/Link.cc',
    'etoile/automaton/Link.hh',
    'etoile/automaton/Object.cc',
    'etoile/automaton/Object.hh',
    'etoile/automaton/Rights.cc',
    'etoile/automaton/Rights.hh',
    'etoile/automaton/Rights.hxx',
    'etoile/depot/Depot.cc',
    'etoile/depot/Depot.hh',
    'etoile/depot/Depot.hxx',
    'etoile/fwd.hh',
    'etoile/gear/Action.cc',
    'etoile/gear/Action.hh',
    'etoile/gear/Action.hxx',
    'etoile/gear/Actor.cc',
    'etoile/gear/Actor.hh',
    'etoile/gear/Chronicle.hh',
    'etoile/gear/Context.cc',
    'etoile/gear/Context.hh',
    'etoile/gear/Directory.cc',
    'etoile/gear/Directory.hh',
    'etoile/gear/File.cc',
    'etoile/gear/File.hh',
    'etoile/gear/Gear.cc',
    'etoile/gear/Gear.hh',
    'etoile/gear/Group.cc',
    'etoile/gear/Group.hh',
    'etoile/gear/Guard.cc',
    'etoile/gear/Guard.hh',
    'etoile/gear/Identifier.cc',
    'etoile/gear/Identifier.hh',
    'etoile/gear/Identifier.hxx',
    'etoile/gear/Link.cc',
    'etoile/gear/Link.hh',
    'etoile/gear/Nature.hh',
    'etoile/gear/Object.cc',
    'etoile/gear/Object.hh',
    'etoile/gear/Operation.hh',
    'etoile/gear/Scope.cc',
    'etoile/gear/Scope.hh',
    'etoile/gear/Scope.hxx',
    'etoile/gear/Transcript.cc',
    'etoile/gear/Transcript.hh',
    'etoile/gear/fwd.hh',
    'etoile/journal/Journal.cc',
    'etoile/journal/Journal.hh',
    'etoile/nest/Nest.cc',
    'etoile/nest/Nest.hh',
    'etoile/nest/Pod.cc',
    'etoile/nest/Pod.hh',
    'etoile/nest/fwd.hh',
    'etoile/path/Chemin.cc',
    'etoile/path/Chemin.hh',
    'etoile/path/Chemin.hxx',
    'etoile/path/Length.hh',
    'etoile/path/Path.cc',
    'etoile/path/Path.hh',
    'etoile/path/Route.cc',
    'etoile/path/Route.hh',
    'etoile/path/Route.hxx',
    'etoile/path/Slab.hh',
    'etoile/path/Slice.hh',
    'etoile/path/Venue.cc',
    'etoile/path/Venue.hh',
    'etoile/path/Venue.hxx',
    'etoile/path/Way.cc',
    'etoile/path/Way.hh',
    'etoile/path/Way.hxx',
    'etoile/path/fwd.hh',
    'etoile/portal/Application.cc',
    'etoile/portal/Application.hh',
    'etoile/portal/Manifest.cc',
    'etoile/portal/Manifest.hh',
    'etoile/portal/Portal.cc',
    'etoile/portal/Portal.hh',
    'etoile/portal/fwd.hh',
    'etoile/shrub/Riffle.cc',
    'etoile/shrub/Riffle.hh',
    'etoile/shrub/Shrub.cc',
    'etoile/shrub/Shrub.hh',
    'etoile/wall/Access.cc',
    'etoile/wall/Access.hh',
    'etoile/wall/Attributes.cc',
    'etoile/wall/Attributes.hh',
    'etoile/wall/Directory.cc',
    'etoile/wall/Directory.hh',
    'etoile/wall/File.cc',
    'etoile/wall/File.hh',
    'etoile/wall/Group.cc',
    'etoile/wall/Group.hh',
    'etoile/wall/Link.cc',
    'etoile/wall/Link.hh',
    'etoile/wall/Object.cc',
    'etoile/wall/Object.hh',
    'etoile/wall/Object.hxx',
    'etoile/wall/Path.cc',
    'etoile/wall/Path.hh',
    'etoile/wall/Wall.hh',
    )
  etoile_lib = drake.cxx.DynLib('lib/etoile', etoile_sources,
                                cxx_toolkit, cxx_config)

  # Horizon
  if enable_horizon:
    horizon_sources = drake.nodes(
      'horizon/Crib.cc',
      'horizon/Crib.hh',
      'horizon/Crux.cc',
      'horizon/Handle.cc',
      'horizon/Handle.hh',
      'horizon/Horizon.cc',
      'horizon/Horizon.hh',
      'horizon/operations.hh',
      )
    if cxx_toolkit.os == drake.os.linux:
      horizon_sources += drake.nodes(
        'horizon/linux/FUSE.cc',
        'horizon/linux/FUSE.hh',
        'horizon/linux/FUker.cc',
        'horizon/linux/FUker.hh',
        'horizon/linux/Linux.cc',
        'horizon/linux/Linux.hh',
        'horizon/linux/fwd.hh',
        )
    elif cxx_toolkit.os == drake.os.macos:
      horizon_sources += drake.nodes(
        'horizon/macosx/Crux.hh',
        'horizon/macosx/Crux.cc',
        'horizon/macosx/FUSE.hh',
        'horizon/macosx/FUSE.cc',
        'horizon/macosx/FUker.hh',
        'horizon/macosx/FUker.cc',
        'horizon/macosx/MacOSX.hh',
        'horizon/macosx/MacOSX.cc',
        'horizon/macosx/fwd.hh',
        )
    else:
      raise Exception('unsupport os')

    horizon_lib = drake.cxx.DynLib('lib/horizon', horizon_sources,
                                   cxx_toolkit, cxx_config)
    horizon_slib = drake.cxx.StaticLib('lib/horizon', horizon_sources,
                                       cxx_toolkit, cxx_config)

  # Agent
  metrics_sources = drake.nodes(
    'metrics/Reporter.hh',
    'metrics/Reporter.cc',
    'metrics/_details/google.hh',
    'metrics/_details/google.cc',
    'metrics/_details/kissmetrics.hh',
    'metrics/_details/kissmetrics.cc',
    )
  metrics_lib = drake.cxx.DynLib('lib/metrics', metrics_sources,
                                 cxx_toolkit, cxx_config)


  ## ----- ##
  ## Tests ##
  ## ----- ##

  tests = drake.Rule('tests')

  ## ----- ##
  ## Build ##
  ## ----- ##

  build = drake.Rule('build')
  build << openssl_lib

  ## -------- ##
  ## Programs ##
  ## -------- ##

  infinit_libs = [
    agent_lib,
    etoile_lib,
    hole_lib,
    infinit_lib,
    lune_lib,
    nucleus_lib,
    plasma_lib,
    cryptography_lib,
    protocol_lib,
    reactor_lib,
    elle_lib,
    metrics_lib,
  ]
  if enable_horizon:
    infinit_libs.append(horizon_slib)
  udt_libs = [asio_udt_lib, udt_lib]
  infinit_libs += udt_libs # FIXME: no need to depend on UDT

  # 8infinit
  infinit_bin_config = drake.cxx.Config(cxx_config)
  infinit_bin_config += boost.config_thread()
  infinit_bin_config.lib_path_runtime('../lib')
  if enable_horizon:
    infinit_bin_config.lib('fuse')
    infinit_bin_config.lib('pthread')

  infinit_sources = drake.nodes(
      '_infinit.cc',
      'satellites/satellite.cc',
      'satellites/satellite.hh'
  )
  infinit_bin = drake.cxx.Executable('bin/8infinit',
                                     infinit_sources + infinit_libs,
                                     cxx_toolkit, infinit_bin_config)
  build << infinit_bin

  # GdbMacro
  gdbmacro_files = drake.nodes(
    'default/gdbmacro',
    )
  macro_copy = drake.copy(gdbmacro_files, 'bin', 'default')

  build << macro_copy

  # 8hole
  hole_cxx_config = drake.cxx.Config(cxx_config)
  hole_cxx_config.lib('fuse')
  hole_bin = drake.cxx.Executable('bin/8hole',
                                  drake.nodes('hole/_hole.cc') + infinit_libs,
                                  cxx_toolkit, hole_cxx_config)
  # build << hole_bin

  def satellite(name):
    fmt = (name, name.capitalize())
    sources = [
      'satellites/%s/%s.cc' % fmt,
      'satellites/%s/%s.hh' % fmt,
      'satellites/%s/%s.hxx' % fmt,
      'satellites/satellite.cc',
      'satellites/satellite.hh',
      ]
    sources = filter(lambda p: drake.path_src(p).exists(), sources)
    sources = map(drake.node, sources)
    bin = drake.cxx.Executable('bin/8%s' % name,
                               list(sources) + infinit_libs,
                               cxx_toolkit, infinit_bin_config)
    if name in satellites:
      build << bin

  for name in [
    'access',
    'authority',
    'group',
    'network',
    'passport',
    'progress',
    'transfer',
    'user',
    'dump',
    ]:
    satellite(name)

  # 8search
  search_sources = drake.nodes(
    'satellites/search/8search.py',
    )
  search_copy = drake.copy(search_sources, 'bin', 'satellites/search')

  if "search" in satellites:
      build << search_copy

  # 8d00m
  d00m_sources = drake.nodes(
    'satellites/d00m/8d00m.py'
    )
  d00m_copy = drake.copy(d00m_sources, 'bin', 'satellites/d00m')

  if "d00m" in satellites:
      build << d00m_copy

  # 8sendto
  sendto_sources = drake.nodes(
    'satellites/sendto/8sendto.py',
    )
  sendto_copy = drake.copy(sendto_sources, 'bin', 'satellites/sendto')

  if "sendto" in satellites:
      build << sendto_copy

  # 8recvfrom
  recvfrom_sources = drake.nodes(
    'satellites/recvfrom/8recvfrom.py',
    )
  recvfrom_copy = drake.copy(recvfrom_sources, 'bin', 'satellites/recvfrom')

  if "recvfrom" in satellites:
      build << recvfrom_copy

  # Trophonius

  tropho_cxx_config = drake.cxx.Config(cxx_config)
  tropho_sources = drake.nodes(
    'plasma/trophonius/Client.cc',
    'plasma/trophonius/Client.hh',
    )
  tropho_lib = drake.cxx.DynLib('lib/trophonius',
                             tropho_sources,
                             cxx_toolkit, cxx_config)
  ## GAP:
  gap_operation_sources = drake.nodes(
    'surface/gap/Exception.hh',
    'surface/gap/OperationManager.cc',
    'surface/gap/OperationManager.hh')

  gap_operation_lib = drake.cxx.DynLib('lib/gap_operation',
                                      gap_operation_sources + infinit_libs,
                                      cxx_toolkit, cxx_config_libs);

  build << gap_operation_lib


  gap_infinit_instance_sources = drake.nodes(
    'surface/gap/Exception.hh',
    'surface/gap/InfinitInstanceManager.cc',
    'surface/gap/InfinitInstanceManager.hh')

  gap_infinit_instance_lib = drake.cxx.DynLib('lib/gap_infinit_instance',
                                              gap_infinit_instance_sources + infinit_libs,
                                              cxx_toolkit, cxx_config_libs);

  build << gap_infinit_instance_lib

  gap_notification_sources = drake.nodes(
    'surface/gap/Exception.hh',
    'surface/gap/NotificationManager.cc',
    'surface/gap/NotificationManager.hh',
    'surface/gap/NotificationManager.hxx')

  gap_notification_lib = drake.cxx.DynLib('lib/gap_notification',
                                          gap_notification_sources + infinit_libs,
                                          cxx_toolkit, cxx_config_libs);

  build << gap_notification_lib;

  gap_network_sources = drake.nodes(
    'surface/gap/Exception.hh',
    'surface/gap/NetworkManager.cc',
    'surface/gap/NetworkManager.hh',
    'surface/gap/metrics.hh')

  gap_network_lib = drake.cxx.DynLib('lib/gap_network',
                                     gap_network_sources + infinit_libs + [gap_infinit_instance_lib,],
                                     cxx_toolkit, cxx_config_libs);

  build << gap_network_lib

  gap_transaction_sources = drake.nodes(
    'surface/gap/Exception.hh',
    'surface/gap/TransactionManager.cc',
    'surface/gap/TransactionManager.hh',
    'surface/gap/metrics.hh')

  gap_transaction_lib = drake.cxx.DynLib('lib/gap_transaction',
                                         gap_transaction_sources + infinit_libs + [gap_network_lib,],
                                         cxx_toolkit, cxx_config_libs);
  build << gap_transaction_lib

  gap_user_sources = drake.nodes(
     'surface/gap/Exception.hh',
    'surface/gap/UserManager.cc',
    'surface/gap/UserManager.hh')

  gap_user_lib = drake.cxx.DynLib('lib/gap_user',
                                  gap_user_sources + infinit_libs,
                                  cxx_toolkit, cxx_config_libs);
  build << gap_user_lib;

  manager_libs = [gap_operation_lib,
                  gap_infinit_instance_lib,
                  gap_notification_lib,
                  gap_network_lib,
                  gap_transaction_lib,
                  gap_user_lib, ]

  # GAP
  gap_sources = drake.nodes(
    'surface/gap/Exception.hh',
    'surface/gap/State.cc',
    'surface/gap/State.hh',
    'surface/gap/device.cc',
    'surface/gap/error.hh',
    'surface/gap/gap.cc',
    'surface/gap/gap.h',
    'surface/gap/metrics.hh',
  )

  gap_ccx_config_libs = cxx_config_libs
  gap_ccx_config_libs.lib_path_runtime('../../lib/_gap')
  gap_lib = drake.cxx.DynLib('lib/gap',
                             gap_sources + infinit_libs + manager_libs,
                             cxx_toolkit, gap_ccx_config_libs)

  build << gap_lib

  # GAP python
  gap_python_cxx_config = cxx_config + python3
  gap_python_cxx_config += boost.config_python()
  gap_python_cxx_config.lib_path_runtime('..')
  gap_python_sources = drake.nodes(
    'surface/gap/python/pygap.cc',
    )
  gap_python_lib = drake.cxx.Module('lib/python/_gap',
                                    # FIXME: sooooo many libs ...
                                    gap_python_sources + [gap_lib, tropho_lib] + infinit_libs,
                                    cxx_toolkit, gap_python_cxx_config)

  gap_python_pyfiles = drake.nodes(
    'surface/gap/python/gap.py',
    )

  gap_python_pyfile_copy = drake.copy(gap_python_pyfiles,
                                      'lib/python',
                                      'surface/gap/python')

  infinit_cli_sources = drake.nodes(
    'surface/cli/infinit-cli'
    )

  infinit_cli_copy = drake.copy(infinit_cli_sources,
                                'bin',
                                'surface/cli')

  build << gap_python_lib
  build << gap_python_pyfile_copy
  build << infinit_cli_copy

  # Oracles

  oracles = drake.Rule('oracle')

  oracle_sources = drake.nodes(
    'oracle/disciples/creosus-server',
    'oracle/disciples/erginus-server',
    'oracle/disciples/longinus-server',
    'oracle/disciples/meta-server',
    'oracle/disciples/trophonius-server',
    'oracle/disciples/admin-console',
    'oracle/disciples/apertus-server',
    'oracle/disciples/services',
    )

  oracle_source_copy = drake.copy(oracle_sources,
                                  'bin',
                                  'oracle/disciples')
  oracle_lib = drake.nodes(
    'oracle/disciples/longinus/application.py',
    'oracle/disciples/longinus/__init__.py',
    'oracle/disciples/longinus/longinus.py',
    )

  oracle_lib += drake.nodes(
    'oracle/disciples/apertus/__init__.py',
    'oracle/disciples/apertus/apertus.py',
    'oracle/disciples/apertus/application.py',
    'oracle/disciples/apertus/conf.py',
    )

  oracle_lib += drake.nodes(
    'oracle/disciples/meta/__init__.py',
    'oracle/disciples/meta/apertus.py',
    'oracle/disciples/meta/application.py',
    'oracle/disciples/meta/conf.py',
    'oracle/disciples/meta/database.py',
    'oracle/disciples/meta/apertus.py',
    'oracle/disciples/meta/invitation.py',
    'oracle/disciples/meta/error.py',
    'oracle/disciples/meta/error_code.hh.inc',
    'oracle/disciples/meta/mail.py',
    'oracle/disciples/meta/notification_type.hh.inc',
    'oracle/disciples/meta/notifier.py',
    'oracle/disciples/meta/page.py',
    'oracle/disciples/meta/regexp.py',
    'oracle/disciples/meta/resources/__init__.py',
    'oracle/disciples/meta/resources/device.py',
    'oracle/disciples/meta/resources/network.py',
    'oracle/disciples/meta/resources/network_update.hh.inc',
    'oracle/disciples/meta/resources/notification.py',
    'oracle/disciples/meta/resources/place_holder_avatar.png',
    'oracle/disciples/meta/resources/root.py',
    'oracle/disciples/meta/resources/transaction.py',
    'oracle/disciples/meta/resources/transaction_status.hh.inc',
    'oracle/disciples/meta/resources/user.py',
    'oracle/disciples/meta/session.py',
    'oracle/disciples/meta/session_store.py',
    'oracle/disciples/meta/user_status.hh.inc',
    )

  oracle_lib += drake.nodes(
    'oracle/disciples/pythia/admin.py',
    'oracle/disciples/pythia/client.py',
    'oracle/disciples/pythia/constants.py',
    'oracle/disciples/pythia/__init__.py',
    )


  oracle_lib += drake.nodes(
    'oracle/disciples/trophonius/application.py',
    'oracle/disciples/trophonius/clients.py',
    'oracle/disciples/trophonius/conf.py',
    'oracle/disciples/trophonius/constants.py',
    'oracle/disciples/trophonius/__init__.py',
    'oracle/disciples/trophonius/trophonius.py',
    )

  oracle_lib_copy = drake.copy(oracle_lib,
                               'lib/python',
                               'oracle/disciples')

  oracles << oracle_source_copy
  oracles << oracle_lib_copy

  # Oracle/metalib

  metalib_config = cxx_config + python2
  metalib_config.lib_path_runtime('..')

  metalib_sources = drake.nodes(
    'oracle/disciples/metalib/identity.cc',
    'oracle/disciples/metalib/metalib.cc',
    'oracle/disciples/metalib/network.cc',
    'oracle/disciples/metalib/passport.cc',

    'oracle/disciples/metalib/identity.hh',
    'oracle/disciples/metalib/metalib.hh',
    'oracle/disciples/metalib/network.hh',
    'oracle/disciples/metalib/passport.hh',
    )

  metalib_lib = drake.cxx.Module('lib/python/metalib',
                                 metalib_sources + infinit_libs,
                                 cxx_toolkit, metalib_config)

  oracles << metalib_lib

  build << oracles

  # Install
  install = drake.Rule('install')
  install << drake.copy(infinit_bin, prefix)
  install << drake.copy(infinit_libs + [udt_lib, asio_udt_lib], prefix)

  # Tests
  tests_cxx_config = drake.cxx.Config(cxx_config)
  tests_cxx_config.lib_path_runtime('../../../../lib')
  tests_cxx_config.lib_path_runtime('../../../lib')
  tests_cxx_config += boost.config_test()
  nucleus_test_libs = [cryptography_lib, elle_lib, nucleus_lib, reactor_lib] + udt_libs
  tests_src_n_lib = [
    ('tests/testing_tests.cc', []),
    ('tests/unit/nucleus/neutron/nn_Group.cc', nucleus_test_libs),
    ('tests/unit/nucleus/neutron/nn_Object.cc', nucleus_test_libs),
    ('tests/unit/nucleus/neutron/nn_Record.cc', nucleus_test_libs),
    ('tests/unit/nucleus/proton/ImprintBlock.cc', nucleus_test_libs),
    ('tests/unit/nucleus/proton/Porcupine.cc', [hole_lib] + infinit_libs + [elle_lib, hole_lib]),
    ('tests/unit/plasma/meta/MetaClient.cc', 'common/common.cc',
     [elle_lib, plasma_lib]),
    ('tests/unit/protocol/rpc.cc',
     [elle_lib, reactor_lib, protocol_lib, cryptography_lib] + udt_libs),
    ('tests/unit/surface/gap/gap.cc', infinit_libs + [elle_lib, metrics_lib]),
    ('tests/unit/surface/gap/Metrics.cc', 'common/common.cc',
     [elle_lib, plasma_lib, metrics_lib, reactor_lib, cryptography_lib] +
     udt_libs),
    ('tests/unit/surface/gap/state_connect.cc',
     [elle_lib, lune_lib, plasma_lib, metrics_lib, gap_lib, metrics_lib] + manager_libs),
    # ('tests/unit/surface/gap/state_ctor.cc',
    #  [elle_lib, lune_lib, plasma_lib, metrics_lib, gap_lib, metrics_lib] + manager_libs),
    ('tests/unit/hole/hole.cc', infinit_libs)
  ]

  check = drake.Rule('check')
  check << elle.rule_check
  for test in tests_src_n_lib:
    bin_path = drake.Path(test[0])
    bin_path.extension = ''
    path = drake.Path(test[0])
    path.extension = ''
    test_bin = drake.cxx.Executable(path,
                                    drake.nodes(*test[:-1]) + test[-1],
                                    cxx_toolkit, tests_cxx_config)
    tests << test_bin
    runner = drake.Runner(test_bin)
    check << runner.status

  #Check
  rule_check = drake.Rule('check')
  rule_check << elle.rule_check

# vim: set sw=2 ts=2 sts=2 expandtab:
