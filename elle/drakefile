import drake
import drake.cxx
import drake.cxx.boost

config = None
lib_static = None
lib_dynamic = None

def configure(cxx_toolkit = None, cxx_config = None, boost = None, curl = None, enable_tests = True):

  global config, lib_static, lib_dynamic

  cxx_toolkit = cxx_toolkit or drake.cxx.Toolkit()
  cxx_config = cxx_config or drake.cxx.Config()

  config = drake.cxx.Config()
  config.standard = drake.cxx.Config.cxx_0x
  config.add_local_include_path('src')
  config.lib_path('lib')

  # OS
  if cxx_toolkit.os == drake.os.linux:
    config.define('INFINIT_LINUX')
  elif cxx_toolkit.os == drake.os.macos:
    config.define('INFINIT_MACOSX')
  elif cxx_toolkit.os == drake.os.windows:
    config.define('INFINIT_WINDOWS')
  else:
    raise Exception('unsupported os')

  config.define('HAVE_SETXATTR')

  if cxx_toolkit.os == drake.os.macos:
    config.define('HAVE_STATFS')

  # Curl
  curl = drake.cxx.find_library('curl/curl.h', curl)
  cxx_config += curl
  cxx_config.lib('curl')

  cxx_config = cxx_config + config

  sources = drake.nodes(
    'src/elle/Backtrace.cc',
    'src/elle/Backtrace.hh',
    'src/elle/Buffer.cc',
    'src/elle/Buffer.hh',
    'src/elle/Exception.cc',
    'src/elle/Exception.hh',
    'src/elle/HttpClient.cc',
    'src/elle/HttpClient.hh',
    'src/elle/HttpClient.hxx',
    'src/elle/IOStream.cc',
    'src/elle/IOStream.hh',
    'src/elle/Printable.cc',
    'src/elle/Printable.hh',
    'src/elle/Version.cc',
    'src/elle/assert.cc',
    'src/elle/assert.hh',
    'src/elle/compiler.hh',
    'src/elle/concept/Fileable.hh',
    'src/elle/concept/Fileable.hxx',
    'src/elle/concept/Uniquable.hh',
    'src/elle/concept/Uniquable.hxx',
    'src/elle/concept/fwd.hh',
    'src/elle/concurrency/fwd.hh',
    'src/elle/container/fwd.hh',
    'src/elle/container/timeline/Bucket.hh',
    'src/elle/container/timeline/Bucket.hxx',
    'src/elle/container/timeline/Timeline.hh',
    'src/elle/container/timeline/Timeline.hxx',
    'src/elle/container/timeline/fwd.hh',
    'src/elle/elle.hh',
    'src/elle/format/fwd.hh',
    'src/elle/format/hexadecimal.cc',
    'src/elle/format/hexadecimal.hh',
    'src/elle/format/ini/File.cc',
    'src/elle/format/ini/File.hh',
    'src/elle/format/ini/Section.cc',
    'src/elle/format/ini/Section.hh',
    'src/elle/format/ini/Section.hxx',
    'src/elle/format/ini/fwd.hh',
    'src/elle/format/json.hh',
    'src/elle/format/json/Array.cc',
    'src/elle/format/json/Array.hh',
    'src/elle/format/json/Array.hxx',
    'src/elle/format/json/Bool.cc',
    'src/elle/format/json/Bool.hh',
    'src/elle/format/json/Dictionary.cc',
    'src/elle/format/json/Dictionary.hh',
    'src/elle/format/json/Dictionary.hxx',
    'src/elle/format/json/Factory.cc',
    'src/elle/format/json/Factory.hh',
    'src/elle/format/json/Factory.hxx',
    'src/elle/format/json/Float.cc',
    'src/elle/format/json/Float.hh',
    'src/elle/format/json/Integer.cc',
    'src/elle/format/json/Integer.hh',
    'src/elle/format/json/Null.cc',
    'src/elle/format/json/Null.hh',
    'src/elle/format/json/Object.cc',
    'src/elle/format/json/Object.hh',
    'src/elle/format/json/Object.hxx',
    'src/elle/format/json/Parser.cc',
    'src/elle/format/json/Parser.hh',
    'src/elle/format/json/String.cc',
    'src/elle/format/json/String.hh',
    'src/elle/format/json/_detail.hh',
    'src/elle/format/json/fwd.hh',
    'src/elle/fwd.hh',
    'src/elle/io/Console.cc',
    'src/elle/io/Console.hh',
    'src/elle/io/Directory.cc',
    'src/elle/io/Directory.hh',
    'src/elle/io/Dumpable.cc',
    'src/elle/io/Dumpable.hh',
    'src/elle/io/File.cc',
    'src/elle/io/File.hh',
    'src/elle/io/Link.cc',
    'src/elle/io/Link.hh',
    'src/elle/io/Path.cc',
    'src/elle/io/Path.hh',
    'src/elle/io/Path.hxx',
    'src/elle/io/Pattern.cc',
    'src/elle/io/Pattern.hh',
    'src/elle/io/Piece.cc',
    'src/elle/io/Piece.hh',
    'src/elle/io/Unique.hh',
    'src/elle/io/fwd.hh',
    'src/elle/log.hh',
    'src/elle/log/Logger.cc',
    'src/elle/log/Logger.hh',
    'src/elle/log/Send.cc',
    'src/elle/log/Send.hh',
    'src/elle/log/Send.hxx',
    'src/elle/log/TextLogger.cc',
    'src/elle/log/TextLogger.hh',
    'src/elle/network/Host.cc',
    'src/elle/network/Host.hh',
    'src/elle/network/Host.hxx',
    'src/elle/network/Interface.cc',
    'src/elle/network/Interface.hh',
    'src/elle/network/Interface.hxx',
    'src/elle/network/Locus.cc',
    'src/elle/network/Locus.hh',
    'src/elle/network/Locus.hxx',
    'src/elle/network/Port.hh',
    'src/elle/network/fwd.hh',
    'src/elle/os.hh',
    'src/elle/os/getenv.cc',
    'src/elle/os/getenv.hh',
    'src/elle/os/path.cc',
    'src/elle/os/path.hh',
    'src/elle/os/path.hxx',
    'src/elle/print.cc',
    'src/elle/print.hh',
    'src/elle/print.hxx',
    'src/elle/printf.hh',
    'src/elle/printf.hxx',
    'src/elle/system/system.hh',
    'src/elle/system/platform.hh',
    'src/elle/types.hh',
    )

  sources += drake.nodes(
    'src/elle/serialize/ArchiveMode.cc',
    'src/elle/serialize/ArchiveMode.hh',
    'src/elle/serialize/ArraySerializer.hxx',
    'src/elle/serialize/Base64Archive.cc',
    'src/elle/serialize/Base64Archive.hh',
    'src/elle/serialize/BaseArchive.hh',
    'src/elle/serialize/BaseArchive.hxx',
    'src/elle/serialize/BinaryArchive.hh',
    'src/elle/serialize/BinaryArchive.hxx',
    'src/elle/serialize/Format.hh',
    'src/elle/serialize/HexadecimalArchive.hh',
    'src/elle/serialize/IniArchive.cc',
    'src/elle/serialize/IniArchive.hh',
    'src/elle/serialize/JSONArchive.cc',
    'src/elle/serialize/JSONArchive.hh',
    'src/elle/serialize/JSONArchive.hxx',
    'src/elle/serialize/ListSerializer.hxx',
    'src/elle/serialize/MapSerializer.hxx',
    'src/elle/serialize/PairSerializer.hxx',
    'src/elle/serialize/Pointer.hh',
    'src/elle/serialize/Pointer.hxx',
    'src/elle/serialize/Serializable.hh',
    'src/elle/serialize/Serializable.hh',
    'src/elle/serialize/Serializable.hxx',
    'src/elle/serialize/Serializable.hxx',
    'src/elle/serialize/Serializer.hh',
    'src/elle/serialize/SetSerializer.hxx',
    'src/elle/serialize/StaticFormat.hh',
    'src/elle/serialize/TupleSerializer.hxx',
    'src/elle/serialize/VectorSerializer.hxx',
    'src/elle/serialize/detail/AssociativeSerializer.hh',
    'src/elle/serialize/detail/MergeArchive.hh',
    'src/elle/serialize/detail/SequenceSerializer.hh',
    'src/elle/serialize/extract.cc',
    'src/elle/serialize/extract.hh',
    'src/elle/serialize/extract.hxx',
    'src/elle/serialize/footprint.hh',
    'src/elle/serialize/footprint.hxx',
    'src/elle/serialize/fwd.hh',
    'src/elle/serialize/insert.cc',
    'src/elle/serialize/insert.hh',
    'src/elle/serialize/insert.hxx',
    )

  sources += drake.nodes(
    'src/elle/system/platform.hh',
    'src/elle/system/Process.cc',
    'src/elle/system/Process.hh',
    'src/elle/system/system.hh',
    )

  sources += drake.nodes(
    'src/elle/utility/Duration.cc',
    'src/elle/utility/Duration.hh',
    'src/elle/utility/Duration.hxx',
    'src/elle/utility/HTTP.cc',
    'src/elle/utility/HTTP.hh',
    'src/elle/utility/Parser.cc',
    'src/elle/utility/Parser.hh',
    'src/elle/utility/Parser.hxx',
    'src/elle/utility/Product.hh',
    'src/elle/utility/Settings.cc',
    'src/elle/utility/Settings.hh',
    'src/elle/utility/Time.cc',
    'src/elle/utility/Time.hh',
    'src/elle/utility/Time.hxx',
    'src/elle/utility/URI.hh',
    'src/elle/utility/Unicode-unix.cc',
    'src/elle/utility/Unicode.hh',
    'src/elle/utility/Utility.hh',
    'src/elle/utility/fwd.hh',
   )

  lib_static = drake.cxx.StaticLib('lib/elle', sources, cxx_toolkit, cxx_config)
  lib_dynamic = drake.cxx.DynLib('lib/elle', sources, cxx_toolkit, cxx_config)

  # Tests

  tests = [
    'printf',
    'IOStream',
    'system/Process',
    ]

  class TestRunner(drake.Builder):

    def __init__(self, test):
      self.__test = test
      self.__out = drake.node('%s.out' % test.name())
      self.__err = drake.node('%s.err' % test.name())
      self.__status = drake.node('%s.status' % test.name())
      drake.Builder.__init__(self, [test], [self.__out, self.__err, self.__status])

    def execute(self):
      import subprocess
      path = str(self.__test.path())
      with open(str(self.__out.path()), 'w') as out, \
           open(str(self.__err.path()), 'w') as err, \
           open(str(self.__status.path()), 'w') as rv:
        self.output(path, 'Test %s' % self.__test)
        p = subprocess.Popen(path, stdout = out, stderr = err)
        p.wait()
        status = p.returncode
        print(status, file = rv)
      return status == 0

  boost = boost or drake.cxx.boost.Boost()

  cxx_config_tests = cxx_config + config
  cxx_config_tests += boost.config()
  cxx_config_tests += boost.config_filesystem()
  cxx_config_tests += boost.config_system()
  cxx_config_tests += boost.config_test()
  cxx_config_tests.lib_path_runtime('../lib')
  if enable_tests:
      for test in tests:
        print("Adding test", test)
        test = drake.cxx.Executable('tests/%s' % test,
                                    drake.nodes('tests/%s.cc' % test) + [lib_dynamic],
                                    cxx_toolkit, cxx_config_tests)
        TestRunner(test)
