#!/usr/bin/env python3

# Meta first, for papier and OpenSSL
import infinit.oracles.meta.server
from infinit.oracles.meta.server.utils import hash_pasword

import bottle
import datetime
import hashlib
import mongobox
import pymongo
import pymongo.collection
import pymongo.database

import sisyphus
import sisyphus.boulders.drip

class MongoExpectation:

  instance = None

  def __init__(self, index_miss = 0, object_miss = 0):
    self.index_miss = index_miss
    self.object_miss = object_miss

  def __enter__(self):
    self.__previous = MongoExpectation.instance
    MongoExpectation.instance = self

  def __exit__(self, *args, **kwargs):
    MongoExpectation.instance = self.__previous

MongoExpectation.instance = MongoExpectation()

class GestapoMongoClient(pymongo.MongoClient):

  def __getattr__(self, name):
    res = super().__getattr__(name)
    if res.__class__ is pymongo.database.Database:
      res.__class__ = GestapoDatabase
    return res

class GestapoDatabase(pymongo.database.Database):

  def __getattr__(self, name):
    res = super().__getattr__(name)
    if res.__class__ is pymongo.collection.Collection:
      res.__class__ = GestapoCollection
    return res

class GestapoCollection(pymongo.collection.Collection):

  def find(self, spec = None, fields = None):
    self.__check(spec)
    return super().find(spec = spec, fields = fields)

  def update(self, spec, document, multi = False):
    self.__check(spec)
    return super().update(spec = spec,
                          document = document,
                          multi = multi)

  def __check(self, condition):
    explanation = super().find(condition).explain()
    print(explanation['cursor'])
    print('  ', condition)
    print('  ', explanation)
    if explanation['cursor'] == 'BasicCursor':
      raise Exception('table scan on condition: %s' % condition)
    if explanation['scanAndOrder']:
      raise Exception('scan and order on condition: %s' % condition)
    nplans = len(list(e for e in explanation['allPlans']
                      if e['cursor'] != 'BasicCursor'))
    if nplans > 1:
      raise Exception('%s viable plans for condition: %s' % (nplans, condition))
    ns = explanation['nscanned']
    nso = explanation['nscannedObjects']
    n = explanation['n']
    print(ns, nso, n)
    if ns - nso > MongoExpectation.instance.index_miss:
      raise Exception('too many index scans (%s) for %s object scans on condition: %s' % (ns, nso, condition))
    if nso - n > MongoExpectation.instance.object_miss:
      raise Exception('too many object scans (%s) for %s results on condition: %s' % (nso, n, condition))

class Meta(infinit.oracles.meta.server.Meta):

  @property
  def now(self):
    if hasattr(self, '_Meta__now'):
      return self.__now
    else:
      return super().now

  @now.setter
  def now(self, value):
    self.__now = value

  def __enter__(self):
    def run():
      try:
        bottle.run(app = self,
                   quiet = True,
                   server = self.__server)
      except KeyboardInterrupt:
        pass
    import threading
    self.__server = bottle.WSGIRefServer(port = 0)
    self.__thread = threading.Thread(target = run)
    self.__thread.daemon = True
    self.__thread.start()
    while self.__server.port == 0 and self.__thread.is_alive():
      import time
      time.sleep(.1)
    return self


  def __exit__(self, *args, **kwargs):
    pass


class Mandrill:

  def __init__(self):
    self.__emails = []

  @property
  def emails(self):
    res = self.__emails
    self.__emails = []
    return res

  class Messages:

    def __init__(self, mandrill):
      self.__mandrill = mandrill

    def send_template(self,
                      template_name,
                      template_content,
                      message,
                      async):
      assert async
      for to in message['to']:
        self.__mandrill._Mandrill__emails.append(to['email'])

  @property
  def messages(self):
    return Mandrill.Messages(self)

class Onboarding(sisyphus.boulders.drip.Onboarding):

  def __init__(self, sisyphus):
    super().__init__(sisyphus)
    self.__now = datetime.datetime.utcnow()

  @property
  def now(self):
    return self.__now

  @now.setter
  def now(self, value):
    self.__now = value


with mongobox.MongoBox() as mongo:
  with Meta(mongo_port = mongo.port, enable_emails = False) as meta:
    mandrill = Mandrill()
    sisy = sisyphus.Sisyphus(mongo_port = mongo.port,
                                 mandrill = mandrill)
    sisy._Sisyphus__mongo.__class__ = GestapoMongoClient
    onboarding = Onboarding(sisy)
    # Check nothing is sent with no users
    sisy.cron()
    assert not mandrill.emails

    # Add deleted users to check they don't receive email and they are
    # not scanned by our mongo queries.
    del1 = meta.user_register('del1@infinit.io', '*' * 64, 'Foo Bar')
    meta.user_delete(del1)
    del2 = meta.user_register('del2@infinit.io', '*' * 64, 'Foo Bar')
    meta.user_delete(del2)
    del3 = meta.user_register('del3@infinit.io', '*' * 64, 'Foo Bar')
    meta.user_delete(del3)

    # Check nothing is sent to a fresh user
    meta.user_register('user1@infinit.io', '*' * 64, 'Foo Bar')
    sisy.cron()
    assert not mandrill.emails

    # Check unactivated 1 is sent to an aging user
    onboarding.now = datetime.datetime.utcnow() + datetime.timedelta(days = 2)
    meta.now = datetime.datetime.utcnow() + datetime.timedelta(days = 2)
    # Add unrelevant users to check they are not scanned by our mongo
    # queries.
    meta.user_register('user2@infinit.io', '*' * 64, 'Foo Bar')
    meta.user_register('user3@infinit.io', '*' * 64, 'Foo Bar')
    meta.user_register('user4@infinit.io', '*' * 64, 'Foo Bar')
    # The activated and unactivated bucket will always inspect user1
    # to check last_transaction_time, hence the one miss.
    with MongoExpectation(object_miss = 1):
      sisy.cron()
      assert mandrill.emails ==  ['user1@infinit.io']
      # Check it's not sent twice
      sisy.cron()
      assert not mandrill.emails
