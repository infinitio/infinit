#include <sstream>

#include <boost/uuid/uuid_io.hpp>
#include <boost/uuid/string_generator.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>

#include <elle/format/json/Dictionary.hh>
#include <elle/json/json.hh>
#include <elle/log.hh>
#include <elle/os/environ.hh>
#include <elle/print.hh>
#include <elle/serialization/json.hh>
#include <elle/serialize/JSONArchive.hh>
#include <elle/serialize/ListSerializer.hxx>
#include <elle/serialize/MapSerializer.hxx>
#include <elle/serialize/SetSerializer.hxx>
#include <elle/system/platform.hh>

#include <reactor/scheduler.hh>
#include <reactor/http/exceptions.hh>

#include <infinit/oracles/meta/Client.hh>
#include <infinit/oracles/meta/ErrorCode.hh>
#include <infinit/oracles/meta/macro.hh>

#include <surface/gap/Error.hh>

#include <version.hh>

ELLE_LOG_COMPONENT("infinit.plasma.meta.Client");

SERIALIZE_RESPONSE(infinit::oracles::meta::DebugResponse, ar, res)
{
  (void) ar;
  (void) res;
}

/*------.
| Users |
`------*/

SERIALIZE_RESPONSE(infinit::oracles::meta::LogoutResponse, ar, res)
{
  (void) ar;
  (void) res;
}

SERIALIZE_RESPONSE(infinit::oracles::meta::RegisterResponse, ar, res)
{
  ar & named("registered_user_id", res.registered_user_id);
  ar & named("invitation_source", res.invitation_source);
}

ELLE_SERIALIZE_SIMPLE(infinit::oracles::meta::User, ar, res, version)
{
  enforce(version == 0);
  ar & named("_id", res.id);
  ar & named("public_key", res.public_key);
  ar & named("fullname", res.fullname);
  ar & named("handle", res.handle);
  ar & named("connected_devices", res.connected_devices);
  ar & named("register_status", res.register_status);
}

SERIALIZE_RESPONSE(infinit::oracles::meta::UserResponse, ar, res)
{
  ar & static_cast<infinit::oracles::meta::User&>(res);
}

SERIALIZE_RESPONSE(infinit::oracles::meta::SelfResponse, ar, res)
{
  ar & static_cast<infinit::oracles::meta::User&>(res);

  ar & named("email", res.email);
  ar & named("identity", res.identity);
  ar & named("devices", res.devices);
  ar & named("favorites", res.favorites);
}

SERIALIZE_RESPONSE(infinit::oracles::meta::RemoveSwaggerResponse, ar, res)
{
  (void) ar;
  (void) res;
}

SERIALIZE_RESPONSE(infinit::oracles::meta::InviteUserResponse, ar, res)
{
  ar & named("_id", res._id);
}

// SERIALIZE_RESPONSE(infinit::oracles::meta::InvitedResponse, ar, res)
// {
//   ar & named("emails", res.emails);
// }

/*--------.
| Devices |
`--------*/

SERIALIZE_RESPONSE(infinit::oracles::meta::CreateDeviceResponse, ar, res)
{
  ar & named("id", res.id);
  ar & named("passport", res.passport);
  ar & named("name", res.name);
}

SERIALIZE_RESPONSE(infinit::oracles::meta::DeviceResponse, ar, res)
{
  ar & named("id", res.id);
  ar & named("passport", res.passport);
  ar & named("name", res.name);
}

SERIALIZE_RESPONSE(infinit::oracles::meta::UpdateDeviceResponse, ar, res)
{
  ar & named("id", res.id);
  ar & named("passport", res.passport);
  ar & named("name", res.name);
}

SERIALIZE_RESPONSE(infinit::oracles::meta::DeleteDeviceResponse, ar, res)
{
  ar & named("id", res.id);
}

/*-------------.
| Transactions |
`-------------*/

SERIALIZE_RESPONSE(infinit::oracles::meta::CreatePeerTransactionResponse, ar, res)
{
  ar & named("created_transaction_id", res.created_transaction_id);
  ar & named("remaining_invitations",  res.remaining_invitations);
}

SERIALIZE_RESPONSE(infinit::oracles::meta::UpdatePeerTransactionResponse, ar, res)
{
  ar & named("updated_transaction_id", res.updated_transaction_id);
}

SERIALIZE_RESPONSE(infinit::oracles::meta::MessageResponse, ar, res)
{
  (void) ar;
  (void) res;
}

SERIALIZE_RESPONSE(infinit::oracles::meta::EndpointNodeResponse, ar, res)
{
  ar & named("externals", res.externals);
  ar & named("locals", res.locals);
}

SERIALIZE_RESPONSE(infinit::oracles::meta::ConnectDeviceResponse, ar, res)
{
  (void) ar;
  (void) res;
}

SERIALIZE_RESPONSE(infinit::oracles::meta::FallbackResponse, ar, res)
{
  ar & named("fallback_host", res.fallback_host);
  ar & named("fallback_port_ssl", res.fallback_port_ssl);
  ar & named("fallback_port_tcp", res.fallback_port_tcp);
}

/*--------------.
| Server Status |
`--------------*/

SERIALIZE_RESPONSE(infinit::oracles::meta::ServerStatusResponse, ar, res)
{
  ar & named("status", res.status);
  if (res.status)
    res.message = "";
  else
    ar & named("message", res.message);
}

namespace infinit
{
  namespace oracles
  {
    namespace meta
    {
      using elle::sprintf;
      using reactor::http::Method;

      Exception::Exception(Error const& error, std::string const& message)
        : elle::Exception(message)
        , err{error}
      {}

      bool
      Exception::operator ==(Exception const& e) const
      {
        return (this->err == e.err);
      }

      bool
      Exception::operator ==(Error const& error) const
      {
        return (this->err == error);
      }

      bool
      Exception::operator !=(Error const& error) const
      {
        return !(*this == error);
      }

      static
      boost::posix_time::time_duration
      _requests_timeout()
      {
        auto env = elle::os::getenv("INFINIT_META_REQUEST_TIMEOUT", "");
        if (!env.empty())
          return boost::posix_time::seconds(boost::lexical_cast<int>(env));
        else
          return 30_sec;
      }

      User::User(std::string const& id,
                 std::string const& fullname,
                 std::string const& handle,
                 std::string const& register_status,
                 User::Devices const& devices,
                 std::string const& public_key):
        id(id),
        fullname(fullname),
        handle(handle),
        register_status(register_status),
        connected_devices(devices),
        public_key(public_key)
      {}

      namespace json = elle::format::json;

      // - Ctor & dtor ----------------------------------------------------------
      Client::Client(std::string const& protocol,
                     std::string const& server,
                     uint16_t port):
        _protocol(protocol),
        _host(server),
        _port(port),
        _root_url{elle::sprintf("%s://%s:%d", protocol, server, port)},
        _client{"MetaClient/" INFINIT_VERSION},
        _default_configuration(_requests_timeout(),
                               {},
                               reactor::http::Version::v10),
        _email{},
        _logged_in{false}
      {
        // Don't check the host name since we have only one certificate but we
        // change hostname between minor versions.
        this->_default_configuration.ssl_verify_host(false);
        this->_rng.seed(static_cast<unsigned int>(std::time(0)));
      }

      Client::~Client()
      {}

      std::string
      Client::session_id() const
      {
        if (this->_client.cookies().find("session-id") !=
          this->_client.cookies().end())
          return this->_client.cookies()["session-id"];
        return "";
      }

      void
      Client::session_id(std::string const& session_id)
      {
        ELLE_TRACE_SCOPE("%s: set the session id to %s", *this, session_id);
        this->_default_configuration.cookies()["session-id"] = session_id;
      }

      // - API calls ------------------------------------------------------------

      DebugResponse
      Client::status() const
      {
        return this->_request<DebugResponse>("/status", Method::GET);
      }

      /*------.
      | Users |
      `------*/
      static
      User
      user_from_json(boost::any const& json_)
      {
        auto const& json = boost::any_cast<elle::json::Object>(json_);
        User u;
        u.id = boost::any_cast<std::string>(json.at("id"));
        u.fullname = boost::any_cast<std::string>(json.at("fullname"));
        u.handle = boost::any_cast<std::string>(json.at("handle"));
        u.public_key = boost::any_cast<std::string>(json.at("public_key"));
        u.register_status =
          boost::any_cast<std::string>(json.at("register_status"));
        for (auto const& device:
             boost::any_cast<elle::json::Array>(json.at("connected_devices")))
        {
          u.connected_devices.push_back(boost::any_cast<std::string>(device));
        }
        return u;
      }

      LoginResponse::LoginResponse(
        elle::serialization::SerializerIn& s)
      {
        this->serialize(s);
      }

      LoginResponse::Trophonius::Trophonius(
        elle::serialization::SerializerIn& s)
      {
        this->serialize(s);
      }

      void
      LoginResponse::serialize(elle::serialization::Serializer& s)
      {
        s.serialize("_id", this->id);
        s.serialize("fullname", this->fullname);
        s.serialize("handle", this->handle);
        s.serialize("email", this->email);
        s.serialize("identity", this->identity);
        s.serialize("device_id", this->device_id);
        s.serialize("trophonius", this->trophonius);
      }

      void
      LoginResponse::Trophonius::serialize(elle::serialization::Serializer& s)
      {
        s.serialize("host", this->host);
        s.serialize("port", this->port);
        s.serialize("port_ssl", this->port_ssl);
      }

      LoginResponse
      Client::login(std::string const& email,
                    std::string const& password,
                    boost::uuids::uuid const& device_uuid)
      {
        std::string struuid = boost::lexical_cast<std::string>(device_uuid);

        auto request = this->_client.request(this->_url("/login"),
                                             Method::POST,
                                             "application/json",
                                             this->_default_configuration);
        {
          elle::serialization::json::SerializerOut output(request);
          output.serialize("email", const_cast<std::string&>(email));
          output.serialize("password", const_cast<std::string&>(password));
          std::string struuid = boost::lexical_cast<std::string>(device_uuid);
          output.serialize("device_id", struuid);
          auto os = elle::system::platform::name();
          output.serialize("OS", os);
        }
        if (request.status() == reactor::http::StatusCode::Forbidden)
        {
          elle::serialization::json::SerializerIn input(request);
          int error_code;
          input.serialize("code", error_code);
          using ErrorCode = ::oracles::meta::client::ErrorCode;
          switch (ErrorCode(error_code))
          {
            case ErrorCode::email_not_confirmed:
              throw infinit::state::UnconfirmedEmailError();
            case ErrorCode::email_password_dont_match:
              throw infinit::state::CredentialError();
            case ErrorCode::already_logged_in:
              throw infinit::state::AlreadyLoggedIn();

            default:
              throw infinit::state::LoginError("Unknown, good luck!");
          }
        }
        else
        {
          this->_handle_errors(request);
          {
            elle::serialization::json::SerializerIn input(request);
            LoginResponse response(input);
            // Debugging purpose.
            this->_email = email;
            this->_logged_in = true;
            return response;
          }
        }
      }

      LogoutResponse
      Client::logout()
      {
        auto res = this->_request<LogoutResponse>("/logout", Method::POST);
        if (res.success())
        {
          // Debugging purpose.
          this->_email = "";
          this->_logged_in = false;
        }
        return res;
      }

      LoginResponse::Trophonius
      Client::trophonius()
      {
        auto request = this->_request("/trophonius", Method::GET);
        elle::serialization::json::SerializerIn input(request);
        return LoginResponse::Trophonius(input);
      }

      RegisterResponse
      Client::register_(std::string const& email,
                        std::string const& fullname,
                        std::string const& password,
                        std::string const& activation_code) const
      {
        json::Dictionary request{std::map<std::string, std::string>{
            {"email", email},
            {"fullname", fullname},
            {"password", password},
            {"activation_code", activation_code},
              }};
        return this->_request<RegisterResponse>(
          "/user/register", Method::POST, request);
      }

      static
      std::pair<std::string, User>
      email_and_user(boost::any const& json_)
      {
        auto const& json = boost::any_cast<elle::json::Object>(json_);
        std::pair<std::string, User> res;
        res.first = boost::any_cast<std::string>(json.at("email"));
        res.second = user_from_json(json_);
        return res;
      }

      std::unordered_map<std::string, User>
      Client::search_users_by_emails(
        std::vector<std::string> const& emails, int limit, int offset) const
      {
        std::stringstream email_list;
        std::vector<boost::any> emails_json;
        for (auto email: emails)
        {
          emails_json.push_back(boost::any(std::string(email)));
        }
        elle::json::write(email_list, emails_json);
        std::string url = elle::sprintf(
          "/user/search_emails?emails=%s", email_list.str());
        if (limit > 0)
        {
          url += elle::sprintf("&limit=%s", limit);
        }
        if (offset > 0)
        {
          url += elle::sprintf("&offset=%s", offset);
        }
        reactor::http::Request request = this->_client.request(
          this->_url(url),
          Method::GET,
          this->_default_configuration);
        this->_handle_errors(request);
        auto json = elle::json::read(request);
        auto const& users =
          boost::any_cast<elle::json::Array>(
            boost::any_cast<elle::json::Object>(json).at("users"));
        std::unordered_map<std::string, User> res;
        for (auto const& user: users)
        {
          res.insert(email_and_user(user));
        }
        return res;
      }

      std::vector<User>
      Client::users_search(std::string const& text, int limit, int offset) const
      {
        std::string url = elle::sprintf("/users?search=%s", text);
        if (limit > 0)
        {
          url += elle::sprintf("&limit=%s", limit);
        }
        if (offset > 0)
        {
          url += elle::sprintf("&skip=%s", offset);
        }
        reactor::http::Request request = this->_client.request(
          this->_url(url),
          Method::GET,
          this->_default_configuration);
        this->_handle_errors(request);
        auto json = elle::json::read(request);
        auto const& users =
          boost::any_cast<elle::json::Array>(
            boost::any_cast<elle::json::Object>(json).at("users"));
        std::vector<User> res;
        for (auto const& user: users)
          res.push_back(user_from_json(user));
        return res;
      }

      UserResponse
      Client::user_from_handle(std::string const& handle) const
      {
        if (handle.size() == 0)
          throw elle::Exception("No handle");
        return this->_request<UserResponse>(
          sprintf("/user/from_handle/%s/view", handle), Method::GET);
      }

      UserResponse
      Client::user(std::string const& id) const
      {
        if (id.size() == 0)
          throw elle::Exception("Wrong id");
        return this->_request<UserResponse>(
          sprintf("/user/%s/view", id), Method::GET);
      }

      SelfResponse
      Client::self() const
      {
        return this->_request<SelfResponse>("/user/self", Method::GET);
      }

      UserResponse
      Client::user_from_public_key(std::string const& public_key) const
      {
        if (public_key.size() == 0)
          throw elle::Exception("empty public key!");
        json::Dictionary request;
        request["public_key"] = public_key;
        return this->_request<UserResponse>(
          "/user/from_public_key", Method::POST, request);
      }

      std::vector<User>
      Client::get_swaggers() const
      {
        std::string url = "/user/full_swaggers";
        reactor::http::Request request =
          this->_client.request(this->_url(url),
                                Method::GET,
                                this->_default_configuration);
        this->_handle_errors(request);
        auto json = elle::json::read(request);
        auto const& swaggers =
          boost::any_cast<elle::json::Array>(
            boost::any_cast<elle::json::Object>(json).at("swaggers"));
        std::vector<User> res;
        for (auto const& swagger: swaggers)
          res.push_back(user_from_json(swagger));
        return res;
      }

      RemoveSwaggerResponse
      Client::remove_swagger(std::string const& _id) const
      {
        json::Dictionary request{std::map<std::string, std::string>{
            {"_id", _id},
              }};

        return this->_request<RemoveSwaggerResponse>(
          "/user/remove_swagger", Method::POST, request);
      }

      Response
      Client::favorite(std::string const& user) const
      {
        json::Dictionary request;
        request["user_id"] = user;
        return this->_request<DebugResponse>(
          "/user/favorite", Method::POST, request);
      }

      Response
      Client::unfavorite(std::string const& user) const
      {
        json::Dictionary request;
        request["user_id"] = user;
        return this->_request<DebugResponse>(
          "/user/unfavorite", Method::POST, request);
      }

      // InvitedResponse
      // Client::invited() const
      // {
      //   return this->_get<InvitedResponse>("/user/invited");
      // }

      /*--------.
      | Devices |
      `--------*/
      CreateDeviceResponse
      Client::create_device(std::string const& name) const
      {
        json::Dictionary request{std::map<std::string, std::string>{
            {"name", name},
        }};
        return this->_request<CreateDeviceResponse>(
          "/device/create", Method::POST, request);
      }

      UpdateDeviceResponse
      Client::update_device(boost::uuids::uuid const& device_uuid,
                            std::string const& name) const
      {
        std::string struuid = boost::lexical_cast<std::string>(device_uuid);

        json::Dictionary request{std::map<std::string, std::string>{
            {"id", struuid},
            {"name", name},
        }};

        return this->_request<UpdateDeviceResponse>(
          "/device/update", Method::POST, request);
      }

      DeviceResponse
      Client::device(boost::uuids::uuid const& device_uuid) const
      {
        std::string struuid = boost::lexical_cast<std::string>(device_uuid);

        return this->_request<DeviceResponse>(
          sprintf("/device/%s/view", struuid), Method::GET);
      }

      DeleteDeviceResponse
      Client::delete_device(boost::uuids::uuid const& device_uuid) const
      {
        std::string struuid = boost::lexical_cast<std::string>(device_uuid);

        json::Dictionary request{std::map<std::string, std::string>{
            {"id", struuid},
         }};

        return this->_request<DeleteDeviceResponse>(
          "/device/delete", Method::POST, request);
      }

      /*------.
      | Users |
      `------*/
      InviteUserResponse
      Client::invite_user(std::string const& email) const
      {
        json::Dictionary request{std::map<std::string, std::string>
          {
            {"email", email}
          }};

        auto res = this->_request<InviteUserResponse>(
          "/user/invite", Method::POST, request);

        return res;
      }

      CreatePeerTransactionResponse
      Client::create_transaction(std::string const& recipient_id_or_email,
                                 std::list<std::string> const& files,
                                 size_t count,
                                 size_t size,
                                 bool is_dir,
                                 // boost::uuids::uuid const& device_uuid,
                                 std::string const& struuid,
                                 std::string const& message) const
      {
        json::Dictionary request;

        // std::string struuid = boost::lexical_cast<std::string>(device_uuid);

        request["id_or_email"] = recipient_id_or_email;
        request["files"] = files;
        request["files_count"] = count;
        request["total_size"] = size;
        request["is_directory"] = is_dir;
        request["device_id"] = struuid; // Can be determine by session.
        request["message"] = message;

        return this->_request<CreatePeerTransactionResponse>(
          "/transaction/create", Method::POST, request);
      }

      UpdatePeerTransactionResponse
      Client::update_transaction(std::string const& transaction_id,
                                 Transaction::Status status,
                                 std::string const& device_id,
                                 std::string const& device_name) const
      {
        ELLE_TRACE("%s: update %s transaction with new status %s",
                   *this,
                   transaction_id,
                   status);
        auto request = this->_request(
          "/transaction/update",
          Method::POST,
          [&] (reactor::http::Request& r)
          {
            elle::serialization::json::SerializerOut query(r);
            // FIXME: get rid of const casts when output serialization has his
            // const API
            query.serialize("transaction_id",
                            const_cast<std::string&>(transaction_id));
            int status_integral = static_cast<int>(status);
            query.serialize("status", status_integral);
            if (status == oracles::Transaction::Status::accepted)
            {
              ELLE_ASSERT_GT(device_id.length(), 0u);
              ELLE_ASSERT_GT(device_name.length(), 0u);
              query.serialize("device_id",
                              const_cast<std::string&>(device_id));
              query.serialize("device_name",
                              const_cast<std::string&>(device_name));
            }
          });
        return this->_deserialize_answer<UpdatePeerTransactionResponse>(
          std::move(request));
      }

      UpdatePeerTransactionResponse
      Client::accept_transaction(std::string const& transaction_id,
                                 std::string const& device_id,
                                 std::string const& device_name) const
      {
        ELLE_TRACE("%s: accept %s transaction on device %s (%s)",
                   *this, transaction_id, device_name, device_id);

        return this->update_transaction(transaction_id,
                                        Transaction::Status::accepted,
                                        device_id,
                                        device_name);
      }

      PeerTransaction
      Client::transaction(std::string const& _id) const
      {
        std::string url = sprintf("/transaction/%s", _id);
        reactor::http::Request request =
          this->_client.request(this->_url(url),
                                Method::GET,
                                this->_default_configuration);
        this->_handle_errors(request);
        elle::serialization::json::SerializerIn input(request);
        return PeerTransaction(input);
      }

      std::vector<PeerTransaction>
      Client::transactions(std::vector<Transaction::Status> const& statuses,
                           bool negate,
                           int count) const
      {
        std::string url;
        if (statuses.size() > 0)
        {
          std::stringstream filter;
          std::vector<boost::any> status_json;
          for (auto s: statuses)
            status_json.push_back(boost::any(int(s)));
          elle::json::write(filter, status_json);
          // FIXME: handle query parameters in reactor Request
          url = elle::sprintf("/transactions?count=%d&negate=%d&filter=%s",
                              count, negate, filter.str());
        }
        else
          url = "/transactions";
        reactor::http::Request request =
          this->_client.request(this->_url(url),
                                Method::GET,
                                this->_default_configuration);
        this->_handle_errors(request);
        std::list<PeerTransaction> res;
        elle::serialization::json::SerializerIn input(request);
        input.serialize("transactions", res);
        return std::vector<PeerTransaction>(res.begin(), res.end());
      }

      MessageResponse
      Client::send_message(std::string const& recipient_id,
                           std::string const& sender_id,
                           std::string const& message) const
      {
        json::Dictionary request{std::map<std::string, std::string>
          {
            {"recipient_id", recipient_id},
            {"sender_id", sender_id},
            {"message", message},
              }};

        // FIXME: Time.h ????
        request["time"] = 0;
        request["notification_id"] = 217;

        // FIXME: /user/message
        auto res = this->_request<MessageResponse>(
          "/debug", Method::POST, request);

        return res;
      }

      DebugResponse
      Client::debug() const
      {
        return this->_request<DebugResponse>("/scratchit", Method::GET);
      }

      void
      Client::transaction_endpoints_put(
        std::string const& transaction_id,
        std::string const& device_id,
        adapter_type const& local_endpoints,
        adapter_type const& public_endpoints) const
      {
        elle::json::Object json;
        json["device"] = device_id;
        auto convert_endpoints = [&](adapter_type const& endpoints)
          {
            std::vector<boost::any> res;
            for (auto const& endpoint: endpoints)
            {
              elle::json::Object o;
              o["ip"] = endpoint.first;
              o["port"] = endpoint.second;
              res.push_back(std::move(o));
            }
            return res;
          };
        json["locals"] = convert_endpoints(local_endpoints);
        json["externals"] = convert_endpoints(public_endpoints);
        auto url = elle::sprintf("/transaction/%s/endpoints", transaction_id);
        this->_request(url, Method::PUT, [&] (reactor::http::Request& r)
                       {
                         elle::json::write(r, json);
                       });
      }

      ConnectDeviceResponse
      Client::connect_device(std::string const& transaction_id,
                             std::string const& device_id,
                             adapter_type const& local_endpoints,
                             adapter_type const& public_endpoints) const
      {
        json::Dictionary request{
          std::map<std::string, std::string>{
            {"_id", transaction_id},
            {"device_id", device_id},
              }
        };

        json::Array local_addrs;
        for (auto& a: local_endpoints)
        {
          json::Dictionary endpoint;

          endpoint["ip"] = a.first;
          endpoint["port"] = a.second;
          local_addrs.push_back(endpoint);
        }

        request["locals"] = local_addrs;

        json::Array public_addrs;
        for (auto& a : public_endpoints)
        {
          json::Dictionary pub_addr;

          pub_addr["ip"] = a.first;
          pub_addr["port"] = a.second;
          public_addrs.push_back(pub_addr);
        }

        request["externals"] = public_addrs;

        return this->_request<ConnectDeviceResponse>(
          "/transaction/connect_device", Method::POST, request);
      }

      EndpointNodeResponse
      Client::device_endpoints(std::string const& transaction_id,
                               std::string const& self_device_id,
                               std::string const& device_id) const
      {
        json::Dictionary request{
          std::map<std::string, std::string>{
            {"self_device_id", self_device_id},
            {"device_id", device_id},
          }
        };

        return this->_request<EndpointNodeResponse>(
          sprintf("/transaction/%s/endpoints", transaction_id),
          Method::POST, request);
      }

      FallbackResponse
      Client::fallback(std::string const& _id) const
      {
        return this->_request<FallbackResponse>(
          elle::sprintf("/apertus/fallback/%s", _id), Method::GET);
      }

      aws::Credentials
      Client::get_cloud_buffer_token(std::string const& transaction_id,
                                     bool force_regenerate) const
      {
        auto url =
          elle::sprintf("/transaction/%s/cloud_buffer?force_regenerate=%s",
                        transaction_id, force_regenerate ? "true" : "false");
        try
        {
          auto request = this->_request(url, Method::GET);
          elle::serialization::json::SerializerIn input(request);
          return aws::Credentials(input);
        }
        catch (elle::http::Exception const& e)
        {
          if (e.code == elle::http::ResponseCode::gone)
            throw infinit::state::TransactionFinalized();
          else
            throw;
        }
      }

      /*------.
      | Links |
      `------*/

      CreateLinkTransactionResponse::CreateLinkTransactionResponse(
        elle::serialization::SerializerIn& s)
      {
        this->serialize(s);
      }

      void
      CreateLinkTransactionResponse::serialize(
        elle::serialization::Serializer& s)
      {
        s.serialize("aws_credentials", this->_aws_credentials);
        s.serialize("transaction", this->_transaction);
      }

      CreateLinkTransactionResponse
      Client::create_link(LinkTransaction::FileList const& files,
                          std::string const& name,
                          std::string const& message) const
      {
        auto request = this->_request(
          "/link", Method::POST,
          [&] (reactor::http::Request& request)
          {
            elle::serialization::json::SerializerOut query(request);
            // FIXME: get rid of const casts when output serialization has his
            // const API
            query.serialize("name", const_cast<std::string&>(name));
            query.serialize("files",
                            const_cast<LinkTransaction::FileList&>(files));
            query.serialize("message", const_cast<std::string&>(message));
          });
        elle::serialization::json::SerializerIn input(request);
        return CreateLinkTransactionResponse(input);
      }

      void
      Client::update_link(std::string const& id,
                          double progress,
                          Transaction::Status status) const
      {
        auto url = elle::sprintf("/link/%s", id);
        auto request = this->_request(
          url, Method::POST,
          [&] (reactor::http::Request& request)
          {
            elle::json::Object body;
            body["progress"] = progress;
            body["status"] = int(status);
            elle::json::write(request, body);
          });
      }

      std::vector<LinkTransaction>
      Client::links(int offset,
                    int count,
                    bool include_expired) const
      {
        std::string url =
          elle::sprintf("/links?offset=%s&count=%s", offset, count);
        if (include_expired)
          url += "&include_expired=1";
        auto request = this->_request(url, Method::GET);
        std::vector<LinkTransaction> res;
        elle::serialization::json::SerializerIn input(request);
        input.serialize("links", res);
        return res;
      }

      aws::Credentials
      Client::link_credentials(std::string const& id,
                               bool regenerate) const
      {
        std::string url = elle::sprintf("/link/%s/credentials", id);
        auto request = this->_request(
          url, regenerate ? Method::POST : Method::GET);
        elle::serialization::json::SerializerIn input(request);
        return aws::Credentials(input);
      }

      /*--------------.
      | Server Status |
      `--------------*/

      ServerStatusResponse
      Client::server_status() const
      {
        return this->_request<ServerStatusResponse>("/status", Method::GET);
      }

      elle::Buffer
      Client::icon(std::string const& user_id) const
      {
        std::string url = elle::sprintf("/user/%s/avatar?no_place_holder=1",
                                        user_id);
        reactor::http::Request request =
          this->_client.request(this->_url(url),
                                Method::GET,
                                this->_default_configuration);

        // If there is no avatar on the server, return an empty buffer.
        if (request.status() == reactor::http::StatusCode::OK)
        {
          return request.response();
        }
        else if (request.status() == reactor::http::StatusCode::Not_Found)
        {
          return elle::Buffer();
        }
        else
        {
          ELLE_ERR("%s: error while getting avatar for (%s): %s: %s",
                   *this, user_id, request.status(),
                   request.response().string());
          ELLE_ERR("%s", elle::Backtrace::current());
          throw elle::http::Exception(
            static_cast<elle::http::ResponseCode>(request.status()),
            elle::sprintf("error %s while getting on %s",
                          request.status(), request.url()));
        }
      }

      void
      Client::icon(std::string const& user_id,
                   elle::ConstWeakBuffer const& icon) const
      {
        reactor::http::Request request =
          this->_client.request(
            elle::sprintf("%s/user/avatar", this->_root_url),
            reactor::http::Method::POST,
            "application/octet-stream",
            this->_default_configuration);

        request.write((char const*) icon.contents(), icon.size());
        request.finalize();

        auto status = request.status();
        if (status != reactor::http::StatusCode::OK)
        {
          throw elle::http::Exception(
            static_cast<elle::http::ResponseCode>(status),
            elle::sprintf("error %s while POSTing avatar", status));
        }
      }

      /*--------.
      | Helpers |
      `--------*/

      void
      Client::_pacify_retry() const
      {
        // FIXME: make this delay exponential.
        boost::random::uniform_int_distribution<> random(100, 200);
        auto delay = 3_sec * (random(this->_rng) / 100.);
        ELLE_TRACE("%s: wait %s before retrying", this, delay);
        reactor::sleep(delay);
      }

      reactor::http::Request
      Client::_request(
        std::string const& url,
        Method method,
        std::function<void (reactor::http::Request&)> const& send) const
      {
        while (true)
        {
          try
          {
            reactor::http::Request request =
              method == Method::GET ?
              this->_client.request(this->_url(url),
                                    method,
                                    this->_default_configuration) :
              this->_client.request(this->_url(url),
                                    method,
                                    "application/json",
                                    this->_default_configuration);
            send(request);
            switch (request.status())
            {
              case reactor::http::StatusCode::Bad_Gateway:
              case reactor::http::StatusCode::Found:
              case reactor::http::StatusCode::Gateway_Timeout:
              case reactor::http::StatusCode::Service_Unavailable:
              // Make sure Found is really a transient proxy error before
              // activating that one.
              {
                ELLE_WARN("%s: error requesting %s, retrying: %s.\n%s",
                          *this, url,
                          request.status(), request.response().string())
                  if (request.status() == reactor::http::StatusCode::Found)
                  {
                    auto it = request.headers().find("Location");
                    if (it != request.headers().end())
                      ELLE_WARN("%s: Found location is %s", *this, *it);
                    else
                      ELLE_WARN("%s: Found location header is missing", *this);
                  }
                this->_pacify_retry();
                continue;
              }
              default:
                break;
            }
            this->_handle_errors(request);
            return request;
          }
          catch (reactor::http::Timeout const&)
          {
            ELLE_WARN("%s: timeout requesting %s, retrying", *this, url);
          }
          catch (reactor::http::ResolutionFailure const&)
          {
            ELLE_WARN("%s: resolution failure requesting %s, retrying",
                      *this, url);

            this->_pacify_retry();
          }
          catch (reactor::http::RequestError&)
          {
            ELLE_ERR("%s: unhandled error requesting %s, retrying: %s",
                     *this, url, elle::exception_string());

            this->_pacify_retry();
          }
        }
      }

      reactor::http::Request
      Client::_build_request(std::string const& url,
                             reactor::http::Method method,
                             elle::format::json::Object const& body) const
      {
        ELLE_LOG_COMPONENT("oracles.meta.client");
        ELLE_TRACE_SCOPE("%s: %s on %s", *this, method, url);

        reactor::http::Request request = &body ?
          this->_client.request(
            this->_root_url + url,
            method,
            "application/json",
            this->_default_configuration) :
          this->_client.request(
            this->_root_url + url,
            method,
            this->_default_configuration);

        if (&body)
        {
          request << body.repr() << "\n";
          request.finalize();
        }

        auto status = request.status();
        if (status != reactor::http::StatusCode::OK)
        {
          ELLE_ERR("%s: error while posting: %s (%s)",
                   *this, status, request.response().string());
          throw elle::http::Exception(
            static_cast<elle::http::ResponseCode>(status),
            elle::sprintf("error %s while posting on %s", status, url));
        }
        return request;
      }

      std::string
      Client::_url(std::string const& url) const
      {
        return this->_root_url + url;
      }

      void
      Client::_handle_errors(reactor::http::Request& request) const
      {
        auto response = request.status();
        if (response != reactor::http::StatusCode::OK)
        {
          ELLE_ERR("%s: error while posting: %s.\n%s",
                   *this, response, request.response().string());
          ELLE_ERR("%s", elle::Backtrace::current());
          throw elle::http::Exception(
            static_cast<elle::http::ResponseCode>(response),
            elle::sprintf("error %s while posting on %s",
                          response, request.url()));
        }
      }

      //- Properties ------------------------------------------------------------

      std::ostream&
      operator <<(std::ostream& out,
                  Error e)
      {
        switch (e)
        {
          <%! from infinit.oracles.meta.error import errors %>
          %for name, (code, comment) in sorted(errors.items()):
            case Error::${name}:
              out << "${name} (${comment})";
              break;
          %endfor
        }
        return out;
      }

      void
      User::print(std::ostream& stream) const
      {
        stream << "User(" << this->id << ", " << this->handle << ")";
      }

      /*----------.
      | Printable |
      `----------*/
      void
      Client::print(std::ostream& stream) const
      {
        stream << "meta::Client(" << this->_host << ":" << this->_port << " @" << this->_email << ")";
      }
    }
  }
}
