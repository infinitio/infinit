#ifndef  PLASMA_META_CLIENT_HH
# define PLASMA_META_CLIENT_HH

# include <infinit/oracles/Transaction.hh>

# include <elle/Exception.hh>
# include <elle/Buffer.hh>
# include <elle/HttpClient.hh> // XXX: Remove that. Only for exception.
# include <elle/format/json/fwd.hh>
# include <elle/log.hh>
# include <reactor/http/Request.hh>
# include <reactor/http/Client.hh>

# include <boost/uuid/uuid.hpp>

# include <algorithm>
# include <functional>
# include <list>
# include <map>
# include <memory>
# include <stdexcept>
# include <string>
# include <vector>

namespace infinit
{
  namespace oracles
  {
    namespace meta
    {
      namespace json = elle::format::json;

      enum class Error: int
      {
        <%! from infinit.oracles.meta.error import errors %>
        %for name, (code, comment) in sorted(errors.items()):
          ${name} = ${code},
        %endfor
      };

      /// Base class for every response
      struct Response
      {
        bool _success;
        Error error_code;
        std::string error_details;

        bool success() const
        {
          return _success;
        }
      };

      class Exception
        : public elle::Exception
      {
      public:
        Error const err;
        Exception(Error const& error, std::string const& message = "");

      public:
        bool operator ==(Exception const& e) const;
        bool operator ==(Error const& error) const;
        bool operator !=(Error const& error) const;
      };

      /////////////////////////
      struct DebugResponse : Response
      {};

      struct LoginResponse : Response
      {
        std::string fullname;
        std::string handle;
        std::string email;
        std::string identity;
        std::string id;
        // boost::uuids::uuid device_id;
        std::string device_id;
      };

      struct LogoutResponse : Response
      {};

      struct RegisterResponse:
        public Response
      {
        std::string registered_user_id;
        std::string invitation_source;
      };

      struct MessageResponse : Response
      {};

      struct User:
         public elle::Printable
      {
        typedef std::vector<std::string> Devices;
        std::string id;
        std::string fullname;
        std::string handle;
        std::string public_key;
        Devices connected_devices;

        User() = default;

        User(std::string const& id,
             std::string const& fullname,
             std::string const& handle,
             Devices const& connected_devices = {},
             std::string const& public_key = "");

        bool
        online() const
        {
          return !this->connected_devices.empty();
        }

        bool
        online(std::string const& device_id) const
        {
          return std::find(std::begin(this->connected_devices),
                           std::end(this->connected_devices),
                           device_id) != std::end(this->connected_devices);
        }

        bool
        ghost() const
        {
          return this->public_key.empty();
        }

        /*----------.
        | Printable |
        `----------*/
      public:
        virtual
        void
        print(std::ostream& stream) const override;

      };

      struct UserResponse : User, Response
      {
      };

      struct SelfResponse : UserResponse
      {
        std::string identity;
        std::string email;
        int remaining_invitations;
        std::string token_generation_key;
        // std::list<boost::uuids::uuid> devices;
        std::list<std::string> devices;
        std::list<std::string> favorites;
      };

      struct InviteUserResponse : Response
      {
        std::string _id;
      };

      // struct InvitedResponse: Response
      // {
      //   std::vector<std::map<std::string, std::string>> emails;
      // };

      struct UsersResponse : Response
      {
        std::list<std::string> users;
      };

      struct RemoveSwaggerResponse: Response
      {};

      struct SwaggersResponse : Response
      {
        std::list<std::string> swaggers;
      };

      struct CreateTransactionResponse : Response
      {
        std::string created_transaction_id;
        int remaining_invitations;
      };

      struct UpdateTransactionResponse : Response
      {
        std::string updated_transaction_id;
      };

      struct ConnectDeviceResponse:
        public Response
      {};

      struct EndpointNodeResponse : Response
      {
        std::vector<std::string>      externals;
        std::vector<std::string>      locals;
      };

      struct CloudBufferTokenResponse: Response
      {
        std::string access_key_id;
        std::string secret_access_key;
        std::string session_token;
        std::string expiration;
      };

      struct Device
      {
        // boost::uuids::uuid
        std::string id;
        std::string name;
        std::string passport;
      };

      struct CreateDeviceResponse : Response, Device
      {};

      struct DeviceResponse : Response, Device
      {};

      struct UpdateDeviceResponse : Response, Device
      {};

      struct DeleteDeviceResponse : Response
      {
        std::string id;
      };

      struct FallbackResponse: Response
      {
        std::string fallback_host;
        int fallback_port_ssl;
        int fallback_port_tcp;
      };

      struct ServerStatusResponse: Response
      {
        bool status;
        std::string message;
      };

      typedef elle::ConstWeakBuffer UserIcon;

      class Client: public elle::Printable
      {
        ELLE_ATTRIBUTE_R(std::string, protocol);
        ELLE_ATTRIBUTE_R(std::string, host);
        ELLE_ATTRIBUTE_R(uint16_t, port);

      private:
        ELLE_ATTRIBUTE_R(std::string, root_url);
        ELLE_ATTRIBUTE_P(reactor::http::Client, client, mutable);
        ELLE_ATTRIBUTE(reactor::http::Request::Configuration,
                       default_configuration);
        ELLE_ATTRIBUTE_RW(std::string, email);
        ELLE_ATTRIBUTE(std::string, session_id);
      public:
        std::string
        session_id() const;

        void
        session_id(std::string const&);

      public:
        Client(std::string const& protocol,
               std::string const& server,
               uint16_t port);

        virtual
        ~Client();

        Client(const Client&) = delete;
        void operator = (const Client&) = delete;
        /*---------.
        | Requests |
        `---------*/
      protected:
        template <typename T>
        T
        _request(std::string const& url,
                 reactor::http::Method method) const;

        template <typename T>
        T
        _request(std::string const& url,
                 reactor::http::Method method,
                 elle::format::json::Object const& body) const;

        reactor::http::Request
        _build_request(std::string const& url,
                       reactor::http::Method method,
                       elle::format::json::Object const& body) const;

        template <typename T>
        T
        _deserialize_answer(reactor::http::Request request) const;
      private:
        std::string
        _url(std::string const& path) const;
        void
        _handle_errors(reactor::http::Request& request) const;


      public:
        DebugResponse
        status() const;

        DebugResponse
        debug() const;

        LoginResponse
        login(std::string const& email,
              std::string const& password,
              boost::uuids::uuid const& device_uuid);

        LogoutResponse
        logout();

        ELLE_ATTRIBUTE_RW(bool, logged_in);

        RegisterResponse
        register_(std::string const& email,
                  std::string const& fullname,
                  std::string const& password,
                  std::string const& activation_code) const;

        Response
        resend_confirmation_email(std::string const& email) const;

        UserResponse
        user(std::string const& id) const;

        SelfResponse
        self() const;

        UserResponse
        user_from_handle(std::string const& handle) const;

        UserResponse
        user_from_public_key(std::string const& public_key) const;

        UsersResponse
        search_users(
          std::string const& text, int count = 10, int offset = 0) const;

        std::unordered_map<std::string, User>
        search_users_by_emails(std::vector<std::string> const& emails,
                               int limit = 10,
                               int offset = 0) const;

        std::vector<User>
        users_search(std::string const& text,
                     int limit = 5,
                     int offset = 0) const;

        SwaggersResponse
        get_swaggers() const;

        Response
        favorite(std::string const& user) const;

        Response
        unfavorite(std::string const& user) const;

        // SwaggerResponse
        // get_swagger(std::string const& id) const;

        CreateDeviceResponse
        create_device(std::string const& name) const;

        UpdateDeviceResponse
        update_device(boost::uuids::uuid const& device_uuid,
                      std::string const& name) const;

        DeviceResponse
        device(boost::uuids::uuid const& device_uuid) const;

        DeleteDeviceResponse
        delete_device(boost::uuids::uuid const& device_uuid) const;

        InviteUserResponse
        invite_user(std::string const& email) const;

        RemoveSwaggerResponse
        remove_swagger(std::string const& _id) const;

        // InvitedResponse
        // invited() const;

        Transaction
        transaction(std::string const& _id) const;

        /// Get the list of transactions that have a spectific status.
        /// The status can be pass threw 'status' list argument, allowing to
        /// search for many status matching.
        /// 'inclusive' is used to inverse the research result, by searching
        /// inclusivly or exclusivly in the status list.
        /// NB: If you let the default argument, it returns the 'non finished'
        /// transactions.
        /// 'count' is use to set a limit of transactions id to be pulled.
        std::vector<Transaction>
        transactions(std::vector<Transaction::Status> const& status = {},
                     bool negate = true,
                     int count = 0) const;

        CreateTransactionResponse
        create_transaction(std::string const& recipient_id_or_email,
                           std::list<std::string> const& files,
                           size_t count,
                           size_t size,
                           bool is_dir,
                           // boost::uuids::uuid const& device_uuid,
                           std::string const& device_uuid,
                           std::string const& message = "") const;

        UpdateTransactionResponse
        update_transaction(std::string const& transaction_id,
                           Transaction::Status status,
                           std::string const& device_id = "",
                           std::string const& device_name = "") const;

        UpdateTransactionResponse
        accept_transaction(std::string const& transaction_id,
                           std::string const& device_id,
                           std::string const& device_name) const;

        MessageResponse
        send_message(std::string const& recipient_id,
                     std::string const& sender_id, // DEBUG.
                     std::string const& message) const;

      private:
        typedef std::vector<std::pair<std::string, uint16_t>> adapter_type;

      public:
        void
        transaction_endpoints_put(std::string const& transaction_id,
                                  std::string const& device_id,
                                  adapter_type const& local_endpoints,
                                  adapter_type const& public_endpoints) const;

        ConnectDeviceResponse
        connect_device(std::string const& transaction_id,
                       std::string const& device_id,
                       adapter_type const& local_endpoints,
                       adapter_type const& public_endpoints) const;

      public:
        EndpointNodeResponse
        device_endpoints(std::string const& transaction_id,
                         std::string const& self_device_id,
                         std::string const& device_id) const;

        FallbackResponse
        fallback(std::string const& _id) const;

        CloudBufferTokenResponse
        get_cloud_buffer_token(std::string const& transaction_id,
                               bool force_regenerate) const;

      public:
        ServerStatusResponse
        server_status() const;

      public:
        elle::Buffer
        icon(std::string const& user_id) const;

        void
        icon(std::string const& user_id,
             elle::ConstWeakBuffer const& icon) const;

          /*----------.
          | Printable |
          `----------*/
      public:
        virtual
        void
        print(std::ostream& stream) const override;
      };

      std::ostream&
      operator <<(std::ostream& out,
                  Error e);
    }
  }
}

# include <infinit/oracles/meta/Client.hxx>

#endif
