#ifndef PLASMA_META_CLIENT_HH
# define PLASMA_META_CLIENT_HH

# include <algorithm>
# include <functional>
# include <list>
# include <map>
# include <memory>
# include <stdexcept>
# include <string>
# include <vector>

# include <boost/random.hpp>
# include <boost/uuid/uuid.hpp>

# include <elle/Buffer.hh>
# include <elle/Exception.hh>
# include <elle/HttpClient.hh> // XXX: Remove that. Only for exception.
# include <elle/format/json/fwd.hh>
# include <elle/json/json.hh>
# include <elle/log.hh>
# include <elle/serialization/fwd.hh>
# include <elle/serialization/SerializerIn.hh>

# include <aws/Credentials.hh>

# include <reactor/http/Client.hh>
# include <reactor/http/Request.hh>

# include <infinit/oracles/LinkTransaction.hh>
# include <infinit/oracles/PeerTransaction.hh>

namespace infinit
{
  namespace oracles
  {
    namespace meta
    {
      namespace json = elle::format::json;

      enum class Error: int
      {
        <%! from infinit.oracles.meta.error import errors %>
        %for name, (code, comment) in sorted(errors.items()):
          ${name} = ${code},
        %endfor
      };

      /// Base class for every response
      struct Response
      {
        bool _success;
        Error error_code;
        std::string error_details;

        bool success() const
        {
          return _success;
        }
      };

      class Exception
        : public elle::Exception
      {
      public:
        Error const err;
        Exception(Error const& error, std::string const& message = "");

      public:
        bool operator ==(Exception const& e) const;
        bool operator ==(Error const& error) const;
        bool operator !=(Error const& error) const;
      };

      /////////////////////////
      struct DebugResponse : Response
      {};

      struct LoginResponse
      {
        std::string fullname;
        std::string handle;
        std::string email;
        std::string identity;
        std::string id;
        // boost::uuids::uuid device_id;
        std::string device_id;
        struct Trophonius
        {
          std::string host;
          int port;
          int port_ssl;
          Trophonius() = default;
          Trophonius(elle::serialization::SerializerIn& s);
          void
          serialize(elle::serialization::Serializer& s);
        };
        Trophonius trophonius;
        LoginResponse() = default;
        LoginResponse(elle::serialization::SerializerIn& s);
        void
        serialize(elle::serialization::Serializer& s);
      };

      struct LogoutResponse : Response
      {};

      struct MessageResponse : Response
      {};

      struct User:
         public elle::Printable
      {
        typedef std::vector<std::string> Devices;
        std::string id;
        std::string fullname;
        std::string handle;
        std::string register_status;
        Devices connected_devices;
        std::string public_key;

        User() = default;

        User(std::string const& id,
             std::string const& fullname,
             std::string const& handle,
             std::string const& register_status,
             Devices const& connected_devices = {},
             std::string const& public_key = "");

        bool
        online() const
        {
          return !this->connected_devices.empty();
        }

        bool
        online(std::string const& device_id) const
        {
          return std::find(std::begin(this->connected_devices),
                           std::end(this->connected_devices),
                           device_id) != std::end(this->connected_devices);
        }

        // Check if there are devices other than that given online.
        // This is used when sending to self to determine if we need to cloud
        // buffer.
        // A simpler function could be used (such as len(devices) < 2) but
        // this would only make sense for ourself.
        bool
        online_excluding_device(std::string const& device_id) const
        {
          bool res = false;
          for (auto const& device: this->connected_devices)
          {
            if (device != device_id)
            {
              res = true;
              break;
            }
          }
          return res;
        }

        bool
        ghost() const
        {
          if (register_status == "ghost")
            return true;
          else
            return false;
        }

        bool
        deleted() const
        {
          if (register_status == "deleted")
            return true;
          else
            return false;
        }

        User(elle::serialization::SerializerIn& s);
        void
        serialize(elle::serialization::Serializer& s);

        /*----------.
        | Printable |
        `----------*/
      public:
        virtual
        void
        print(std::ostream& stream) const override;

      };

      struct Self : User
      {
      public:
        Self() = default;
        Self(elle::serialization::SerializerIn& s);
        void
        serialize(elle::serialization::Serializer& s);
        std::string identity;
        std::string email;
        int remaining_invitations;
        std::string token_generation_key;
        // std::list<boost::uuids::uuid> devices;
        std::list<std::string> devices;
        std::list<std::string> favorites;
      };

      struct InviteUserResponse : Response
      {
        std::string _id;
      };

      // struct InvitedResponse: Response
      // {
      //   std::vector<std::map<std::string, std::string>> emails;
      // };

      struct RemoveSwaggerResponse: Response
      {};

      struct CreatePeerTransactionResponse : Response
      {
        std::string created_transaction_id;
        int remaining_invitations;
      };

      struct UpdatePeerTransactionResponse : Response
      {
        std::string updated_transaction_id;
      };

      struct ConnectDeviceResponse:
        public Response
      {};

      struct EndpointNodeResponse : Response
      {
        std::vector<std::string>      externals;
        std::vector<std::string>      locals;
      };

      struct Device
      {
        // boost::uuids::uuid
        std::string id;
        std::string name;
        std::string passport;
      };

      struct CreateDeviceResponse : Response, Device
      {};

      struct DeviceResponse : Response, Device
      {};

      struct UpdateDeviceResponse : Response, Device
      {};

      struct DeleteDeviceResponse : Response
      {
        std::string id;
      };

      struct FallbackResponse: Response
      {
        std::string fallback_host;
        int fallback_port_ssl;
        int fallback_port_tcp;
      };

      class CreateLinkTransactionResponse
      {
      public:
        CreateLinkTransactionResponse() = default;
        ELLE_ATTRIBUTE_R(LinkTransaction, transaction);
        ELLE_ATTRIBUTE_R(aws::Credentials, aws_credentials);

        CreateLinkTransactionResponse(elle::serialization::SerializerIn& s);
        void
        serialize(elle::serialization::Serializer& s);
      };

      struct ServerStatusResponse: Response
      {
        bool status;
        std::string message;
      };

      typedef elle::ConstWeakBuffer UserIcon;

      class Client: public elle::Printable
      {
        ELLE_ATTRIBUTE_R(std::string, protocol);
        ELLE_ATTRIBUTE_R(std::string, host);
        ELLE_ATTRIBUTE_R(uint16_t, port);

      private:
        ELLE_ATTRIBUTE_R(std::string, root_url);
        ELLE_ATTRIBUTE_P(reactor::http::Client, client, mutable);
        ELLE_ATTRIBUTE_X(reactor::http::Request::Configuration,
                          default_configuration);
        ELLE_ATTRIBUTE_RW(std::string, email);
        ELLE_ATTRIBUTE(std::string, session_id);
      public:
        std::string
        session_id() const;

        void
        session_id(std::string const&);

      public:
        Client(std::string const& protocol,
               std::string const& server,
               uint16_t port);

        virtual
        ~Client();

        Client(const Client&) = delete;
        void operator = (const Client&) = delete;

      /*--------.
      | Helpers |
      `--------*/
      protected:
        reactor::http::Request
        _request(
          std::string const& url,
          reactor::http::Method method,
          std::function<void (reactor::http::Request&)> const& send) const;
        reactor::http::Request
        _request(
          std::string const& url,
          reactor::http::Method method,
          reactor::http::Request::QueryDict const& query_dict =
            reactor::http::Request::QueryDict(),
          std::function<void (reactor::http::Request&)> const& send =
            [] (reactor::http::Request&) {}) const;
        template <typename T>
        T
        _request(std::string const& url,
                 reactor::http::Method method) const;
        template <typename T>
        T
        _request(std::string const& url,
                 reactor::http::Method method,
                 elle::format::json::Object const& body) const;
        reactor::http::Request
        _build_request(std::string const& url,
                       reactor::http::Method method,
                       elle::format::json::Object const& body) const;
        template <typename T>
        T
        _deserialize_answer(reactor::http::Request request) const;
        virtual
        void
        _pacify_retry(int& retry_count) const;
      private:
        std::string
        _url(std::string const& path) const;
        void
        _handle_errors(reactor::http::Request& request) const;
        boost::random::mt19937 mutable _rng;

      public:
        DebugResponse
        status() const;

        DebugResponse
        debug() const;

        LoginResponse
        login(std::string const& email,
              std::string const& password,
              boost::uuids::uuid const& device_uuid);

        LogoutResponse
        logout();

        LoginResponse::Trophonius
        trophonius();

        ELLE_ATTRIBUTE_RW(bool, logged_in);

        std::string
        register_(std::string const& email,
                  std::string const& fullname,
                  std::string const& password) const;

        User
        user(std::string const& id) const;

        Self
        self() const;

        User
        user_from_handle(std::string const& handle) const;

        User
        user_from_public_key(std::string const& public_key) const;

        std::unordered_map<std::string, User>
        search_users_by_emails(std::vector<std::string> const& emails,
                               int limit = 10,
                               int offset = 0) const;

        std::vector<User>
        users_search(std::string const& text,
                     int limit = 5,
                     int offset = 0) const;

        std::vector<User>
        get_swaggers() const;

        Response
        favorite(std::string const& user) const;

        Response
        unfavorite(std::string const& user) const;

        // SwaggerResponse
        // get_swagger(std::string const& id) const;

        CreateDeviceResponse
        create_device(std::string const& name) const;

        UpdateDeviceResponse
        update_device(boost::uuids::uuid const& device_uuid,
                      std::string const& name) const;

        DeviceResponse
        device(boost::uuids::uuid const& device_uuid) const;

        DeleteDeviceResponse
        delete_device(boost::uuids::uuid const& device_uuid) const;

        InviteUserResponse
        invite_user(std::string const& email) const;

        RemoveSwaggerResponse
        remove_swagger(std::string const& _id) const;

        // InvitedResponse
        // invited() const;

        PeerTransaction
        transaction(std::string const& _id) const;

        /// Fetch the list of transactions which have spectific statuses.
        /// A list of statuses to match can be passed through the 'statuses'
        /// list argument.
        /// 'negate' is used to inverse the search result, by either filtering
        /// for or by the 'statuses'.
        /// 'count' is use to set a limit to the number of transactions fetched.
        /// NB: The default arguments return the server's default response:
        /// all the unfinished transactions.
        std::vector<PeerTransaction>
        transactions(std::vector<Transaction::Status> const& statuses = {},
                     bool negate = false,
                     int count = 0) const;

        CreatePeerTransactionResponse
        create_transaction(std::string const& recipient_id_or_email,
                           std::list<std::string> const& files,
                           size_t count,
                           size_t size,
                           bool is_dir,
                           // boost::uuids::uuid const& device_uuid,
                           std::string const& device_uuid,
                           std::string const& message = "") const;

        UpdatePeerTransactionResponse
        update_transaction(std::string const& transaction_id,
                           Transaction::Status status,
                           std::string const& device_id = "",
                           std::string const& device_name = "") const;

        MessageResponse
        send_message(std::string const& recipient_id,
                     std::string const& sender_id, // DEBUG.
                     std::string const& message) const;

      private:
        typedef std::vector<std::pair<std::string, uint16_t>> adapter_type;

      public:
        void
        transaction_endpoints_put(std::string const& transaction_id,
                                  std::string const& device_id,
                                  adapter_type const& local_endpoints,
                                  adapter_type const& public_endpoints) const;

        ConnectDeviceResponse
        connect_device(std::string const& transaction_id,
                       std::string const& device_id,
                       adapter_type const& local_endpoints,
                       adapter_type const& public_endpoints) const;

      public:
        EndpointNodeResponse
        device_endpoints(std::string const& transaction_id,
                         std::string const& self_device_id,
                         std::string const& device_id) const;

        FallbackResponse
        fallback(std::string const& _id) const;

        aws::Credentials
        get_cloud_buffer_token(std::string const& transaction_id,
                               bool force_regenerate) const;

      /*------.
      | Links |
      `------*/
      public:
        CreateLinkTransactionResponse
        create_link(LinkTransaction::FileList const& file_list,
                    std::string const& name,
                    std::string const& message) const;
        void
        update_link(std::string const& id,
                    double progress,
                    Transaction::Status status) const;
        std::vector<LinkTransaction>
        links(int offset = 0,
              int count = 500,
              bool include_expired = false) const;
        aws::Credentials
        link_credentials(std::string const& id,
                         bool regenerate = false) const;

      public:
        ServerStatusResponse
        server_status() const;


      /*----------.
      | Self User |
      `----------*/
      public:
        void
        change_email(std::string const& email,
                     std::string const& password) const;

        void
        change_password(std::string const& old_password,
                        std::string const& new_password) const;

        void
        edit_user(std::string const& fullname, std::string const& handle) const;

        elle::Buffer
        icon(std::string const& user_id) const;

        void
        icon(std::string const& user_id,
             elle::ConstWeakBuffer const& icon) const;

      /*----------.
      | Printable |
      `----------*/
      public:
        virtual
        void
        print(std::ostream& stream) const override;
      };

      std::ostream&
      operator <<(std::ostream& out,
                  Error e);
    }
  }
}

# include <infinit/oracles/meta/Client.hxx>

#endif
