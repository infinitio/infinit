#ifndef  PLASMA_META_CLIENT_HH
# define PLASMA_META_CLIENT_HH

# include <infinit/oracles/LinkTransaction.hh>
# include <infinit/oracles/PeerTransaction.hh>

# include <aws/Credentials.hh>

# include <elle/Buffer.hh>
# include <elle/Exception.hh>
# include <elle/format/json/fwd.hh>
# include <elle/HttpClient.hh> // XXX: Remove that. Only for exception.
# include <elle/log.hh>
# include <elle/serialization/fwd.hh>
# include <elle/serialization/SerializerIn.hh>
# include <elle/serialize/construct.hh>
# include <reactor/http/Client.hh>
# include <reactor/http/Request.hh>

# include <boost/uuid/uuid.hpp>

# include <algorithm>
# include <functional>
# include <list>
# include <map>
# include <memory>
# include <stdexcept>
# include <string>
# include <vector>

namespace infinit
{
  namespace oracles
  {
    namespace meta
    {
      namespace json = elle::format::json;

      enum class Error: int
      {
        <%! from infinit.oracles.meta.error import errors %>
        %for name, (code, comment) in sorted(errors.items()):
          ${name} = ${code},
        %endfor
      };

      /// Base class for every response
      struct Response
      {
        bool _success;
        Error error_code;
        std::string error_details;

        bool success() const
        {
          return _success;
        }
      };

      class Exception
        : public elle::Exception
      {
      public:
        Error const err;
        Exception(Error const& error, std::string const& message = "");

      public:
        bool operator ==(Exception const& e) const;
        bool operator ==(Error const& error) const;
        bool operator !=(Error const& error) const;
      };

      /////////////////////////
      struct DebugResponse : Response
      {};

      struct LoginResponse : Response
      {
        std::string fullname;
        std::string handle;
        std::string email;
        std::string identity;
        std::string id;
        // boost::uuids::uuid device_id;
        std::string device_id;
      };

      struct LogoutResponse : Response
      {};

      struct RegisterResponse:
        public Response
      {
        std::string registered_user_id;
        std::string invitation_source;
      };

      struct MessageResponse : Response
      {};

      struct User:
         public elle::Printable
      {
        typedef std::vector<std::string> Devices;
        std::string id;
        std::string fullname;
        std::string handle;
        std::string register_status;
        Devices connected_devices;
        std::string public_key;

        User() = default;

        User(std::string const& id,
             std::string const& fullname,
             std::string const& handle,
             std::string const& register_status,
             Devices const& connected_devices = {},
             std::string const& public_key = "");

        bool
        online() const
        {
          return !this->connected_devices.empty();
        }

        bool
        online(std::string const& device_id) const
        {
          return std::find(std::begin(this->connected_devices),
                           std::end(this->connected_devices),
                           device_id) != std::end(this->connected_devices);
        }

        bool
        ghost() const
        {
          if (register_status == "ghost")
            return true;
          else
            return false;
        }

        bool
        deleted() const
        {
          if (register_status == "deleted")
            return true;
          else
            return false;
        }

        /*----------.
        | Printable |
        `----------*/
      public:
        virtual
        void
        print(std::ostream& stream) const override;

      };

      struct UserResponse : User, Response
      {
      };

      struct SelfResponse : UserResponse
      {
        std::string identity;
        std::string email;
        int remaining_invitations;
        std::string token_generation_key;
        // std::list<boost::uuids::uuid> devices;
        std::list<std::string> devices;
        std::list<std::string> favorites;
      };

      struct InviteUserResponse : Response
      {
        std::string _id;
      };

      // struct InvitedResponse: Response
      // {
      //   std::vector<std::map<std::string, std::string>> emails;
      // };

      struct RemoveSwaggerResponse: Response
      {};

      struct CreatePeerTransactionResponse : Response
      {
        std::string created_transaction_id;
        int remaining_invitations;
      };

      struct UpdatePeerTransactionResponse : Response
      {
        std::string updated_transaction_id;
      };

      struct ConnectDeviceResponse:
        public Response
      {};

      struct EndpointNodeResponse : Response
      {
        std::vector<std::string>      externals;
        std::vector<std::string>      locals;
      };

      struct CloudBufferTokenResponse: Response
      {
        std::string access_key_id;
        std::string secret_access_key;
        std::string session_token;
        std::string expiration;
        std::string protocol;
        std::string region;
        std::string bucket;
        std::string folder;
      };

      struct Device
      {
        // boost::uuids::uuid
        std::string id;
        std::string name;
        std::string passport;
      };

      struct CreateDeviceResponse : Response, Device
      {};

      struct DeviceResponse : Response, Device
      {};

      struct UpdateDeviceResponse : Response, Device
      {};

      struct DeleteDeviceResponse : Response
      {
        std::string id;
      };

      struct FallbackResponse: Response
      {
        std::string fallback_host;
        int fallback_port_ssl;
        int fallback_port_tcp;
      };

      class CreateLinkTransactionResponse
      {
      public:
        CreateLinkTransactionResponse() = default;

        ELLE_ATTRIBUTE_R(aws::Credentials, aws_credentials);
        ELLE_ATTRIBUTE_R(std::string, destination);
        ELLE_ATTRIBUTE_R(std::string, id);
        ELLE_ATTRIBUTE_R(std::string, share_link);

        CreateLinkTransactionResponse(elle::serialization::SerializerIn& s)
        {
          this->serialize(s);
        }

        void
        serialize(elle::serialization::Serializer& s)
        {
          s.serialize("aws_credentials", this->_aws_credentials);
          s.serialize("destination", this->_destination);
          s.serialize("id", this->_id);
          s.serialize("share_link", this->_share_link);
        }
      };

      class LinkTransactionResponse
      {
      public:
        LinkTransactionResponse() = default;

        ELLE_ATTRIBUTE_R(aws::Credentials, aws_credentials);
        ELLE_ATTRIBUTE_R(int32_t, click_count);
        ELLE_ATTRIBUTE_R(std::string, cloud_location);
        ELLE_ATTRIBUTE_R(double, creation_time);
        ELLE_ATTRIBUTE_R(double, expiry_time);
        ELLE_ATTRIBUTE_R(LinkTransaction::FileList, file_list);
        ELLE_ATTRIBUTE_R(std::string, id);
        ELLE_ATTRIBUTE_R(std::string, name);
        ELLE_ATTRIBUTE_R(double, progress);
        ELLE_ATTRIBUTE_R(Transaction::Status, status);

        LinkTransactionResponse(elle::serialization::SerializerIn& s)
        {
          this->serialize(s);
        }

        void
        serialize(elle::serialization::Serializer& s)
        {
          s.serialize("aws_credentials", this->_aws_credentials);
          s.serialize("click_count", this->_click_count);
          s.serialize("cloud_location", this->_cloud_location);
          s.serialize("creation_time", this->_creation_time);
          s.serialize("expiry_time", this->_expiry_time);
          s.serialize("file_list", this->_file_list);
          s.serialize("id", this->_id);
          s.serialize("name", this->_name);
          s.serialize("progress", this->_progress);
          s.serialize("status", this->_status, elle::serialization::as<int>());
        }
      };

      class LinkTransactionsResponse
      {
      public:
        LinkTransactionsResponse() = default;
        LinkTransactionsResponse(
          std::vector<LinkTransactionResponse> const& transactions);

        ELLE_ATTRIBUTE_R(std::vector<LinkTransactionResponse>, transactions);

        LinkTransactionsResponse(elle::serialization::SerializerIn& s)
        {
          this->serialize(s);
        }

        void
        serialize(elle::serialization::Serializer& s)
        {
          s.serialize("transactions", this->_transactions);
        }
      };

      struct ServerStatusResponse: Response
      {
        bool status;
        std::string message;
      };

      typedef elle::ConstWeakBuffer UserIcon;

      class Client: public elle::Printable
      {
        ELLE_ATTRIBUTE_R(std::string, protocol);
        ELLE_ATTRIBUTE_R(std::string, host);
        ELLE_ATTRIBUTE_R(uint16_t, port);

      private:
        ELLE_ATTRIBUTE_R(std::string, root_url);
        ELLE_ATTRIBUTE_P(reactor::http::Client, client, mutable);
        ELLE_ATTRIBUTE(reactor::http::Request::Configuration,
                       default_configuration);
        ELLE_ATTRIBUTE_RW(std::string, email);
        ELLE_ATTRIBUTE(std::string, session_id);
      public:
        std::string
        session_id() const;

        void
        session_id(std::string const&);

      public:
        Client(std::string const& protocol,
               std::string const& server,
               uint16_t port);

        virtual
        ~Client();

        Client(const Client&) = delete;
        void operator = (const Client&) = delete;
        /*---------.
        | Requests |
        `---------*/
      protected:
        template <typename T>
        T
        _request(std::string const& url,
                 reactor::http::Method method) const;

        template <typename T>
        T
        _request(std::string const& url,
                 reactor::http::Method method,
                 elle::format::json::Object const& body) const;

        reactor::http::Request
        _build_request(std::string const& url,
                       reactor::http::Method method,
                       elle::format::json::Object const& body) const;

        template <typename T>
        T
        _deserialize_answer(reactor::http::Request request) const;
      private:
        std::string
        _url(std::string const& path) const;
        void
        _handle_errors(reactor::http::Request& request) const;


      public:
        DebugResponse
        status() const;

        DebugResponse
        debug() const;

        LoginResponse
        login(std::string const& email,
              std::string const& password,
              boost::uuids::uuid const& device_uuid);

        LogoutResponse
        logout();

        ELLE_ATTRIBUTE_RW(bool, logged_in);

        RegisterResponse
        register_(std::string const& email,
                  std::string const& fullname,
                  std::string const& password,
                  std::string const& activation_code) const;

        Response
        resend_confirmation_email(std::string const& email) const;

        UserResponse
        user(std::string const& id) const;

        SelfResponse
        self() const;

        UserResponse
        user_from_handle(std::string const& handle) const;

        UserResponse
        user_from_public_key(std::string const& public_key) const;

        std::unordered_map<std::string, User>
        search_users_by_emails(std::vector<std::string> const& emails,
                               int limit = 10,
                               int offset = 0) const;

        std::vector<User>
        users_search(std::string const& text,
                     int limit = 5,
                     int offset = 0) const;

        std::vector<User>
        get_swaggers() const;

        Response
        favorite(std::string const& user) const;

        Response
        unfavorite(std::string const& user) const;

        // SwaggerResponse
        // get_swagger(std::string const& id) const;

        CreateDeviceResponse
        create_device(std::string const& name) const;

        UpdateDeviceResponse
        update_device(boost::uuids::uuid const& device_uuid,
                      std::string const& name) const;

        DeviceResponse
        device(boost::uuids::uuid const& device_uuid) const;

        DeleteDeviceResponse
        delete_device(boost::uuids::uuid const& device_uuid) const;

        InviteUserResponse
        invite_user(std::string const& email) const;

        RemoveSwaggerResponse
        remove_swagger(std::string const& _id) const;

        // InvitedResponse
        // invited() const;

        PeerTransaction
        transaction(std::string const& _id) const;

        /// Fetch the list of transactions which have spectific statuses.
        /// A list of statuses to match can be passed through the 'statuses'
        /// list argument.
        /// 'negate' is used to inverse the search result, by either filtering
        /// for or by the 'statuses'.
        /// 'count' is use to set a limit to the number of transactions fetched.
        /// NB: The default arguments return the server's default response:
        /// all the unfinished transactions.
        std::vector<PeerTransaction>
        transactions(std::vector<Transaction::Status> const& statuses = {},
                     bool negate = false,
                     int count = 0) const;

        CreatePeerTransactionResponse
        create_transaction(std::string const& recipient_id_or_email,
                           std::list<std::string> const& files,
                           size_t count,
                           size_t size,
                           bool is_dir,
                           // boost::uuids::uuid const& device_uuid,
                           std::string const& device_uuid,
                           std::string const& message = "") const;

        UpdatePeerTransactionResponse
        update_transaction(std::string const& transaction_id,
                           Transaction::Status status,
                           std::string const& device_id = "",
                           std::string const& device_name = "") const;

        UpdatePeerTransactionResponse
        accept_transaction(std::string const& transaction_id,
                           std::string const& device_id,
                           std::string const& device_name) const;

        MessageResponse
        send_message(std::string const& recipient_id,
                     std::string const& sender_id, // DEBUG.
                     std::string const& message) const;

      private:
        typedef std::vector<std::pair<std::string, uint16_t>> adapter_type;

      public:
        void
        transaction_endpoints_put(std::string const& transaction_id,
                                  std::string const& device_id,
                                  adapter_type const& local_endpoints,
                                  adapter_type const& public_endpoints) const;

        ConnectDeviceResponse
        connect_device(std::string const& transaction_id,
                       std::string const& device_id,
                       adapter_type const& local_endpoints,
                       adapter_type const& public_endpoints) const;

      public:
        EndpointNodeResponse
        device_endpoints(std::string const& transaction_id,
                         std::string const& self_device_id,
                         std::string const& device_id) const;

        FallbackResponse
        fallback(std::string const& _id) const;

        CloudBufferTokenResponse
        get_cloud_buffer_token(std::string const& transaction_id,
                               bool force_regenerate) const;

        /*------.
        | Links |
        `------*/
      public:
        CreateLinkTransactionResponse
        create_link(LinkTransaction::FileList const& file_list,
                    std::string const& name);

        void
        update_link(std::string const& id,
                    double progress,
                    Transaction::Status status);

        LinkTransactionsResponse
        links(int offset = 0,
              int count = 100,
              bool include_expired = false);

      public:
        ServerStatusResponse
        server_status() const;

      public:
        elle::Buffer
        icon(std::string const& user_id) const;

        void
        icon(std::string const& user_id,
             elle::ConstWeakBuffer const& icon) const;

          /*----------.
          | Printable |
          `----------*/
      public:
        virtual
        void
        print(std::ostream& stream) const override;
      };

      std::ostream&
      operator <<(std::ostream& out,
                  Error e);
    }
  }
}

# include <infinit/oracles/meta/Client.hxx>

#endif
