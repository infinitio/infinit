#include <csignal>
#include <fcntl.h>
#include <fstream>
#include <iostream>

#include <boost/random.hpp>

#include <elle/Buffer.hh>
#include <elle/assert.hh>
#include <elle/finally.hh>
#include <elle/format/json/Dictionary.hh>
#include <elle/format/json/Parser.hh>
#include <elle/format/json/Object.hh>
#include <elle/format/json/Array.hh>
#include <elle/json/exceptions.hh>
#include <elle/json/json.hh>
#include <elle/log.hh>
#include <elle/memory.hh>
#include <elle/print.hh>
#include <elle/serialize/JSONArchive.hh>
#include <elle/serialize/ListSerializer.hxx>
#include <elle/serialize/NamedValue.hh>
#include <elle/serialize/Serializer.hh>
#include <elle/serialize/extract.hh>
#include <elle/serialize/insert.hh>

#include <reactor/exception.hh>
#include <reactor/network/buffer.hh>
#include <reactor/network/exception.hh>
#include <reactor/network/resolve.hh>
#include <reactor/network/fingerprinted-socket.hh>
#include <reactor/scheduler.hh>
#include <reactor/Scope.hh>
#include <reactor/thread.hh>

#include <infinit/oracles/trophonius/Client.hh>

ELLE_LOG_COMPONENT("infinit.oracles.trophonius.Client");

#ifdef INFINIT_WINDOWS
# define SUICIDE() ::exit(0);
#else
# define SUICIDE() ::kill(::getpid(), SIGKILL)
#endif

/*-------------------------.
| Notification serializers |
`-------------------------*/
ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::Notification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::Notification, ar, value, version)
{
  (void)version;
  ar & named("notification_type", value.notification_type);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::ConnectionEnabledNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::ConnectionEnabledNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & named("response_code", value.response_code);
  ar & named("response_details", value.response_details);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::NewSwaggerNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::NewSwaggerNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & named("user_id", value.user_id);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::UserStatusNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::UserStatusNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & named("user_id", value.user_id);
  ar & named("status", value.status);
  ar & named("device_id", value.device_id);
  ar & named("device_status", value.device_status);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::TransactionNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::TransactionNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & base_class<infinit::oracles::Transaction>(value);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::PeerReachabilityNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::PeerReachabilityNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & named("transaction_id", value.transaction_id);
  ar & named("status", value.status);
  ar & named("devices", value. devices);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::MessageNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::MessageNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & named("sender_id", value.sender_id);
  ar & named("message", value.message);
}

// Local fingerprint as sha1.

static const std::vector<unsigned char> fingerprint =
{
  0xCB, 0xC5, 0x12, 0xBB, 0x86, 0x4D, 0x6B, 0x1C, 0xBC, 0x02,
  0x3D, 0xD8, 0x44, 0x75, 0xC1, 0x8C, 0x6E, 0xfC, 0x3B, 0x65
};

namespace infinit
{
  namespace oracles
  {
    namespace trophonius
    {
      boost::posix_time::time_duration const default_ping_period(
        boost::posix_time::seconds(30));

        /*--------------.
        | Notifications |
        `--------------*/
      void
      Notification::print(std::ostream& stream) const
      {
        stream << this->notification_type;
      }

      void
      UserStatusNotification::print(std::ostream& stream) const
      {
        stream << "Notification user " << user_id
               << " went " << (device_status ? "on" : "off")
               << "line on device " << device_id;
      }

      void
      TransactionNotification::print(std::ostream& stream) const
      {
        stream << this->notification_type << ": "
               << *static_cast<Transaction const*>(this);
      }

      std::unique_ptr<Notification>
      notification_from_dict(json::Dictionary const& dict)
      {
        ELLE_TRACE("convert json %s to Notification instance", dict.repr());
        NotificationType type = dict["notification_type"].as<NotificationType>();
        using namespace elle::serialize;
        auto extractor = from_string<InputJSONArchive>(dict.repr());
        typedef std::unique_ptr<Notification> Ptr;
        switch (type)
        {
          case NotificationType::ping:
            return Ptr(new Notification{extractor});
          case NotificationType::transaction:
            return Ptr(new TransactionNotification{extractor});
          case NotificationType::peer_connection_update:
            return Ptr(new PeerReachabilityNotification{extractor});
          case NotificationType::new_swagger:
            return Ptr(new NewSwaggerNotification{extractor});
          case NotificationType::user_status:
            return Ptr(new UserStatusNotification{extractor});
          case NotificationType::message:
            return Ptr(new MessageNotification{extractor});
          case NotificationType::connection_enabled:
            return Ptr(new ConnectionEnabledNotification{extractor});
            // XXX: Handle at upper levels (?)
          case NotificationType::suicide:
            SUICIDE();
          default:
            throw elle::Exception{elle::sprint("Unknown notification type", type)};
        }
        elle::unreachable();
      }

      //- Implementation --------------------------------------------------------
      struct Client::Impl:
        public elle::Printable
      {
        int _reconnected;
        std::shared_ptr<reactor::network::FingerprintedSocket> _socket;
        reactor::Barrier _connected;
        bool _synchronized;
        reactor::Barrier _pollable;
        std::string server;
        uint16_t port;
        boost::asio::streambuf request;
        boost::asio::streambuf response;
        boost::system::error_code last_error;
        std::string user_id;
        std::string user_device_id;
        std::string user_session_id;
        Client::ConnectCallback connect_callback;
        Client::ReconnectPokeFailedCallback reconnect_failed_callback;
        std::unique_ptr<reactor::Thread> _connect_callback_thread;
        std::exception_ptr _poll_exception;

        Impl(std::string const& server,
             uint16_t port,
             Client::ConnectCallback connect_callback,
             Client::ReconnectPokeFailedCallback reconnect_failed_callback):
          _reconnected{0},
          _socket(nullptr),
          _connected(),
          _synchronized(false),
          _pollable(),
          server(server),
          port(port),
          request{},
          response{},
          connect_callback{connect_callback},
          reconnect_failed_callback{reconnect_failed_callback},
          _poll_exception(),
          _poke_sent_signal(),
          _ping_period(default_ping_period),
          _ping_timeout(this->_ping_period * 2),
          _ping_signal(),
          _ping_thread(*reactor::Scheduler::scheduler(),
                       elle::sprintf("%s ping thread", *this),
                       [&] () { this->ping_thread(); }),
          _pong_signal(),
          _pong_thread(*reactor::Scheduler::scheduler(),
                       elle::sprintf("%s pong thread", *this),
                       [&] () { this->pong_thread(); }),
          _read_thread(*reactor::Scheduler::scheduler(),
                       elle::sprintf("%s read thread", *this),
                       [&] () { this->read_thread(); }),
          _poke_timeout(15_sec)
        {}

        ~Impl()
        {
          this->_ping_thread.terminate_now();
          this->_pong_thread.terminate_now();
          this->_read_thread.terminate_now();
          if (this->_connect_callback_thread)
            this->_connect_callback_thread->terminate_now();
        }

        std::vector<unsigned char> _test_fingerprint;
        void
        _set_test_fingerprint(std::vector<unsigned char> new_fingerprint)
        {
          _test_fingerprint = new_fingerprint;
        }

        reactor::Signal _poke_completed;
        reactor::Signal _poke_sent_signal;
        bool
        _poke(reactor::DurationOpt const& timeout = reactor::DurationOpt())
        {
          // Catch all exceptions in calling function
          ELLE_TRACE_SCOPE("%s: poke trophonius", *this);
          if (this->_socket)
          {
            ELLE_DEBUG("%s: close old socket", *this);
            this->_socket->close();
          }

          ELLE_DEBUG("%s: establishing connection", *this);
          auto endpoint = reactor::network::resolve_tcp(
            this->server,
            boost::lexical_cast<std::string>(this->port));
          if (this->_test_fingerprint.size() == 0)
          {
            this->_socket.reset(new reactor::network::FingerprintedSocket(
              endpoint,
              fingerprint,
              15_sec));
          }
          else
          {
            ELLE_LOG("%s: using passed fingerprint", *this);
            this->_socket.reset(new reactor::network::FingerprintedSocket(
              endpoint,
              this->_test_fingerprint,
              15_sec));
          }

          ELLE_DEBUG("%s: socket connected", *this);
          // XXX: restore this by exposing the API in reactor's TCP socket.
          // _impl->socket.set_option(boost::asio::socket_base::keep_alive{true});

          // Do not inherit file descriptor when forking.
          // XXX: What for ? Needed ?
          // ::fcntl(this->_socket.native_handle(), F_SETFD, 1);

          std::string const poke_msg("ouch");
          elle::json::Object poke_obj;
          poke_obj["poke"] = poke_msg;

          return elle::With<reactor::Scope>() << [&] (reactor::Scope& scope)
          {
            bool result = false;
            scope.run_background("poke reply", [&]
            {
              reactor::wait(this->_poke_sent_signal);
              ELLE_DEBUG("%s: get poke reply", *this);
              auto poke_reply_read = elle::json::read(*this->_socket);

              // XXX: Newer servers reply with JSON of the form {poke: reply}
              // while older ones reply with just the reply string. This check
              // handles both cases. Remove when no longer needed.
              if (poke_reply_read.type() == typeid(elle::json::Object))
              {
                auto poke_reply =
                  boost::any_cast<elle::json::Object>(poke_reply_read);
                if (poke_reply.find("poke") != poke_reply.end())
                {
                  std::string reply_msg =
                    boost::any_cast<std::string>(poke_reply["poke"]);
                  if (reply_msg == poke_msg)
                  {
                    ELLE_DEBUG("%s: got correct poke reply", *this);
                    result = true;
                  }
                  else
                  {
                    ELLE_WARN("%s: got incorrect poke reply: %s",
                              *this,
                              reply_msg);
                    result = false;
                  }
                }
                else
                {
                  ELLE_WARN("%s: poke reply not found in json", *this);
                  result = false;
                }
              }
              else if (poke_reply_read.type() == typeid(std::string))
              {
                auto poke_reply = boost::any_cast<std::string>(poke_reply_read);
                if (poke_reply == poke_msg)
                {
                  ELLE_DEBUG("%s: got correct poke reply", *this);
                  result = true;
                }
                else
                {
                  ELLE_WARN("%s: got incorrect poke reply: %s",
                              *this,
                              poke_reply);
                  result = false;
                }
              }
              else
              {
                result = false;
                ELLE_WARN("%s: unknown poke reply type", *this);
              }
            });
            scope.run_background("send poke", [&]
            {
              ELLE_DEBUG("%s: send poke message: %s", *this, poke_msg)
              elle::json::write(*this->_socket, poke_obj);
              this->_poke_sent_signal.signal();
            });
            auto deadline = timeout ? timeout.get() : this->_poke_timeout;
            scope.wait(deadline);
            if (result == false)
              this->_socket->close();
            _poke_completed.signal();
            return result;
          };
        }

        void
        _close_socket_on_exception()
        {
          if (this->_socket)
            this->_socket->close();
        }

        void
        _connect(bool user_action = false)
        {
          ELLE_DEBUG_SCOPE("%s: connect to %s:%s",
                           *this, this->server, this->port);

          this->_poll_exception = nullptr;
          this->_pollable.close();

          if (this->_connected.opened())
            return;

          try
          {
            if (this->user_id.empty() ||
                this->user_session_id.empty() ||
                this->user_device_id.empty())
            {
              throw elle::Exception("some of the attributes are empty");
            }

            json::Dictionary connection_request{
              std::map<std::string, std::string>{
                {"user_id", this->user_id},
                {"session_id", this->user_session_id},
                {"device_id", this->user_device_id},
            }};

            // May raise an exception.
            std::stringstream request;
            elle::serialize::OutputJSONArchive(request, connection_request);

            // Add '\n' to request.
            request << std::endl;

            ELLE_DEBUG("%s: identification", *this);
            this->_socket->write(elle::ConstWeakBuffer(request.str()));

            ELLE_DEBUG("%s: wait for confirmation", *this);
            auto notif = read();

            ELLE_ASSERT(notif != nullptr);
            ELLE_DEBUG("%s: read: %s", *this, *notif);

            if (notif->notification_type != NotificationType::connection_enabled)
            {
              throw elle::Exception("wrong first notification");
            }

            ELLE_ASSERT(dynamic_cast<ConnectionEnabledNotification*>(notif.get()));

            auto notification = std::unique_ptr<ConnectionEnabledNotification>(
              static_cast<ConnectionEnabledNotification*>(notif.release()));

            if (notification->response_code != 200)
            {
              throw elle::Exception(notification->response_details);
            }

            ELLE_LOG("%s: connected", *this);
            this->_connected.open();
          }
          catch (reactor::network::Exception const& e)
          {
            // In the case that we have a network exception, we need to
            // poke again to get a working socket.
            ELLE_WARN("%s: connection failed: %s",
                      *this, e.what());
            return;
          }
          catch (elle::Exception const& e)
          {
            // If an error occured, the connection to trophonius is broken and
            // requiere a new data (user_id, token, ...).
            this->_disconnect();

            ELLE_ERR("%s: failure to connect: %s", *this, e.what());
            this->_poll_exception = std::make_exception_ptr(e);
            // Wake up the poll thread to throw this exception.
            this->_pollable.open();
            // If the action has been initiated by the user, we can throw him
            // the exception.
            if (user_action)
              throw;
            return;
          }
        }

        void
        _disconnect()
        {
          ELLE_DEBUG_SCOPE("%s: disconnect", *this);
          this->_connected.close();
          this->_synchronized = false;
          this->_pollable.close();
          while (!this->_notifications.empty())
            this->_notifications.pop();
          if (this->_connect_callback_thread)
          {
            this->_connect_callback_thread->terminate_now();
            this->_connect_callback_thread.reset();
          }
          if (this->_socket)
          {
            this->_socket->close();
            this->_socket.reset();
          }
        }

        void
        _reconnect()
        {
          // If several threads try to reconnect, just wait for the first one to
          // be done.
          if (!this->_connected.opened())
          {
            ELLE_DEBUG_SCOPE("%s: already reconnected, wait", *this);
            reactor::wait(this->_connected);
            return;
          }

          ELLE_DEBUG_SCOPE("%s: reconnect", *this);

          this->_disconnect();
          this->connect_callback(false);
          while (true)
          {
            try
            {
              if (this->_poke())
              {
                this->_connect();
                if (this->_connected.opened())
                {
                  auto& sched = *reactor::Scheduler::scheduler();
                  this->_connect_callback_thread.reset(
                    new reactor::Thread(
                      sched,
                      "reconnection callback",
                      [&]
                      {
                        ELLE_LOG("%s: running reconnection callback", *this);
                        try
                        {
                          this->connect_callback(true);
                        }
                        catch (reactor::Terminate const&)
                        {
                          throw;
                        }
                        catch (...)
                        {
                          ELLE_ERR("%s: connection callback failed: %s",
                                   *this, elle::exception_string());
                          throw;
                        }
                        this->_synchronized = true;
                        if (!this->_notifications.empty())
                        {
                          ELLE_DEBUG("%s: resynchronized, "
                                     "resume handling notifications", *this);
                          this->_pollable.open();
                        }
                      }));
                  break;
                }
                else
                {
                  ELLE_WARN("%s: unable to authenticate with trophonius",
                            *this);
                }
              }
              else // timed out or we got the wrong response
              {
                ELLE_WARN("%s: wrong response or timeout on reconnection",
                          *this);
              }
            }
            catch (reactor::network::ResolutionError const& e)
            {
              ELLE_WARN("%s: no connection to network for reconnection: %s",
                        *this,
                        e.what());
            }
            catch (reactor::network::Exception const& e)
            {
              ELLE_WARN("%s: network error on reconnection: %s",
                        *this,
                        e.what());
            }
            catch (elle::json::ParserError const& e)
            {
              ELLE_WARN("%s: JSON parsing error during reconnect: %s",
                       *this,
                       e.what());
            }
            catch (elle::Exception const&)
            {
              ELLE_ERR("%s: unable to reconnect to trophonius: %s",
                        *this,
                        elle::exception_string());
            }
            this->reconnect_failed_callback();
            boost::random::mt19937 rng;
            rng.seed(static_cast<unsigned int>(std::time(0)));
            boost::random::uniform_int_distribution<> random_ten(0, 10);
            int rand_num = random_ten(rng);
            ELLE_LOG("%s: will try to reconnect in 20 + %s seconds",
                     *this, rand_num);
            reactor::Scheduler::scheduler()->current()->sleep(
              20_sec + (boost::posix_time::seconds(rand_num)));
          }
          if (this->_connected)
          {
            ELLE_LOG("%s: reconnected to trophonius", *this);
            this->_reconnected++;
          }
        }

        boost::posix_time::time_duration _ping_period;
        boost::posix_time::time_duration _ping_timeout;
        reactor::Signal _ping_signal;
        reactor::Thread _ping_thread;
        void
        ping_thread()
        {
          ELLE_TRACE_SCOPE("start ping thread");
          static std::string const ping_msg("{\"notification_type\": 208}\n");

          while (true)
          {
            // Wait for the ping signal, or ping_period at most.
            this->_ping_signal.wait(this->_ping_period);

            if (!this->_connected.opened())
            {
              ELLE_DEBUG("%s: ping thread: waiting to be connected", *this);
              reactor::wait(this->_connected);
              ELLE_DEBUG("%s: ping thread: connected", *this);
            }

            auto socket = this->_socket;
            try
            {
              ELLE_DEBUG_SCOPE("send ping to %s", socket->peer());
              socket->write(elle::ConstWeakBuffer(ping_msg));
            }
            catch (elle::Exception const&)
            {
              ELLE_WARN("couldn't send ping to tropho: %s",
                        elle::exception_string());
              this->_reconnect();
            }
          }
        }

        reactor::Signal _pong_signal;
        reactor::Thread _pong_thread;
        void
        pong_thread()
        {
          ELLE_TRACE_SCOPE("start pong thread");
          while (true)
          {
            if (!this->_connected.opened())
            {
              ELLE_DEBUG("%s: pong thread: waiting to be connected", *this);
              reactor::wait(this->_connected);
              ELLE_DEBUG("%s: pong thread: connected", *this);
            }

            if (!this->_pong_signal.wait(this->_ping_timeout))
            {
              ELLE_WARN("%s: didn't receive ping from tropho in %s",
                        *this, this->_ping_timeout);
              this->_reconnect();
            }
          }
        }

        std::unique_ptr<Notification>
        read()
        {
          ELLE_DEBUG_SCOPE("%s: reading message", *this);
          auto socket = this->_socket;
          auto buffer = socket->read_until("\n");
          ELLE_DEBUG("%s: got message: %f", *this, buffer);
          // XXX: Shitty JSON parser seeks.
          // elle::InputStreamBuffer<elle::Buffer> streambuffer(buffer);
          // std::istream input(&streambuffer);
          std::string buffer_str(
            reinterpret_cast<char const*>(buffer.contents()), buffer.size());
          std::stringstream input(buffer_str);
          ELLE_DUMP("%s: contents: %s", *this, buffer_str);
          return notification_from_dict(json::parse(input)->as_dictionary());
        }

        std::queue<std::unique_ptr<Notification>> _notifications;
        reactor::Thread _read_thread;
        void
        read_thread()
        {
          ELLE_TRACE_SCOPE("start read thread");
          while (true)
          {
            ELLE_DEBUG("%s: read thread: waiting to be connected", *this);
            reactor::wait(this->_connected);
            ELLE_DEBUG("%s: read thread: connected", *this);

            auto notif = std::unique_ptr<Notification>();

            try
            {
              notif = this->read();
            }
            catch (elle::Exception const& e)
            {
              ELLE_WARN("%s: error while reading: %s", *this, e.what());
              this->_reconnect();
              continue;
            }

            ELLE_ASSERT(notif != nullptr);

            if (notif->notification_type == NotificationType::ping)
            {
              ELLE_DEBUG("%s: ping received", *this);
              this->_pong_signal.signal();
              continue;
            }
            else
            {
              this->_notifications.push(std::move(notif));
              if (this->_synchronized)
                this->_pollable.open();
            }
          }
        }

        std::unique_ptr<Notification>
        poll()
        {
          this->_pollable.wait();

          if (this->_poll_exception)
            std::rethrow_exception(this->_poll_exception);

          ELLE_TRACE("%s new notification", *this);
          ELLE_ASSERT(!this->_notifications.empty());
          std::unique_ptr<Notification> res(
            this->_notifications.front().release());
          this->_notifications.pop();
          if (this->_notifications.empty())
            this->_pollable.close();
          return std::move(res);
        }

          /*----------.
          | Printable |
          `----------*/

        void
        print(std::ostream& stream) const override
        {
          stream << "trophonius::Client("
                 << this->user_id << ", "
                 << this->user_device_id << ")";
        }

        ELLE_ATTRIBUTE_RW(reactor::Duration, poke_timeout);
      };

      Client::Client(std::string const& server,
                     uint16_t port,
                     ConnectCallback connect_callback,
                     ReconnectPokeFailedCallback reconnect_failed_callback):
        _impl(new Impl(server, port,
                       connect_callback,
                       reconnect_failed_callback)),
        _ping_period(default_ping_period)
      {
        ELLE_ASSERT(connect_callback != nullptr);
      }

      Client::Client(std::string const& server,
                     uint16_t port,
                     ConnectCallback connect_callback,
                     ReconnectPokeFailedCallback reconnect_failed_callback,
                     std::vector<unsigned char> server_fingerprint):
        Client(server, port, connect_callback, reconnect_failed_callback)
      {
        this->_impl->_set_test_fingerprint(server_fingerprint);
      }

      reactor::Barrier const&
      Client::connected() const
      {
        return this->_impl->_connected;
      }

      reactor::Barrier&
      Client::connected()
      {
        return this->_impl->_connected;
      }

      void
      Client::ping_period(boost::posix_time::time_duration const& value)
      {
        this->_impl->_ping_period = value;
        this->_impl->_ping_timeout = value * 2;
        // Reping immediately.
        this->_impl->_ping_signal.signal();
      }

      boost::posix_time::time_duration const&
      Client::ping_period() const
      {
        return this->_impl->_ping_period;
      }

      reactor::Signal const&
      Client::poked() const
      {
        return this->_impl->_poke_completed;
      }

      reactor::Signal&
      Client::poked()
      {
        return this->_impl->_poke_completed;
      }

      Client::~Client()
      {}

      int
      Client::reconnected() const
      {
        return this->_impl->_reconnected;
      }

      bool
      Client::poke(reactor::DurationOpt const& timeout) const
      {
        try
        {
          return this->_impl->_poke(timeout);
        }
        catch (reactor::network::Exception const& e)
        {
          ELLE_ERR("%s: failure to poke trophonius: %s", *this, e.what());
        }
        catch (elle::json::ParserError const& e)
        {
          ELLE_ERR("%s: JSON parsing error: %s", *this, e.what());
        }
        catch (elle::Exception const& e)
        {
          ELLE_ERR("%s: error trying to poke trophonius: %s", *this, e.what());
          throw;
        }
        this->_impl->_close_socket_on_exception();
        return false;
      }

      void
      Client::poke_timeout(reactor::Duration const& timeout)
      {
        this->_impl->poke_timeout(timeout);
      }

      bool
      Client::connect(std::string const& _id,
                      std::string const& device_id,
                      std::string const& session_id)
      {
        ELLE_TRACE("%s: connecting with id %s, session %s, device_id %s",
                   *this, _id, session_id, device_id);

        this->_impl->user_id = _id;
        this->_impl->user_session_id = session_id;
        this->_impl->user_device_id = device_id;
        this->_impl->_connect(true);
        if (!this->_impl->_connected.opened())
        {
          ELLE_ERR("%s: unable to authenticate with trophonius", *this);
          return false;
        }
        this->_impl->_synchronized = true;
        return true;
      }

      void
      Client::disconnect()
      {
        this->_impl->_disconnect();
      }

      std::unique_ptr<Notification>
      Client::poll()
      {
        return this->_impl->poll();
      }

      std::ostream&
      operator <<(std::ostream& out,
                  NotificationType t)
      {
        switch (t)
        {
        <%! from infinit.oracles.notification import notifications %>
        %for name, value in notifications.items():
          case NotificationType::${name}:
            out << "${name}";
            break;
        %endfor
        }

        return out;
      }

      void
      Client::print(std::ostream& stream) const
      {
        stream << *this->_impl;
      }
    }
  }
}
