#include <csignal>
#include <fcntl.h>
#include <fstream>
#include <iostream>

#include <boost/random.hpp>

#include <elle/Buffer.hh>
#include <elle/assert.hh>
#include <elle/finally.hh>
#include <elle/format/json/Dictionary.hh>
#include <elle/format/json/Parser.hh>
#include <elle/format/json/Object.hh>
#include <elle/format/json/Array.hh>
#include <elle/json/exceptions.hh>
#include <elle/json/json.hh>
#include <elle/log.hh>
#include <elle/memory.hh>
#include <elle/print.hh>
#include <elle/serialize/JSONArchive.hh>
#include <elle/serialize/ListSerializer.hxx>
#include <elle/serialize/NamedValue.hh>
#include <elle/serialize/Serializer.hh>
#include <elle/serialize/extract.hh>
#include <elle/serialize/insert.hh>

#include <reactor/Channel.hh>
#include <reactor/Scope.hh>
#include <reactor/signal.hh>
#include <reactor/exception.hh>
#include <reactor/network/buffer.hh>
#include <reactor/network/exception.hh>
#include <reactor/network/fingerprinted-socket.hh>
#include <reactor/network/resolve.hh>
#include <reactor/scheduler.hh>
#include <reactor/thread.hh>

#include <infinit/oracles/trophonius/Client.hh>
#include <version.hh>

ELLE_LOG_COMPONENT("infinit.oracles.trophonius.Client");

#ifdef INFINIT_WINDOWS
# define SUICIDE() ::exit(0);
#else
# define SUICIDE() ::kill(::getpid(), SIGKILL)
#endif

/*-------------------------.
| Notification serializers |
`-------------------------*/
ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::Notification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::Notification, ar, value, version)
{
  (void)version;
  ar & named("notification_type", value.notification_type);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::ConnectionEnabledNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::ConnectionEnabledNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & named("response_code", value.response_code);
  ar & named("response_details", value.response_details);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::NewSwaggerNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::NewSwaggerNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & named("user_id", value.user_id);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::DeletedSwaggerNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::DeletedSwaggerNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & named("user_id", value.user_id);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::DeletedFavoriteNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::DeletedFavoriteNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & named("user_id", value.user_id);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::UserStatusNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::UserStatusNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & named("user_id", value.user_id);
  ar & named("status", value.user_status);
  ar & named("device_id", value.device_id);
  ar & named("device_status", value.device_status);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::LinkTransactionNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::LinkTransactionNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & base_class<infinit::oracles::LinkTransaction>(value);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::PeerTransactionNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::PeerTransactionNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & base_class<infinit::oracles::PeerTransaction>(value);
}

ELLE_SERIALIZE_NO_FORMAT(infinit::oracles::trophonius::MessageNotification);
ELLE_SERIALIZE_SIMPLE(infinit::oracles::trophonius::MessageNotification,
                      ar,
                      value,
                      version)
{
  (void)version;
  ar & base_class<infinit::oracles::trophonius::Notification>(value);
  ar & named("sender_id", value.sender_id);
  ar & named("message", value.message);
}

namespace infinit
{
  namespace oracles
  {
    namespace trophonius
    {
      boost::posix_time::time_duration const default_ping_period(
        boost::posix_time::seconds(30));

      /*--------------.
      | Notifications |
      `--------------*/

      void
      Notification::print(std::ostream& stream) const
      {
        stream << this->notification_type;
      }

      ConfigurationNotification::ConfigurationNotification(
        elle::json::Object json)
        : Notification(NotificationType::configuration)
        , configuration(json)
      {}

      void
      UserStatusNotification::print(std::ostream& stream) const
      {
        stream << "Notification user " << user_id
               << " went " << (device_status ? "on" : "off")
               << "line on device " << device_id;
      }

      void
      LinkTransactionNotification::print(std::ostream& stream) const
      {
        stream << this->notification_type << ": "
               << *static_cast<LinkTransaction const*>(this);
      }

      void
      PeerTransactionNotification::print(std::ostream& stream) const
      {
        stream << this->notification_type << ": "
               << *static_cast<PeerTransaction const*>(this);
      }

      PeerReachabilityNotification::PeerReachabilityNotification()
        : Notification(NotificationType::peer_connection_update)
      {}

      static
      std::unique_ptr<Notification>
      notification_from_dict(elle::json::Object const& json)
      {
        ELLE_TRACE("convert json %s to notification", json);
        auto type =
          NotificationType(
            boost::any_cast<int64_t>(json.at("notification_type")));
        switch (type)
        {
          case NotificationType::peer_connection_update:
          {
            auto res = elle::make_unique<PeerReachabilityNotification>();
            res->transaction_id =
              boost::any_cast<std::string>(json.at("transaction_id"));
            res->status =
              boost::any_cast<bool>(json.at("status"));
            if (res->status)
            {
              auto const& endpoints =
                boost::any_cast<elle::json::Object>(json.at("peer_endpoints"));
              for (auto const& elt_:
                     boost::any_cast<elle::json::Array>(endpoints.at("locals")))
              {
                auto const& elt = boost::any_cast<elle::json::Object>(elt_);
                auto ip = boost::any_cast<std::string>(elt.at("ip"));
                auto port = boost::any_cast<int64_t>(elt.at("port"));
                res->endpoints_local.push_back(
                  PeerReachabilityNotification::Endpoint(ip, port));
              }
              for (auto const& elt_:
                boost::any_cast<elle::json::Array>(endpoints.at("externals")))
              {
                auto const& elt = boost::any_cast<elle::json::Object>(elt_);
                auto ip = boost::any_cast<std::string>(elt.at("ip"));
                auto port = boost::any_cast<int64_t>(elt.at("port"));
                res->endpoints_public.push_back(
                  PeerReachabilityNotification::Endpoint(ip, port));
              }
            }
            return std::move(res);
          }
          case NotificationType::configuration:
          {
            return elle::make_unique<ConfigurationNotification>(
              std::move(json));
          }
          default:
            ; // Nothing.
        }
        using namespace elle::serialize;
        std::stringstream stream;
        elle::json::write(stream, json);
        auto repr = stream.str();
        auto extractor = from_string<InputJSONArchive>(repr);
        typedef std::unique_ptr<Notification> Ptr;
        switch (type)
        {
          case NotificationType::ping:
            return Ptr(new Notification{extractor});
          case NotificationType::link_transaction:
            return Ptr(new LinkTransactionNotification{extractor});
          case NotificationType::peer_transaction:
            return Ptr(new PeerTransactionNotification{extractor});
          case NotificationType::peer_connection_update:
            elle::unreachable();
          case NotificationType::new_swagger:
            return Ptr(new NewSwaggerNotification{extractor});
          case NotificationType::deleted_swagger:
            return Ptr(new DeletedSwaggerNotification{extractor});
          case NotificationType::deleted_favorite:
            return Ptr(new DeletedFavoriteNotification{extractor});
          case NotificationType::user_status:
            return Ptr(new UserStatusNotification{extractor});
          case NotificationType::message:
            return Ptr(new MessageNotification{extractor});
          case NotificationType::connection_enabled:
            return Ptr(new ConnectionEnabledNotification{extractor});
            // XXX: Handle at upper levels (?)
          case NotificationType::invalid_credentials:
            return Ptr(new InvalidCredentialsNotification());
          case NotificationType::suicide:
            SUICIDE();
          default:
            throw elle::Exception{elle::sprint("Unknown notification type", type)};
        }
        elle::unreachable();
      }

      //- Implementation --------------------------------------------------------
      struct Client::Impl:
        public elle::Printable
      {
        Client& _client;
        int _reconnected;
        std::shared_ptr<reactor::network::FingerprintedSocket> _socket;
        reactor::Barrier _connected;
        bool _synchronized;
        std::string server;
        uint16_t port;
        boost::asio::streambuf request;
        boost::asio::streambuf response;
        boost::system::error_code last_error;
        std::string user_id;
        std::string user_device_id;
        std::string user_session_id;
        Client::ConnectCallback connect_callback;
        Client::ReconnectPokeFailedCallback reconnect_failed_callback;
        std::unique_ptr<reactor::Thread> _connect_callback_thread;

        Impl(Client& client,
             Client::ConnectCallback connect_callback,
             Client::ReconnectPokeFailedCallback reconnect_failed_callback):
          _client(client),
          _reconnected(0),
          _socket(nullptr),
          _connected(),
          _synchronized(false),
          server(),
          port(),
          request{},
          response{},
          connect_callback{connect_callback},
          reconnect_failed_callback{reconnect_failed_callback},
          _ping_period(default_ping_period),
          _ping_timeout(this->_ping_period * 2),
          _ping_signal(),
          _ping_thread(),
          _pong_signal(),
          _pong_thread(),
          _read_thread(),
          _poke_timeout(15_sec)
        {}

        virtual
        ~Impl()
        {
          if (this->_ping_thread)
            this->_ping_thread->terminate_now();
          if (this->_pong_thread)
            this->_pong_thread->terminate_now();
          if (this->_read_thread)
            this->_read_thread->terminate_now();
          if (this->_connect_callback_thread)
            this->_connect_callback_thread->terminate_now();
        }

        void
        _setup_threads()
        {
          if (this->_ping_thread)
            this->_ping_thread->terminate_now();
          if (this->_pong_thread)
            this->_pong_thread->terminate_now();
          if (this->_read_thread)
            this->_read_thread->terminate_now();
          this->_ping_thread.reset(
            new reactor::Thread(
              elle::sprintf("%s ping thread", *this),
              [&] () { this->ping_thread(); }));
          this->_pong_thread.reset(
            new reactor::Thread(
              elle::sprintf("%s pong thread", *this),
              [&] () { this->pong_thread(); }));
          this->_read_thread.reset(
            new reactor::Thread(
              elle::sprintf("%s read thread", *this),
              [&] () { this->read_thread(); }));
        }

        std::vector<unsigned char> _test_fingerprint;
        void
        _set_test_fingerprint(std::vector<unsigned char> new_fingerprint)
        {
          _test_fingerprint = new_fingerprint;
        }

        bool
        _poke(reactor::DurationOpt const& timeout = reactor::DurationOpt())
        {
          ELLE_TRACE("%s: connect to %s:%s", *this, this->server, this->port)
          {
            if (this->_socket)
            {
              ELLE_DEBUG("%s: close old socket", *this);
              this->_socket->close();
            }
            auto endpoint = reactor::network::resolve_tcp(
              this->server,
              boost::lexical_cast<std::string>(this->port));
            try
            {
              this->_socket.reset(new reactor::network::FingerprintedSocket(
                                    endpoint,
                                    this->_test_fingerprint,
                                    15_sec));
            }
            catch (reactor::network::Exception const& e)
            {
              ELLE_ERR("%s: unable to open socket to trophonius: %s",
                       *this, elle::exception_string());
              return false;
            }
          }
          ELLE_TRACE_SCOPE("%s: poke", *this);
          std::string const poke_msg("ouch");
          elle::json::Object poke_obj;
          poke_obj["poke"] = poke_msg;
          ELLE_DEBUG("%s: send poke message: %s", *this, poke_msg)
            elle::json::write(*this->_socket, poke_obj);
          elle::json::Json poke_reply_read;
          ELLE_DEBUG("%s: get poke reply", *this)
          {
            // FIXME: create and use reactor::timeout.
            boost::asio::deadline_timer timer(
              reactor::scheduler().io_service(),
              timeout ? timeout.get() : this->_poke_timeout);
            auto thread = reactor::scheduler().current();
            timer.async_wait(
              [thread] (const boost::system::error_code& error)
              {
                if (error == boost::asio::error::operation_aborted)
                  return;
                thread->terminate();
              });
            try
            {
              poke_reply_read = elle::json::read(*this->_socket);
              timer.cancel();
            }
            catch (reactor::Terminate const&)
            {
              ELLE_WARN("%s: timeout on poke reply", *this);
              return false;
            }
          }
          try
          {
            auto const& poke_reply =
              boost::any_cast<elle::json::Object>(poke_reply_read);
            std::string reply_msg =
              boost::any_cast<std::string>(poke_reply.at("poke"));
            if (reply_msg == poke_msg)
            {
              ELLE_DEBUG("%s: got correct poke reply", *this);
              return true;
            }
            else
            {
              ELLE_WARN("%s: incorrect poke reply: %s", *this, reply_msg);
              return false;
            }
          }
          catch (boost::bad_any_cast const&)
          {
            ELLE_WARN("%s: invalid poke reply", *this);
            return false;
          }
        }

        void
        _close_socket_on_exception()
        {
          if (this->_socket)
            this->_socket->close();
        }

        void
        _connect(bool user_action = false)
        {
          if (this->_connect_callback_thread)
            this->_connect_callback_thread->terminate_now();
          if (!this->_poke())
          {
            if (this->_socket)
              this->_socket->close();
            throw Unreachable(this->server, this->port);
          }
          ELLE_DEBUG_SCOPE("%s: connect to %s:%s",
                           *this, this->server, this->port);
          this->_notifications.close();

          if (this->_connected.opened())
            return;

          try
          {
            if (this->user_id.empty() ||
                this->user_session_id.empty() ||
                this->user_device_id.empty())
            {
              throw elle::Exception("some of the attributes are empty");
            }

            elle::json::Object connection_request;
            {
              connection_request["user_id"] = this->user_id;
              connection_request["session_id"] = this->user_session_id;
              connection_request["device_id"] = this->user_device_id;
              {
                elle::json::Object version;
                version["major"] = INFINIT_VERSION_MAJOR;
                version["minor"] = INFINIT_VERSION_MINOR;
                version["subminor"] = INFINIT_VERSION_SUBMINOR;
                connection_request["version"] = version;

              }
            }

            ELLE_DEBUG("%s: identification", *this)
              elle::json::write(*this->_socket, connection_request);

            ELLE_DEBUG("%s: wait for confirmation", *this);
            auto notif = read();

            ELLE_ASSERT(notif != nullptr);
            ELLE_DEBUG("%s: read: %s", *this, *notif);

            if (notif->notification_type != NotificationType::connection_enabled)
            {
              throw elle::Exception("wrong first notification");
            }

            ELLE_ASSERT(dynamic_cast<ConnectionEnabledNotification*>(notif.get()));

            auto notification = std::unique_ptr<ConnectionEnabledNotification>(
              static_cast<ConnectionEnabledNotification*>(notif.release()));

            if (notification->response_code != 200)
            {
              throw elle::Exception(notification->response_details);
            }

            ELLE_LOG("%s: connected", *this);
            this->_connected.open();
          }
          catch (reactor::network::Exception const& e)
          {
            // In the case that we have a network exception, we need to
            // poke again to get a working socket.
            ELLE_WARN("%s: connection failed: %s",
                      *this, e.what());
            return;
          }
          catch (elle::Exception const& e)
          {
            // If an error occured, the connection to trophonius is broken and
            // requiere a new data (user_id, token, ...).
            this->_disconnect();

            ELLE_ERR("%s: failure to connect: %s", *this, e.what());
            // If the action has been initiated by the user, we can throw him
            // the exception.
            if (user_action)
              throw;
            return;
          }
        }

        void
        _disconnect()
        {
          ELLE_DEBUG_SCOPE("%s: disconnect", *this);
          this->_connected.close();
          this->_synchronized = false;
          this->_notifications.close();
          this->_notifications.clear();
          if (this->_connect_callback_thread)
          {
            this->_connect_callback_thread->terminate_now();
            this->_connect_callback_thread.reset();
          }
          if (this->_socket)
          {
            this->_socket->close();
            this->_socket.reset();
          }
        }

        void
        _reconnect()
        {
          // If several threads try to reconnect, just wait for the first one to
          // be done.
          ELLE_TRACE_SCOPE("%s: thread %s trying to reconnect",
                           *this, *reactor::Scheduler::scheduler()->current());
          if (!this->_connected.opened())
          {
            ELLE_DEBUG_SCOPE("%s: already reconnecting, wait", *this);
            reactor::wait(this->_connected);
            return;
          }
          ELLE_DEBUG_SCOPE("%s: reconnect", *this);
          this->_disconnect();
          this->connect_callback(false);
          while (true)
          {
            try
            {
              this->_connect();
              if (this->_connected.opened())
              {
                auto& sched = *reactor::Scheduler::scheduler();
                this->_connect_callback_thread.reset(
                  new reactor::Thread(
                    sched,
                    "reconnection callback",
                    [&]
                    {
                      ELLE_LOG("%s: running reconnection callback", *this);
                      try
                      {
                        this->connect_callback(true);
                      }
                      catch (reactor::Terminate const&)
                      {
                        throw;
                      }
                      catch (...)
                      {
                        ELLE_ERR("%s: connection callback failed: %s",
                                 *this, elle::exception_string());
                        throw;
                      }
                      this->_synchronized = true;
                      this->_notifications.open();
                    }));
                break;
              }
              else
              {
                ELLE_WARN("%s: unable to authenticate with trophonius",
                          *this);
              }
            }
            catch (Unreachable const&)
            {
              ELLE_WARN("%s: wrong response or timeout on reconnection",
                        *this);
            }
            catch (reactor::network::ResolutionError const& e)
            {
              ELLE_WARN("%s: no connection to network for reconnection: %s",
                        *this,
                        e.what());
            }
            catch (reactor::network::Exception const& e)
            {
              ELLE_WARN("%s: network error on reconnection: %s",
                        *this,
                        e.what());
            }
            catch (elle::json::ParserError const& e)
            {
              ELLE_WARN("%s: JSON parsing error during reconnect: %s",
                       *this,
                       e.what());
            }
            catch (elle::Exception const&)
            {
              ELLE_ERR("%s: unable to reconnect to trophonius: %s",
                        *this,
                        elle::exception_string());
            }
            this->reconnect_failed_callback();
            boost::random::mt19937 rng;
            rng.seed(static_cast<unsigned int>(std::time(0)));
            boost::random::uniform_int_distribution<> random(100, 150);
            auto const delay =
              this->_client.reconnection_cooldown() * random(rng) / 100;
            ELLE_LOG("%s: will retry reconnection in %s", *this, delay);
            reactor::sleep(delay);
          }
          if (this->_connected)
          {
            ELLE_LOG("%s: reconnected to trophonius", *this);
            this->_reconnected++;
          }
        }

        boost::posix_time::time_duration _ping_period;
        boost::posix_time::time_duration _ping_timeout;
        reactor::Signal _ping_signal;
        std::unique_ptr<reactor::Thread> _ping_thread;
        void
        ping_thread()
        {
          ELLE_TRACE_SCOPE("start ping thread");
          static std::string const ping_msg("{\"notification_type\": 208}\n");

          while (true)
          {
            // Wait for the ping signal, or ping_period at most.
            this->_ping_signal.wait(this->_ping_period);

            if (!this->_connected.opened())
            {
              ELLE_DUMP("%s: ping thread: waiting to be connected", *this);
              reactor::wait(this->_connected);
              ELLE_DUMP("%s: ping thread: connected", *this);
            }

            auto socket = this->_socket;
            try
            {
              ELLE_DUMP_SCOPE("send ping to %s", socket->peer());
              socket->write(elle::ConstWeakBuffer(ping_msg));
            }
            catch (elle::Exception const&)
            {
              ELLE_WARN("couldn't send ping to tropho: %s",
                        elle::exception_string());
              this->_reconnect();
            }
          }
        }

        reactor::Signal _pong_signal;
        std::unique_ptr<reactor::Thread> _pong_thread;
        void
        pong_thread()
        {
          ELLE_TRACE_SCOPE("start pong thread");
          while (true)
          {
            if (!this->_connected.opened())
            {
              ELLE_DUMP("%s: pong thread: waiting to be connected", *this);
              reactor::wait(this->_connected);
              ELLE_DUMP("%s: pong thread: connected", *this);
            }

            if (!this->_pong_signal.wait(this->_ping_timeout))
            {
              ELLE_WARN("%s: didn't receive ping from tropho in %s",
                        *this, this->_ping_timeout);
              this->_reconnect();
            }
          }
        }

        std::unique_ptr<Notification>
        read()
        {
          ELLE_DUMP_SCOPE("%s: read message", *this);
          auto socket = this->_socket;
          auto buffer = socket->read_until("\n");
          ELLE_TRACE("%s: got message: %f", *this, buffer);
          elle::InputStreamBuffer<elle::Buffer> streambuffer(buffer);
          std::istream input(&streambuffer);
          auto json = boost::any_cast<elle::json::Object>(
            elle::json::read(input));
          return notification_from_dict(json);
        }

        std::unique_ptr<reactor::Thread> _read_thread;
        void
        read_thread()
        {
          ELLE_TRACE_SCOPE("start read thread");
          while (true)
          {
            ELLE_DUMP("%s: read thread: waiting to be connected", *this);
            reactor::wait(this->_connected);
            ELLE_DUMP("%s: read thread: connected", *this);
            auto notif = std::unique_ptr<Notification>();
            try
            {
              notif = this->read();
            }
            catch (elle::Exception const& e)
            {
              ELLE_WARN("%s: error while reading: %s", *this, e.what());
              this->_reconnect();
              continue;
            }
            ELLE_ASSERT(notif != nullptr);
            if (notif->notification_type == NotificationType::ping)
            {
              ELLE_DUMP("%s: ping received", *this);
              this->_pong_signal.signal();
              continue;
            }
            else
            {
              ELLE_DUMP("%s: enqueue notification", *this);
              this->_notifications.put(std::move(notif));
              if (this->_synchronized)
                this->_notifications.open();
            }
          }
        }

        std::unique_ptr<Notification>
        poll()
        {
          // Check that there actually is a notification availble: we may be
          // awaken because a notification was received, but a ping timeout
          // disconnects and empties the notifications list before we get a
          // chance to execute.
          auto res = this->_notifications.get();
          ELLE_TRACE("%s: handle new notification", *this);
          return std::move(res);
        }

        /*----------.
        | Printable |
        `----------*/

        void
        print(std::ostream& stream) const override
        {
          stream << "trophonius::Client("
                 << this->user_id << ", "
                 << this->user_device_id << ")";
        }

        typedef reactor::Channel<std::unique_ptr<Notification>> Notifications;
        ELLE_ATTRIBUTE(Notifications, notifications);
        ELLE_ATTRIBUTE_RW(reactor::Duration, poke_timeout);
      };

      Client::Client(ConnectCallback connect_callback,
                     ReconnectPokeFailedCallback reconnect_failed_callback,
                     std::vector<unsigned char> server_fingerprint,
                     boost::posix_time::time_duration reconnection_cooldown)
        : _impl(new Impl(*this, connect_callback, reconnect_failed_callback))
        , _ping_period(default_ping_period)
        , _reconnection_cooldown(reconnection_cooldown)
      {
        ELLE_ASSERT(connect_callback != nullptr);
        this->_impl->_set_test_fingerprint(server_fingerprint);
      }

      Client::Client(std::string host,
                     int port,
                     ConnectCallback connect_callback,
                     ReconnectPokeFailedCallback reconnect_failed_callback,
                     std::vector<unsigned char> server_fingerprint,
                     boost::posix_time::time_duration reconnection_cooldown):
        Client(std::move(connect_callback),
               std::move(reconnect_failed_callback),
               std::move(server_fingerprint),
               reconnection_cooldown)
      {
        this->server(std::move(host), port);
      }

      reactor::Barrier const&
      Client::connected() const
      {
        return this->_impl->_connected;
      }

      reactor::Barrier&
      Client::connected()
      {
        return this->_impl->_connected;
      }

      void
      Client::ping_period(boost::posix_time::time_duration const& value)
      {
        this->_impl->_ping_period = value;
        this->_impl->_ping_timeout = value * 2;
        // Reping immediately.
        this->_impl->_ping_signal.signal();
      }

      boost::posix_time::time_duration const&
      Client::ping_period() const
      {
        return this->_impl->_ping_period;
      }

      Client::~Client()
      {
        delete _impl;
        _impl = nullptr;
      }

      int
      Client::reconnected() const
      {
        return this->_impl->_reconnected;
      }

      bool
      Client::poke(reactor::DurationOpt const& timeout) const
      {
        ELLE_TRACE_SCOPE("%s: poke", *this);
        try
        {
          return this->_impl->_poke(timeout);
        }
        catch (reactor::network::Exception const& e)
        {
          ELLE_ERR("%s: failure to poke trophonius: %s", *this, e.what());
        }
        catch (elle::json::ParserError const& e)
        {
          ELLE_ERR("%s: JSON parsing error: %s", *this, e.what());
        }
        catch (elle::Exception const& e)
        {
          ELLE_ERR("%s: error trying to poke trophonius: %s", *this, e.what());
          throw;
        }
        this->_impl->_close_socket_on_exception();
        return false;
      }

      void
      Client::poke_timeout(reactor::Duration const& timeout)
      {
        this->_impl->poke_timeout(timeout);
      }

      bool
      Client::connect(std::string const& _id,
                      std::string const& device_id,
                      std::string const& session_id)
      {
        ELLE_TRACE_SCOPE("%s: connecting with id %s, session %s, device_id %s",
                         *this, _id, session_id, device_id);
        this->_impl->user_id = _id;
        this->_impl->user_session_id = session_id;
        this->_impl->user_device_id = device_id;
        this->_impl->_setup_threads();
        this->_impl->_connect(true);
        if (!this->_impl->_connected.opened())
        {
          ELLE_ERR("%s: unable to authenticate with trophonius", *this);
          return false;
        }
        this->_impl->_synchronized = true;
        return true;
      }

      void
      Client::server(std::string const& host, int port)
      {
        ELLE_TRACE_SCOPE("%s: set server (%s:%s)", *this, host, port);
        this->_impl->server = host;
        this->_impl->port = port;
      }

      void
      Client::disconnect()
      {
        this->_impl->_disconnect();
      }

      std::unique_ptr<Notification>
      Client::poll()
      {
        return this->_impl->poll();
      }

      std::ostream&
      operator <<(std::ostream& out,
                  NotificationType t)
      {
        switch (t)
        {
        <%! from infinit.oracles.notification import notifications %>
        %for name, value in notifications.items():
          case NotificationType::${name}:
            out << "${name}";
            break;
        %endfor
        }

        return out;
      }

      void
      Client::print(std::ostream& stream) const
      {
        stream << *this->_impl;
      }

      Unreachable::Unreachable(std::string host, int port)
        : elle::Error(
          elle::sprintf("unable to reach trophonius on %s:%s", host, port))
      {}
    }
  }
}
