#ifndef INFINIT_ORACLES_TROPHONIUS_CLIENT_HH
# define INFINIT_ORACLES_TROPHONIUS_CLIENT_HH

# include <infinit/oracles/Transaction.hh>

# include <boost/date_time/posix_time/posix_time_types.hpp>

# include <elle/format/json.hh>

# include <reactor/Barrier.hh>
# include <reactor/signal.hh>

# include <functional>
# include <queue>

namespace infinit
{
  namespace oracles
  {
    namespace trophonius
    {
      enum class NotificationType: int
      {
        <%! from infinit.oracles.notification import notifications %>
        %for name, value in notifications.items():
          ${name} = ${value},
        %endfor
      };

      /// Base class for all notifications.
      struct Notification:
        public elle::Printable
      {
        NotificationType notification_type;

        ELLE_SERIALIZE_CONSTRUCT(Notification)
        {}

        Notification(NotificationType const type):
          notification_type{type}
        {}

        virtual ~Notification() = default;

        virtual
        void
        print(std::ostream& stream) const override;
      };

      namespace json = elle::format::json;

      struct ConnectionEnabledNotification:
        public Notification
      {
        uint32_t response_code;
        std::string response_details;

        ELLE_SERIALIZE_CONSTRUCT(ConnectionEnabledNotification,
                                 Notification)
        {}
      };

      struct NewSwaggerNotification:
        public Notification
      {
        std::string user_id;

        ELLE_SERIALIZE_CONSTRUCT(NewSwaggerNotification,
                                 Notification)
        {}
      };

      struct UserStatusNotification:
        public Notification
      {
        std::string user_id;
        bool status;
        std::string device_id;
        bool device_status;

        ELLE_SERIALIZE_CONSTRUCT(UserStatusNotification,
                                 Notification)
        {}

        UserStatusNotification():
          Notification{NotificationType::user_status}
        {}

        void
        print(std::ostream& stream) const override;
      };

      struct TransactionNotification:
        public Notification,
        public Transaction
      {
        ELLE_SERIALIZE_CONSTRUCT(TransactionNotification,
                                 Notification,
                                 Transaction)
        {}

        virtual
        void
        print(std::ostream& stream) const override;
      };

      struct PeerInterfacesUpdated:
        public Notification
      {
        std::string transaction_id;
        bool status;
        std::vector<std::string> devices;

        ELLE_SERIALIZE_CONSTRUCT(PeerInterfacesUpdated,
                                 Notification)
        {}
      };

      struct MessageNotification:
        public Notification
      {
        std::string sender_id;
        std::string message;

        ELLE_SERIALIZE_CONSTRUCT(MessageNotification,
                                 Notification)
        {}
      };

      /// Build a notification with the 'good' type from a dictionnary.
      /// The notification type is determined by the "notification_type" field
      /// presents in the dictionary.
      std::unique_ptr<Notification>
      notification_from_dict(json::Dictionary const& dict);

      class Client:
        public elle::Printable
      {
      public:
        typedef std::function<void (bool)> ConnectCallback;
        typedef std::function<void (void)> ReconnectPokeFailedCallback;
      private:
        struct Impl;
        std::unique_ptr<Impl> _impl;

      public:
        Client(std::string const& server,
               uint16_t port,
               ConnectCallback connect_callback,
               ReconnectPokeFailedCallback reconnect_failed_callback);

        Client(std::string const& server,
               uint16_t port,
               ConnectCallback connect_callback,
               ReconnectPokeFailedCallback reconnect_failed_callback,
               std::vector<unsigned char> server_fingerprint);

        ~Client();

      public:
        bool
        poke(reactor::DurationOpt const& timeout =
             reactor::DurationOpt()) const;
        void
        poke_timeout(reactor::Duration const& timeout);

        bool
        connect(std::string const& _id,
                std::string const& session_id,
                std::string const& device_id);

        void
        disconnect();

        //GenericNotification
        std::unique_ptr<Notification>
        poll();

        int
        reconnected() const;
        ELLE_ATTRIBUTE_rx(reactor::Barrier, connected);
        ELLE_ATTRIBUTE_rw(boost::posix_time::time_duration, ping_period);
        ELLE_ATTRIBUTE_rx(reactor::Signal, poked);

      /*----------.
      | Printable |
      `----------*/
      public:
        virtual
        void
        print(std::ostream& stream) const override;
      };

      std::ostream&
      operator <<(std::ostream& out,
                  NotificationType t);
    }
  }
}

#endif
