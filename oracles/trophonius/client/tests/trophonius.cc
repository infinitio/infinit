#include <elle/cast.hh>
#include <elle/json/json.hh>
#include <elle/log.hh>
#include <elle/test.hh>
#include <elle/utility/Move.hh>

#include <boost/filesystem.hpp>

#include <infinit/oracles/trophonius/Client.hh>

#include <reactor/network/buffer.hh>
#include <reactor/network/exception.hh>
#include <reactor/network/ssl-server.hh>
#include <reactor/scheduler.hh>
#include <reactor/signal.hh>
#include <reactor/Scope.hh>
#include <reactor/thread.hh>

ELLE_LOG_COMPONENT("infinit.oracles.trophonius.client.test")

extern const std::vector<unsigned char> fingerprint;
extern const std::vector<char> server_certificate;
extern const std::vector<char> server_key;
extern const std::vector<char> server_dh1024;

static
void
exhaust(reactor::network::Socket& socket)
{
  try
  {
    while (true)
      socket.read_some(BUFSIZ);
  }
  catch (reactor::network::ConnectionClosed const&)
  {}
}

enum class NotificationCode
{
  NONE_NOTIFICATION = 0,
  USER_STATUS_NOTIFICATION = 8,
  TRANSACTION_NOTIFICATION = 7,
  NEW_SWAGGER_NOTIFICATION = 9,
  PEER_CONNECTION_UPDATE_NOTIFICATION = 11,
  INVALID_CREDENTAILS_NOTIFICATION = 12,
  NETWORK_UPDATE_NOTIFICATION = 128,
  MESSAGE_NOTIFICATION = 217,
  PING_NOTIFICATION = 208,
  CONNECTION_ENABLED_NOTIFICATION = -666,
  SUICIDE_NOTIFICATION = 666,
};

class Trophonius
{
public:
    Trophonius():
      Trophonius(true)
    {}

  Trophonius(bool start):
    _certificate(nullptr),
    _server(nullptr),
    _port(),
    _accepter()
  {
    if (!start)
    {
      this->_port = 42;
      return;
    }

    this->_certificate.reset(new reactor::network::SSLCertificate(
      server_certificate,
      server_key,
      server_dh1024));
    this->_server.reset(new reactor::network::SSLServer(
      std::move(this->_certificate)));
    this->_server->listen(0);
    this->_port = this->_server->port();
    ELLE_LOG("%s: listen on port %s", *this, this->_port);
    this->_accepter.reset(new reactor::Thread(
      *reactor::Scheduler::scheduler(),
      "accepter",
      std::bind(&Trophonius::_handle_connection, std::ref(*this))));
  }

  virtual
  ~Trophonius()
  {
    ELLE_LOG("%s: entering destructor", *this);
    if (this->_accepter)
      this->_accepter->terminate_now();
    ELLE_LOG("%s: finalize", *this);
  }

  ELLE_ATTRIBUTE(std::unique_ptr<reactor::network::SSLCertificate>,
                 certificate);
  ELLE_ATTRIBUTE(std::unique_ptr<reactor::network::SSLServer>, server);
  ELLE_ATTRIBUTE_R(int, port);
  ELLE_ATTRIBUTE_R(std::unique_ptr<reactor::Thread>, accepter);

protected:
  reactor::network::SSLServer&
  server()
  {
    return *this->_server;
  }

  virtual
  void
  _handle_connection()
  {
    try
    {
      elle::With<reactor::Scope>() << [this] (reactor::Scope& scope)
      {
        while (true)
        {
          auto socket = elle::utility::move_on_copy(this->_server->accept());
          ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
          auto name = elle::sprintf("serve %s", **socket);
          scope.run_background(
            name,
            [&, socket]
            {
              auto poke_read = elle::json::read(**socket);
              auto poke = boost::any_cast<elle::json::Object>(poke_read);
              elle::json::write(**socket, poke);
              ELLE_LOG("%s replied to poke", *this);
              this->_serve(**socket);
            });
        }
      };
    }
    catch (reactor::network::ConnectionClosed const&)
    {
      ELLE_LOG("%s: ignore connection closed on killing accepter", *this);
    }
  }

  void
  _send_notification(reactor::network::Socket& socket,
                     std::string const& message)
  {
    elle::json::Object notification;
    notification["notification_type"] =
      int(NotificationCode::MESSAGE_NOTIFICATION);
    notification["sender_id"] = std::string("id");
    notification["message"] = message;
    ELLE_LOG("%s: write: %s",
             *this,
             elle::json::pretty_print(notification));
    elle::json::write(socket, notification);
  }

  virtual
  void
  _serve(reactor::network::Socket& socket) = 0;

  virtual
  void
  _login_response(reactor::network::Socket& socket)
  {
    this->_login_response(socket, true);
  }

  void
  _login_response(reactor::network::Socket& socket, bool success)
  {
    elle::json::Object login_response;
    login_response["notification_type"] =
      int(NotificationCode::CONNECTION_ENABLED_NOTIFICATION);
    login_response["response_code"] = success ? int(200) : int(500);
    login_response["response_details"] = std::string("nothing");
    ELLE_LOG("%s: login response: %s",
             *this,
             elle::json::pretty_print(login_response));
    elle::json::write(socket, login_response);
  }
};

/*-----.
| Poke |
`-----*/

// Check that the client's poke reports connectivity correctly.

class PokeTrophonius:
  public Trophonius
{
public:
  PokeTrophonius(int round):
    PokeTrophonius(true, round)
  {
    ELLE_DEBUG("making trophonius for round %s", round);
  }

  PokeTrophonius(bool start, int round):
    Trophonius(start),
    _round(round)
  {}

  ~PokeTrophonius()
  {
    ELLE_DEBUG("~PokeTrophonius:  Waiting for accepter");
    //reactor::wait(*this->accepter());
    ELLE_DEBUG("~PokeTrophonius: done");
  }

  ELLE_ATTRIBUTE_R(int, round);

protected:
  virtual
  void
  _handle_connection()
  {
    ELLE_DEBUG("server in round: %s", this->_round);
    if (this->round() == 0) // Normal case.
    {
      auto socket = this->server().accept();
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
      auto poke = boost::any_cast<elle::json::Object>(poke_read);
      elle::json::write(*socket, poke);
      ELLE_LOG("%s replied to poke", *this);
    }
    else if (this->round() == 1) // No poke reply.
    {
      std::unique_ptr<reactor::network::Socket> socket(
        this->server().accept());
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
    }
    else if (this->round() == 2) // Unable to resolve.
    {
      // Do nothing.
    }
    else if (this->round() == 3) // Wrong JSON reply.
    {
      std::unique_ptr<reactor::network::Socket> socket(
        this->server().accept());
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
      elle::json::Object rubbish;
      rubbish["poke"] = std::string("rubbish");
      elle::json::write(*socket, rubbish);
      ELLE_LOG("%s replied incorrect JSON to poke", *this);
    }
    else if (this->round() == 4) // HTML reply.
    {
      std::unique_ptr<reactor::network::Socket> socket(
        this->server().accept());
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
      std::string rubbish(
        "<h1>Some random HTML</h1>\n<p>shouldn't break anything</p>");
      socket->write(rubbish);
      ELLE_LOG("%s replied HTML to poke", *this);
    }
    else if (this->round() == 5) // Connection refused.
    {
      // Do nothing.
    }
    _handle_connection();
  }

  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    // Do nothing.
  }

};

ELLE_TEST_SCHEDULED(poke_success)
{
  PokeTrophonius tropho(0);
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    tropho.port(),
    [] (bool) {},
    [] (void) {},
    fingerprint);
  try
  {
    client.connect("", "", "");
  }
  catch (infinit::oracles::trophonius::Unreachable const&)
  {
    BOOST_ERROR("trophonius was unreachable");
  }
  catch (infinit::oracles::trophonius::ConnectionError const&)
  {}
  BOOST_CHECK(!client.connected().opened());
}

ELLE_TEST_SCHEDULED(poke_no_reply)
{
  PokeTrophonius tropho(1);
  reactor::Barrier b;
  bool success = false;
  int connectCount = 0;
  int reconnectCount = 0;
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    tropho.port(),
    [&] (bool v) {
          connectCount++;
          success = v;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // connect callback
        [&] (void) {
          reconnectCount++;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // reconnection failed callback
    fingerprint);
  BOOST_CHECK_NO_THROW(client.connect("", "", ""));
  b.wait();b.close();b.wait();
  BOOST_CHECK_EQUAL(reconnectCount, 1);
  BOOST_CHECK_EQUAL(connectCount, 1);
  BOOST_CHECK(!client.connected());
  BOOST_CHECK_EQUAL(success, false);
}

ELLE_TEST_SCHEDULED(poke_resolution_failure)
{
  reactor::Barrier b;
  bool success = false;
  int connectCount = 0;
  int reconnectCount = 0;
  infinit::oracles::trophonius::Client client(
        "does.not.exist",
        8000,
        [&] (bool v) {
          connectCount++;
          success = v;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // connect callback
        [&] (void) {
          reconnectCount++;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // reconnection failed callback
        fingerprint);
  BOOST_CHECK_NO_THROW(client.connect("", "", ""));
  b.wait();b.close();b.wait();
  BOOST_CHECK_EQUAL(reconnectCount, 1);
  BOOST_CHECK_EQUAL(connectCount, 1);
  BOOST_CHECK(!client.connected());
  BOOST_CHECK_EQUAL(success, false);
}

ELLE_TEST_SCHEDULED(poke_json)
{
  PokeTrophonius tropho(3);
  reactor::Barrier b;
  bool success = false;
  int connectCount = 0;
  int reconnectCount = 0;
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    tropho.port(),
        [&] (bool v) {
          connectCount++;
          success = v;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // connect callback
        [&] (void) {
          reconnectCount++;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // reconnection failed callback
        fingerprint, 1_sec);
  BOOST_CHECK_NO_THROW(client.connect("", "", ""));
  b.wait();b.close();b.wait();
  BOOST_CHECK_EQUAL(reconnectCount, 1);
  BOOST_CHECK_EQUAL(connectCount, 1);
  BOOST_CHECK(!client.connected());
  BOOST_CHECK_EQUAL(success, false);
  b.close(); b.wait(); b.close(); b.wait();
  BOOST_CHECK_EQUAL(reconnectCount, 2);
  BOOST_CHECK_EQUAL(connectCount, 2);
  BOOST_CHECK(!client.connected());
  BOOST_CHECK_EQUAL(success, false);

}

ELLE_TEST_SCHEDULED(poke_html)
{
  reactor::Barrier b;
  bool success = false;
  int connectCount = 0;
  int reconnectCount = 0;
  PokeTrophonius tropho(4);
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    tropho.port(),
    [&] (bool v) {
          connectCount++;
          success = v;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // connect callback
    [&] (void) {
          reconnectCount++;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // reconnection failed callback
        fingerprint);
  BOOST_CHECK_NO_THROW(client.connect("", "", ""));
  b.wait();b.close();b.wait();
  BOOST_CHECK_EQUAL(reconnectCount, 1);
  BOOST_CHECK_EQUAL(connectCount, 1);
  BOOST_CHECK(!client.connected());
  BOOST_CHECK_EQUAL(success, false);
}

ELLE_TEST_SCHEDULED(poke_connection_refused)
{
  reactor::Barrier b;
  bool success = false;
  int connectCount = 0;
  int reconnectCount = 0;
  int port;
  {
    PokeTrophonius tropho(5);
    port = tropho.port();
  }
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    port,
    [&] (bool v) {
          connectCount++;
          success = v;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // connect callback
    [&] (void) {
          reconnectCount++;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // reconnection failed callback
        fingerprint);
  BOOST_CHECK_NO_THROW(client.connect("", "", ""));
  b.wait();b.close();b.wait();
  BOOST_CHECK_EQUAL(reconnectCount, 1);
  BOOST_CHECK_EQUAL(connectCount, 1);
  BOOST_CHECK(!client.connected());
  BOOST_CHECK_EQUAL(success, false);

}

/*-------------.
| Notification |
`-------------*/

// Check that a client can receive a simple notification message and will
// reconnect when the socket is closed.

class NotificationTrophonius:
  public Trophonius
{
protected:
  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    ELLE_LOG("serve notification test");
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_LOG("%s: got connect message: %s",
             *this,
             elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
    this->_send_notification(socket, "hello");
  }
};

ELLE_TEST_SCHEDULED(notification)
{
  static int const reconnections = 5;
  NotificationTrophonius tropho;
  {
    using namespace infinit::oracles::trophonius;
    Client client(
      "127.0.0.1",
      tropho.port(),
      [] (bool) {}, // connect callback
      [] (void) {}, // reconnection failed callback
      fingerprint);
    client.connect("0", "0", "0");
    reactor::wait(client.connected());
    BOOST_CHECK(client.connected());
    for (int i = 0; i < reconnections; ++i)
    {
      ELLE_LOG("poll notifications");
      std::unique_ptr<Notification> notification = client.poll();
      ELLE_DEBUG("back from poll");
      BOOST_CHECK_EQUAL(client.reconnected(), i);
      BOOST_CHECK(notification);
      ELLE_LOG("got notification type: %s", notification->notification_type);
      BOOST_CHECK_EQUAL(notification->notification_type,
                        NotificationType::message);
    }
  }
}


/*-----.
| Ping |
`-----*/

// Check the client pings every period.

class PingTrophonius:
  public Trophonius
{
public:
  PingTrophonius(boost::posix_time::time_duration const& period):
    Trophonius(),
    _ping_received(0),
    _period(period)
  {}

ELLE_ATTRIBUTE_R(int, ping_received);

protected:
  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_LOG("%s: got connect message: %s",
             *this,
             elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
    ELLE_LOG("start serving ping");
    elle::With<reactor::Scope>() << [&] (reactor::Scope& scope)
    {
      scope.run_background("pinger", [&]
      {
        while (true)
        {
          elle::json::Object msg;
          msg["notification_type"] = int(NotificationCode::PING_NOTIFICATION);
          ELLE_LOG("send ping");
          elle::json::write(socket, msg);
          reactor::sleep(this->_period);
        }
      });
      scope.run_background("ping checker", [&]
      {
        auto previous = boost::posix_time::microsec_clock::local_time();
        boost::posix_time::time_duration periods;
        while (true)
        {
          auto data_read = elle::json::read(socket);
          auto now = boost::posix_time::microsec_clock::local_time();
          auto ping = boost::any_cast<elle::json::Object>(data_read);
          auto diff = now - previous;
          ELLE_LOG("got ping after %s: %s",
                   diff,
                   elle::json::pretty_print(ping));
          periods += diff;
          previous = now;
          ++this->_ping_received;
        }
        // Check the mean ping time is 20% around the expected period.
        BOOST_CHECK_LT(periods / this->_ping_received, this->_period * 12 / 10);
      });
      scope.wait();
    };
  }

private:
  ELLE_ATTRIBUTE(boost::posix_time::time_duration, period);
};

ELLE_TEST_SCHEDULED(ping)
{
  boost::posix_time::time_duration const period = 500_ms;
  boost::posix_time::time_duration const run_time = 10_sec;
  int periods = run_time.total_milliseconds() / period.total_milliseconds();
  PingTrophonius tropho(period);
  using namespace infinit::oracles::trophonius;
  Client client(
    "127.0.0.1",
    tropho.port(),
    [] (bool) {}, // connect callback
    [] (void) {}, // reconnection failed callback
    fingerprint);
  client.ping_period(period);
  client.connect("0", "0", "0");
  reactor::wait(client.connected());
  BOOST_CHECK(client.connected());
  reactor::sleep(run_time);
  BOOST_CHECK_EQUAL(client.reconnected(), 0);
  BOOST_CHECK_LE(std::abs(tropho.ping_received() - periods), 1);
}

/*--------.
| No ping |
`--------*/

// Check a client not receiving pings reconnects every 2 periods.

class NoPingTrophonius:
  public Trophonius
{
public:
  NoPingTrophonius(boost::posix_time::time_duration const& period):
    Trophonius(),
    _ping_received(0),
    _period(period)
  {}

  ELLE_ATTRIBUTE_R(int, ping_received);

protected:
  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_DEBUG("%s: got connect message: %s",
               *this,
               elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
    auto previous = boost::posix_time::microsec_clock::local_time();
    ELLE_LOG("serving no ping");
    boost::posix_time::time_duration periods;
    try
    {
      while (true)
      {
        auto data_read = elle::json::read(socket);
        auto now = boost::posix_time::microsec_clock::local_time();
        auto ping = boost::any_cast<elle::json::Object>(data_read);
        auto diff = now - previous;
        ELLE_LOG("got ping after %s: %s", diff, elle::json::pretty_print(ping));
        periods += diff;
        previous = now;
        ++this->_ping_received;
      }
    }
    catch(reactor::network::ConnectionClosed const&)
    {
      BOOST_CHECK_LT(periods / this->_ping_received, this->_period * 12 / 10);
      // As the client will not be receiving any pings, it will disconnect
      auto disconnection_time =
        boost::posix_time::microsec_clock::local_time() - previous;
      ELLE_LOG("%s: disconnection after %s", *this, disconnection_time);
      BOOST_CHECK_GE(this->ping_received(), 1);
      BOOST_CHECK_LT(disconnection_time, this->_period * 22 / 10);
    }
  }

private:
  ELLE_ATTRIBUTE(boost::posix_time::time_duration, period);
};

ELLE_TEST_SCHEDULED(no_ping)
{
  boost::posix_time::time_duration const period = 500_ms;
  boost::posix_time::time_duration const run_time = 10_sec;
  int periods = run_time.total_milliseconds() / period.total_milliseconds();
  NoPingTrophonius tropho(period);
  using namespace infinit::oracles::trophonius;
  Client client(
    "127.0.0.1",
    tropho.port(),
    [] (bool) {}, // connect callback
    [] (void) {}, // reconnection failed callback
    fingerprint);
  client.ping_period(period);
  client.connect("0", "0", "0");
  reactor::wait(client.connected());
  BOOST_CHECK(client.connected());
  reactor::sleep(run_time);
  // Approximate test as we don't know how long a poke, connect, disconnect
  // cycle will take.
  BOOST_CHECK_LT(std::abs(client.reconnected() - (periods / 2)), 5);
}

/*-------------.
| Reconnection |
`-------------*/

// Ensure that we read the correct notification on losing connection and
// reconnecting.

class ReconnectionTrophonius:
  public Trophonius
{
public:
  ReconnectionTrophonius():
    Trophonius(),
    _first(true)
  {}

protected:
  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_DEBUG("%s: got connect message: %s",
               *this,
               elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
    if (this->_first)
    {
      this->_first = false;
      ELLE_LOG("send notification 0")
        this->_send_notification(socket, "0");
      ELLE_LOG("send notification 1")
        this->_send_notification(socket, "1");
      ELLE_LOG("wait for disconnection")
      // Read pings until disconnected.
      {
        try
        {
          while (true)
          {
            auto ping = elle::json::read(socket);
          }
        }
        catch (reactor::network::ConnectionClosed const&)
        {}
      }
    }
    else
    {
      ELLE_LOG("send notification 2")
        this->_send_notification(socket, "2");
      while (true)
      {
        auto ping = elle::json::read(socket);
      }
    }
  }

private:
  ELLE_ATTRIBUTE(bool, first);
};

ELLE_TEST_SCHEDULED(reconnection)
{
  reactor::Barrier reconnecting;
  bool synchronized = false;
  bool first_connect = true;
  ReconnectionTrophonius tropho;
  using namespace infinit::oracles::trophonius;
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    tropho.port(),
    [&] (bool connected) // connect callback
    {
      if (connected)
      {
        BOOST_CHECK(client.connected());
        if (first_connect)
        {
          // Wait to check that the client doesn't get notification '2' yet.
          reactor::sleep(1_sec);
          synchronized = true;
          first_connect = false;
        }
      }
      else
      {
        ELLE_LOG("client got disconnected");
        BOOST_CHECK(!client.connected());
        reconnecting.open();
      }
    },
    [] (void) {},  // reconnection failed callback
    fingerprint);
  client.ping_period(1_sec);
  ELLE_LOG("connect")
  {
    client.connect("0", "0", "0");
    reactor::wait(client.connected());
    BOOST_CHECK(client.connected());
  }
  ELLE_LOG("read notification 0");
  {
    auto notification =
      elle::cast<MessageNotification>::runtime(client.poll());
    BOOST_CHECK_EQUAL(notification->message, "0");
  }
  reactor::wait(reconnecting);
  reactor::wait(client.connected());
  ELLE_LOG("waited for ping timeout")
  {
    // Check notification 1 was discarded
    ELLE_LOG("read notification 2")
    {
      auto notification =
        elle::cast<MessageNotification>::runtime(client.poll());
      BOOST_CHECK(synchronized);
      BOOST_CHECK_EQUAL(notification->message, "2");
    }
  }
}

/*---------------------------.
| Connection callback throws |
`---------------------------*/

// Check that the reconnection callback is called and that it throws.

class SilentTrophonius:
  public Trophonius
{
protected:
  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_DEBUG("%s: got connect message: %s",
               *this,
               elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
    exhaust(socket);
  }
};

ELLE_TEST_SCHEDULED_THROWS(connection_callback_throws, std::runtime_error)
{
  bool beacon = false;
  SilentTrophonius tropho;
  using namespace infinit::oracles::trophonius;
  Client client(
    "127.0.0.1",
    tropho.port(),
    [&] (bool connected) // connect callback
    {
      if (connected)
      {
        ELLE_LOG("fail connect callback");
        beacon = true;
        throw std::runtime_error("sync failed");
      }
    },
    [] (void) {},  // reconnection failed callback
    fingerprint);
  client.ping_period(100_ms);
  ELLE_LOG("connect")
    client.connect("0", "0", "0");
  reactor::sleep(1_sec);
  BOOST_CHECK(beacon);
}

/*-----------------------------.
| Reconnection failed callback |
`-----------------------------*/

// Simulate reconnection on different network where there is no access to
// Trophonius, i.e.: server could be resolved but not contacted. This means that
// the reconnection failed callback should be called.

class ReconnectionFailTrophohius:
  public Trophonius
{
public:
  ReconnectionFailTrophohius():
    Trophonius()
  {}

protected:
  virtual
  void
  _handle_connection()
  {
    try
    {
      ELLE_LOG("first connection to server");
      auto socket = this->server().accept();
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
      auto poke = boost::any_cast<elle::json::Object>(poke_read);
      elle::json::write(*socket, poke);
      ELLE_LOG("%s replied to poke", *this);
      this->_serve(*socket);
    }
    catch (reactor::network::ConnectionClosed const&)
    {
      ELLE_LOG("%s: ignore connection closed on killing accepter", *this);
    }
    while (true)
    {
      auto socket = this->server().accept();
      exhaust(*socket);
    }
  }

  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_DEBUG("%s: got connect message: %s",
               *this,
               elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
    exhaust(socket);
  }
};

ELLE_TEST_SCHEDULED(reconnection_failed_callback)
{
  ReconnectionFailTrophohius tropho;
  reactor::Barrier callback_called;
  using namespace infinit::oracles::trophonius;
  Client client(
    "127.0.0.1",
    tropho.port(),
    [] (bool) {}, // connect callback
    [&] (void)    // reconnection failed callback
    {
      ELLE_LOG("reconnection failed callback called");
      callback_called.open();
    },
    fingerprint);
  client.poke_timeout(500_ms);
  client.ping_period(2_sec);
  ELLE_LOG("connect");
  client.connect("0", "0", "0");
  reactor::wait(callback_called);
  BOOST_CHECK(!client.connected());
}

/*------------------------.
| Close socket after poke |
`------------------------*/

// Test for the following bug: If connection is closed during _connect(), the
// client would never reopen the socket but keep retrying to authenticate in
// a loop.

class SocketClosedTrophonius:
  public Trophonius
{
public:
  SocketClosedTrophonius():
    Trophonius()
  {}

protected:
  virtual
  void
  _handle_connection()
  {
    try
    {
      ELLE_LOG("first connection to server");
      std::unique_ptr<reactor::network::Socket> socket(
        this->server().accept());
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
      auto poke = boost::any_cast<elle::json::Object>(poke_read);
      elle::json::write(*socket, poke);
      ELLE_LOG("%s replied to poke", *this);
      this->_serve(*socket);
    }
    catch (reactor::network::ConnectionClosed const&)
    {
      ELLE_LOG("%s: ignore connection closed on killing accepter", *this);
    }
  }

  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    socket.close();
    ELLE_LOG("socket closed");
  }
};

ELLE_TEST_SCHEDULED(socket_close_after_poke)
{
  SocketClosedTrophonius tropho;
  using namespace infinit::oracles::trophonius;
  reactor::Barrier b;
  bool success = false;
  int connectCount = 0;
  int reconnectCount = 0;
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    tropho.port(),
        [&] (bool v) {
          connectCount++;
          success = v;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // connect callback
        [&] (void) {
          reconnectCount++;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // reconnection failed callback
        fingerprint);
  client.ping_period(200_ms);
  BOOST_CHECK_NO_THROW(client.connect("", "", ""));
  b.wait();b.close();b.wait();
  BOOST_CHECK_EQUAL(reconnectCount, 1);
  BOOST_CHECK_EQUAL(connectCount, 1);
  BOOST_CHECK(!client.connected());
  BOOST_CHECK_EQUAL(success, false);
}

/*------------------.
| Notify disconnect |
`------------------*/

// Test sending a notification and disconnecting concurrently. This used to
// assert !this->_notifications.empty() because the poll thread would wake up
// but the disconnection would empty the notifications before it is executed.

class NotifyDisconnectTrophonius
  : public Trophonius
{
public:
  NotifyDisconnectTrophonius()
    : Trophonius()
  {}

protected:
  virtual
  void
  _serve(reactor::network::Socket& socket) override
  {
    ELLE_LOG("%s: get login", *this);
    auto connect_data = elle::json::read(socket);
    ELLE_LOG("%s: answer login", *this);
    this->_login_response(socket);
    ELLE_LOG("%s: send notification", *this);
    this->_send_notification(socket, "poke");
  }
};

ELLE_TEST_SCHEDULED(notify_disconnect)
{
  NotifyDisconnectTrophonius tropho;
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    tropho.port(),
    [&client] (bool connected)
    {
      if (!connected)
        client.ping_period(30_sec);
    },
    [] (void) {},
    fingerprint);
  client.ping_period(0_sec);
  client.connect("0", "0", "0");
  ELLE_LOG("%s: poll", client)
    client.poll();
}

/*----------------.
| Login reconnect |
`----------------*/

// Login while reconnecting

class LoginReconnectingTrophonius
  : public Trophonius
{
public:
  LoginReconnectingTrophonius()
    : Trophonius()
    , _iteration(0)
  {}

  virtual
  ~LoginReconnectingTrophonius()
  {
    ELLE_LOG("iterations done: %s", this->_iteration);
  }

protected:
  virtual
  void
  _serve(reactor::network::Socket& socket) override
  {
    // connection 0: first client auth, make it work and kick him.
    // connection 1: read thread reconnection, make it fail immediately.
    // connection 2: second manual connection, make it work and keep it.
    // following connection: pong thread and read thread reconnecting,
    //                       keep them.
    auto iteration = this->_iteration;
    ++this->_iteration;
    ELLE_LOG("%s: connection %s", *this, iteration);
    if (iteration == 1)
      return;
    ELLE_LOG("%s: get login", *this);
    auto connect_data = elle::json::read(socket);
    ELLE_LOG("%s: answer login", *this);
    this->_login_response(socket);
    if (iteration >= 2)
      exhaust(socket);
  }

  ELLE_ATTRIBUTE(int, iteration);
};

ELLE_TEST_SCHEDULED(login_reconnect)
{
  LoginReconnectingTrophonius tropho;
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    tropho.port(),
    [] (bool connected) {
      ELLE_LOG("reconnection callback: %sconnected", connected ? "" : "dis");
      if (connected) reactor::sleep(2_sec);
    },
    [] (void) {},
    fingerprint);
  client.ping_period(100_ms);
  client.reconnection_cooldown(1_sec);
  ELLE_LOG("first connection")
    client.connect("0", "0", "0");
  reactor::sleep(300_ms);
  ELLE_LOG("second connection")
    client.connect("0", "0", "0");
  ELLE_LOG("final sleep")
    reactor::sleep(2_sec);
  ELLE_LOG("done");
}

/*--------------------.
| Invalid credentials |
`--------------------*/

// Ensure that client handles invalid credentials message correctly.

class InvalidCredentailsTrophonius
  : public Trophonius
{
public:
  InvalidCredentailsTrophonius()
    : Trophonius()
  {}
protected:
  virtual
  void
  _serve(reactor::network::Socket& socket) override
  {
    ELLE_LOG("%s: get login", *this);
    auto connect_data = elle::json::read(socket);
    ELLE_LOG("%s: answer login", *this);
    this->_login_response(socket);
    elle::json::Object notification;
    notification["notification_type"] =
      int(NotificationCode::INVALID_CREDENTAILS_NOTIFICATION);
    notification["message"] = std::string("kick!");
    ELLE_LOG("%s: send invalid credentails", *this);
    elle::json::write(socket, notification);
  }
};

ELLE_TEST_SCHEDULED(invalid_credentials)
{
  InvalidCredentailsTrophonius tropho;
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    tropho.port(),
    [] (bool connected) { if (connected) reactor::sleep(2_sec); },
    [] (void) {},
    fingerprint);
  client.connect("0", "0", "0");
  reactor::wait(client.connected());
  ELLE_LOG("poll for credentials invalid notification");
  auto notif = client.poll();
  BOOST_CHECK_EQUAL(int(notif->notification_type),
                    int(NotificationCode::INVALID_CREDENTAILS_NOTIFICATION));
}

/*---------------------.
| Connect Read Timeout |
`---------------------*/

// Ensure that client handles read timeouts on connection correctly.

class ConnectReadTimeoutTrophonius
  : public Trophonius
{
public:
  ConnectReadTimeoutTrophonius()
    : Trophonius()
  {}

protected:
  virtual
  void
  _serve(reactor::network::Socket& socket) override
  {
    ELLE_LOG("%s: get login", *this);
    auto connect_data = elle::json::read(socket);
    exhaust(socket);
  }
};

ELLE_TEST_SCHEDULED(connect_read_timeout)
{
  ConnectReadTimeoutTrophonius tropho;
    reactor::Barrier b;
  bool success = false;
  int connectCount = 0;
  int reconnectCount = 0;
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    tropho.port(),
        [&] (bool v) {
          connectCount++;
          success = v;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // connect callback
        [&] (void) {
          reconnectCount++;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // reconnection failed callback
        fingerprint);
  client.connect_timeout(500_ms);
  BOOST_CHECK_NO_THROW(client.connect("0", "0", "0"));
  b.wait();b.close();b.wait();
  BOOST_CHECK_EQUAL(reconnectCount, 1);
  BOOST_CHECK_EQUAL(connectCount, 1);
  BOOST_CHECK(!client.connected());
  BOOST_CHECK_EQUAL(success, false);
}

/*---------------------.
| SSL shutdown timeout |
`---------------------*/

namespace ssl_shutdown
{
  class TimeoutConnectTrophonius
    : public Trophonius
  {
  protected:
    virtual
    void
    _handle_connection() override
    {
      auto socket = this->server().accept();
      reactor::sleep();
    }

    virtual
    void
    _serve(reactor::network::Socket&) override
    {}
  };

  ELLE_TEST_SCHEDULED(timeout_connect)
  {
    TimeoutConnectTrophonius tropho;
    reactor::Barrier b;
    bool success = false;
    int connectCount = 0;
    int reconnectCount = 0;
    infinit::oracles::trophonius::Client client(
      "127.0.0.1",
      tropho.port(),
        [&] (bool v) {
          connectCount++;
          success = v;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // connect callback
        [&] (void) {
          reconnectCount++;
          b.open();
          reactor::yield();
          reactor::yield();
        }, // reconnection failed callback
        fingerprint);
    client.poke_timeout(50_ms);
    client.connect_timeout(50_ms);
    BOOST_CHECK_NO_THROW(client.connect("0", "0", "0"));
    b.wait();b.close();b.wait();
    BOOST_CHECK_EQUAL(reconnectCount, 1);
    BOOST_CHECK_EQUAL(connectCount, 1);
    BOOST_CHECK(!client.connected());
    BOOST_CHECK_EQUAL(success, false);
  }

  class TimeoutReconnectTrophonius
    : public Trophonius
  {
  protected:
    virtual
    void
    _serve(reactor::network::Socket& socket) override
    {
      auto connect_data = elle::json::read(socket);
      this->_login_response(socket);
      reactor::wait(this->_done);
    }
    ELLE_ATTRIBUTE_RX(reactor::Barrier, done);
  };

  ELLE_TEST_SCHEDULED(timeout_reconnect)
  {
    TimeoutReconnectTrophonius tropho;
    infinit::oracles::trophonius::Client client(
      "127.0.0.1",
      tropho.port(),
      [&] (bool connected)
      {
        if (connected)
          tropho.done().open();
      },
      [] (void) {},
      fingerprint);
    client.ping_period(100_ms);
    client.connect("0", "0", "0");
    reactor::wait(tropho.done());
  }

  class TimeoutDisconnectTrophonius
    : public Trophonius
  {
  protected:
    virtual
    void
    _serve(reactor::network::Socket& socket) override
    {
      auto connect_data = elle::json::read(socket);
      this->_login_response(socket);
      reactor::sleep();
    }
  };

  ELLE_TEST_SCHEDULED(timeout_disconnect)
  {
    TimeoutDisconnectTrophonius tropho;
    infinit::oracles::trophonius::Client client(
      "127.0.0.1",
      tropho.port(),
      [] (bool connected) {},
      [] (void) {},
      fingerprint);
    client.connect_timeout(valgrind(200_ms));
    client.connect("0", "0", "0");
  }
}

// Test suite

ELLE_TEST_SUITE()
{
  auto timeout = RUNNING_ON_VALGRIND ? 20 : 5;
  auto& suite = boost::unit_test::framework::master_test_suite();
  {
    boost::unit_test::test_suite* poke = BOOST_TEST_SUITE("poke");
    boost::unit_test::framework::master_test_suite().add(poke);
    auto success = &poke_success;
    poke->add(BOOST_TEST_CASE(success));
    auto no_reply = &poke_no_reply;
    poke->add(BOOST_TEST_CASE(no_reply));
    auto resolution_failure = &poke_resolution_failure;
    poke->add(BOOST_TEST_CASE(resolution_failure));
    auto json = &poke_json;
    poke->add(BOOST_TEST_CASE(json));
    auto html = &poke_html;
    poke->add(BOOST_TEST_CASE(html));
    auto connection_refused = &poke_connection_refused;
    poke->add(BOOST_TEST_CASE(connection_refused));
  }
  suite.add(BOOST_TEST_CASE(notification), 0, timeout);
  suite.add(BOOST_TEST_CASE(ping), 0, 5 * timeout);
  suite.add(BOOST_TEST_CASE(no_ping), 0, 5 * timeout);
  suite.add(BOOST_TEST_CASE(reconnection), 0, 2 * timeout);
  suite.add(BOOST_TEST_CASE(connection_callback_throws), 0, timeout);
  suite.add(BOOST_TEST_CASE(reconnection_failed_callback), 0, 2 * timeout);
  suite.add(BOOST_TEST_CASE(socket_close_after_poke), 0, timeout);
  suite.add(BOOST_TEST_CASE(notify_disconnect), 0, timeout);
  suite.add(BOOST_TEST_CASE(login_reconnect), 0, timeout);
  suite.add(BOOST_TEST_CASE(invalid_credentials), 0, timeout);
  suite.add(BOOST_TEST_CASE(connect_read_timeout), 0, timeout);
  {
    using namespace ssl_shutdown;
    boost::unit_test::test_suite* s = BOOST_TEST_SUITE("ssl_shutdown");
    suite.add(s);
    s->add(BOOST_TEST_CASE(timeout_connect), 0, timeout);
    s->add(BOOST_TEST_CASE(timeout_reconnect), 0, timeout);
    s->add(BOOST_TEST_CASE(timeout_disconnect), 0, timeout);
  }
}

const std::vector<unsigned char> fingerprint =
{
  0x66, 0x84, 0x68, 0xEB, 0xBE, 0x83, 0xA0, 0x5C, 0x6A, 0x32,
  0xAD, 0xD2, 0x58, 0x62, 0x01, 0x31, 0x79, 0x96, 0x78, 0xB8
};

const std::vector<char> server_certificate =
{
  0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x44, 0x61, 0x74, 0x61, 0x3a, 0x0a, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69,
  0x6f, 0x6e, 0x3a, 0x20, 0x33, 0x20, 0x28, 0x30, 0x78, 0x32, 0x29, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x65, 0x72, 0x69,
  0x61, 0x6c, 0x20, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x3a, 0x20, 0x34,
  0x30, 0x39, 0x36, 0x20, 0x28, 0x30, 0x78, 0x31, 0x30, 0x30, 0x30, 0x29,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,
  0x72, 0x65, 0x20, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d,
  0x3a, 0x20, 0x73, 0x68, 0x61, 0x31, 0x57, 0x69, 0x74, 0x68, 0x52, 0x53,
  0x41, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x49, 0x73, 0x73, 0x75,
  0x65, 0x72, 0x3a, 0x20, 0x43, 0x3d, 0x46, 0x52, 0x2c, 0x20, 0x53, 0x54,
  0x3d, 0x49, 0x6c, 0x65, 0x2d, 0x64, 0x65, 0x2d, 0x46, 0x72, 0x61, 0x6e,
  0x63, 0x65, 0x2c, 0x20, 0x4c, 0x3d, 0x50, 0x61, 0x72, 0x69, 0x73, 0x2c,
  0x20, 0x4f, 0x3d, 0x49, 0x6e, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x2e, 0x69,
  0x6f, 0x2c, 0x20, 0x4f, 0x55, 0x3d, 0x44, 0x65, 0x76, 0x65, 0x6c, 0x6f,
  0x70, 0x6d, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x43, 0x4e, 0x3d, 0x4c, 0x6f,
  0x75, 0x69, 0x73, 0x20, 0x46, 0x45, 0x55, 0x56, 0x52, 0x49, 0x45, 0x52,
  0x2f, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
  0x73, 0x3d, 0x6c, 0x6f, 0x75, 0x69, 0x73, 0x2e, 0x66, 0x65, 0x75, 0x76,
  0x72, 0x69, 0x65, 0x72, 0x40, 0x69, 0x6e, 0x66, 0x69, 0x6e, 0x69, 0x74,
  0x2e, 0x69, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x56, 0x61, 0x6c, 0x69, 0x64, 0x69, 0x74, 0x79, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4e, 0x6f, 0x74,
  0x20, 0x42, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x3a, 0x20, 0x44, 0x65, 0x63,
  0x20, 0x20, 0x35, 0x20, 0x31, 0x30, 0x3a, 0x35, 0x39, 0x3a, 0x34, 0x38,
  0x20, 0x32, 0x30, 0x31, 0x33, 0x20, 0x47, 0x4d, 0x54, 0x0a, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4e, 0x6f,
  0x74, 0x20, 0x41, 0x66, 0x74, 0x65, 0x72, 0x20, 0x3a, 0x20, 0x44, 0x65,
  0x63, 0x20, 0x20, 0x35, 0x20, 0x31, 0x30, 0x3a, 0x35, 0x39, 0x3a, 0x34,
  0x38, 0x20, 0x32, 0x30, 0x31, 0x34, 0x20, 0x47, 0x4d, 0x54, 0x0a, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x75, 0x62, 0x6a, 0x65,
  0x63, 0x74, 0x3a, 0x20, 0x43, 0x3d, 0x46, 0x52, 0x2c, 0x20, 0x53, 0x54,
  0x3d, 0x49, 0x6c, 0x65, 0x2d, 0x64, 0x65, 0x2d, 0x46, 0x72, 0x61, 0x6e,
  0x63, 0x65, 0x2c, 0x20, 0x4f, 0x3d, 0x49, 0x6e, 0x66, 0x69, 0x6e, 0x69,
  0x74, 0x2e, 0x69, 0x6f, 0x2c, 0x20, 0x4f, 0x55, 0x3d, 0x44, 0x65, 0x76,
  0x65, 0x6c, 0x6f, 0x70, 0x6d, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x43, 0x4e,
  0x3d, 0x4c, 0x6f, 0x75, 0x69, 0x73, 0x20, 0x46, 0x45, 0x55, 0x56, 0x52,
  0x49, 0x45, 0x52, 0x2f, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x41, 0x64, 0x64,
  0x72, 0x65, 0x73, 0x73, 0x3d, 0x6c, 0x6f, 0x75, 0x69, 0x73, 0x2e, 0x66,
  0x65, 0x75, 0x76, 0x72, 0x69, 0x65, 0x72, 0x40, 0x69, 0x6e, 0x66, 0x69,
  0x6e, 0x69, 0x74, 0x2e, 0x69, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x53, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x50,
  0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x4b, 0x65, 0x79, 0x20, 0x49, 0x6e,
  0x66, 0x6f, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x4b,
  0x65, 0x79, 0x20, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d,
  0x3a, 0x20, 0x72, 0x73, 0x61, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,
  0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x50, 0x75, 0x62, 0x6c,
  0x69, 0x63, 0x2d, 0x4b, 0x65, 0x79, 0x3a, 0x20, 0x28, 0x31, 0x30, 0x32,
  0x34, 0x20, 0x62, 0x69, 0x74, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4d,
  0x6f, 0x64, 0x75, 0x6c, 0x75, 0x73, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x30, 0x30, 0x3a, 0x64, 0x30, 0x3a, 0x66, 0x66,
  0x3a, 0x61, 0x30, 0x3a, 0x34, 0x34, 0x3a, 0x63, 0x66, 0x3a, 0x65, 0x35,
  0x3a, 0x30, 0x65, 0x3a, 0x63, 0x34, 0x3a, 0x62, 0x66, 0x3a, 0x32, 0x32,
  0x3a, 0x35, 0x33, 0x3a, 0x64, 0x38, 0x3a, 0x30, 0x65, 0x3a, 0x36, 0x39,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x61,
  0x3a, 0x31, 0x61, 0x3a, 0x33, 0x65, 0x3a, 0x31, 0x64, 0x3a, 0x37, 0x38,
  0x3a, 0x63, 0x39, 0x3a, 0x35, 0x32, 0x3a, 0x38, 0x35, 0x3a, 0x38, 0x30,
  0x3a, 0x31, 0x63, 0x3a, 0x65, 0x35, 0x3a, 0x65, 0x64, 0x3a, 0x66, 0x35,
  0x3a, 0x32, 0x62, 0x3a, 0x30, 0x37, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x66, 0x63, 0x3a, 0x63, 0x37, 0x3a, 0x32, 0x62,
  0x3a, 0x63, 0x61, 0x3a, 0x31, 0x38, 0x3a, 0x37, 0x35, 0x3a, 0x66, 0x37,
  0x3a, 0x39, 0x31, 0x3a, 0x35, 0x61, 0x3a, 0x39, 0x32, 0x3a, 0x37, 0x39,
  0x3a, 0x35, 0x35, 0x3a, 0x66, 0x36, 0x3a, 0x65, 0x39, 0x3a, 0x34, 0x32,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x30,
  0x3a, 0x65, 0x30, 0x3a, 0x61, 0x33, 0x3a, 0x64, 0x66, 0x3a, 0x66, 0x62,
  0x3a, 0x33, 0x65, 0x3a, 0x62, 0x34, 0x3a, 0x34, 0x32, 0x3a, 0x64, 0x30,
  0x3a, 0x34, 0x62, 0x3a, 0x66, 0x35, 0x3a, 0x65, 0x62, 0x3a, 0x30, 0x35,
  0x3a, 0x34, 0x34, 0x3a, 0x33, 0x32, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x32, 0x63, 0x3a, 0x34, 0x61, 0x3a, 0x38, 0x35,
  0x3a, 0x64, 0x30, 0x3a, 0x65, 0x31, 0x3a, 0x61, 0x33, 0x3a, 0x36, 0x63,
  0x3a, 0x61, 0x61, 0x3a, 0x66, 0x30, 0x3a, 0x30, 0x31, 0x3a, 0x66, 0x37,
  0x3a, 0x31, 0x32, 0x3a, 0x63, 0x34, 0x3a, 0x30, 0x65, 0x3a, 0x66, 0x66,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x30,
  0x3a, 0x61, 0x31, 0x3a, 0x37, 0x34, 0x3a, 0x64, 0x32, 0x3a, 0x36, 0x35,
  0x3a, 0x32, 0x30, 0x3a, 0x64, 0x62, 0x3a, 0x35, 0x61, 0x3a, 0x30, 0x33,
  0x3a, 0x37, 0x38, 0x3a, 0x63, 0x37, 0x3a, 0x35, 0x34, 0x3a, 0x61, 0x31,
  0x3a, 0x62, 0x63, 0x3a, 0x64, 0x37, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x38, 0x33, 0x3a, 0x66, 0x66, 0x3a, 0x39, 0x37,
  0x3a, 0x37, 0x38, 0x3a, 0x62, 0x64, 0x3a, 0x31, 0x34, 0x3a, 0x64, 0x36,
  0x3a, 0x35, 0x31, 0x3a, 0x33, 0x35, 0x3a, 0x62, 0x61, 0x3a, 0x36, 0x30,
  0x3a, 0x31, 0x62, 0x3a, 0x66, 0x66, 0x3a, 0x39, 0x34, 0x3a, 0x62, 0x66,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x37, 0x65,
  0x3a, 0x34, 0x63, 0x3a, 0x34, 0x34, 0x3a, 0x61, 0x62, 0x3a, 0x63, 0x63,
  0x3a, 0x62, 0x36, 0x3a, 0x39, 0x33, 0x3a, 0x30, 0x63, 0x3a, 0x36, 0x61,
  0x3a, 0x35, 0x66, 0x3a, 0x38, 0x36, 0x3a, 0x38, 0x65, 0x3a, 0x32, 0x38,
  0x3a, 0x36, 0x62, 0x3a, 0x39, 0x31, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x65, 0x64, 0x3a, 0x32, 0x38, 0x3a, 0x62, 0x61,
  0x3a, 0x34, 0x61, 0x3a, 0x36, 0x66, 0x3a, 0x34, 0x66, 0x3a, 0x33, 0x33,
  0x3a, 0x33, 0x66, 0x3a, 0x34, 0x35, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x45,
  0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x3a, 0x20, 0x36, 0x35, 0x35,
  0x33, 0x37, 0x20, 0x28, 0x30, 0x78, 0x31, 0x30, 0x30, 0x30, 0x31, 0x29,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x58, 0x35, 0x30,
  0x39, 0x76, 0x33, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f,
  0x6e, 0x73, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x58, 0x35, 0x30, 0x39, 0x76, 0x33, 0x20, 0x42,
  0x61, 0x73, 0x69, 0x63, 0x20, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61,
  0x69, 0x6e, 0x74, 0x73, 0x3a, 0x20, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x43,
  0x41, 0x3a, 0x46, 0x41, 0x4c, 0x53, 0x45, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4e, 0x65, 0x74, 0x73,
  0x63, 0x61, 0x70, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74,
  0x3a, 0x20, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4f, 0x70, 0x65, 0x6e, 0x53,
  0x53, 0x4c, 0x20, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64,
  0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x58, 0x35, 0x30, 0x39, 0x76, 0x33, 0x20, 0x53, 0x75, 0x62, 0x6a,
  0x65, 0x63, 0x74, 0x20, 0x4b, 0x65, 0x79, 0x20, 0x49, 0x64, 0x65, 0x6e,
  0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x3a, 0x20, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x44, 0x35, 0x3a, 0x35, 0x44, 0x3a, 0x43, 0x36, 0x3a, 0x32, 0x43,
  0x3a, 0x41, 0x42, 0x3a, 0x31, 0x46, 0x3a, 0x42, 0x44, 0x3a, 0x32, 0x41,
  0x3a, 0x35, 0x42, 0x3a, 0x45, 0x38, 0x3a, 0x34, 0x46, 0x3a, 0x43, 0x36,
  0x3a, 0x36, 0x38, 0x3a, 0x42, 0x38, 0x3a, 0x42, 0x42, 0x3a, 0x33, 0x32,
  0x3a, 0x38, 0x37, 0x3a, 0x44, 0x34, 0x3a, 0x31, 0x44, 0x3a, 0x45, 0x35,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x58, 0x35, 0x30, 0x39, 0x76, 0x33, 0x20, 0x41, 0x75, 0x74, 0x68,
  0x6f, 0x72, 0x69, 0x74, 0x79, 0x20, 0x4b, 0x65, 0x79, 0x20, 0x49, 0x64,
  0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x3a, 0x20, 0x0a, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x6b, 0x65, 0x79, 0x69, 0x64, 0x3a, 0x33, 0x37, 0x3a,
  0x38, 0x38, 0x3a, 0x37, 0x35, 0x3a, 0x43, 0x33, 0x3a, 0x34, 0x45, 0x3a,
  0x34, 0x42, 0x3a, 0x31, 0x33, 0x3a, 0x46, 0x33, 0x3a, 0x30, 0x32, 0x3a,
  0x37, 0x46, 0x3a, 0x30, 0x43, 0x3a, 0x42, 0x44, 0x3a, 0x44, 0x30, 0x3a,
  0x39, 0x43, 0x3a, 0x38, 0x35, 0x3a, 0x34, 0x36, 0x3a, 0x46, 0x39, 0x3a,
  0x42, 0x46, 0x3a, 0x34, 0x31, 0x3a, 0x44, 0x46, 0x0a, 0x0a, 0x20, 0x20,
  0x20, 0x20, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x20,
  0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x3a, 0x20, 0x73,
  0x68, 0x61, 0x31, 0x57, 0x69, 0x74, 0x68, 0x52, 0x53, 0x41, 0x45, 0x6e,
  0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x32, 0x61, 0x3a, 0x36, 0x35, 0x3a,
  0x63, 0x39, 0x3a, 0x33, 0x31, 0x3a, 0x66, 0x39, 0x3a, 0x65, 0x66, 0x3a,
  0x62, 0x35, 0x3a, 0x37, 0x37, 0x3a, 0x65, 0x37, 0x3a, 0x37, 0x36, 0x3a,
  0x66, 0x61, 0x3a, 0x30, 0x63, 0x3a, 0x34, 0x39, 0x3a, 0x64, 0x61, 0x3a,
  0x33, 0x33, 0x3a, 0x36, 0x33, 0x3a, 0x61, 0x38, 0x3a, 0x35, 0x38, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x33,
  0x3a, 0x38, 0x31, 0x3a, 0x64, 0x61, 0x3a, 0x64, 0x37, 0x3a, 0x37, 0x32,
  0x3a, 0x36, 0x35, 0x3a, 0x66, 0x39, 0x3a, 0x39, 0x63, 0x3a, 0x30, 0x36,
  0x3a, 0x65, 0x31, 0x3a, 0x39, 0x36, 0x3a, 0x36, 0x36, 0x3a, 0x66, 0x63,
  0x3a, 0x38, 0x38, 0x3a, 0x61, 0x38, 0x3a, 0x63, 0x34, 0x3a, 0x31, 0x63,
  0x3a, 0x38, 0x66, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x62, 0x65, 0x3a, 0x36, 0x36, 0x3a, 0x39, 0x38, 0x3a, 0x33,
  0x64, 0x3a, 0x64, 0x62, 0x3a, 0x61, 0x65, 0x3a, 0x36, 0x32, 0x3a, 0x63,
  0x33, 0x3a, 0x66, 0x63, 0x3a, 0x37, 0x32, 0x3a, 0x66, 0x63, 0x3a, 0x32,
  0x62, 0x3a, 0x64, 0x37, 0x3a, 0x36, 0x63, 0x3a, 0x39, 0x37, 0x3a, 0x30,
  0x65, 0x3a, 0x31, 0x63, 0x3a, 0x35, 0x32, 0x3a, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x39, 0x3a, 0x63, 0x63, 0x3a,
  0x66, 0x64, 0x3a, 0x65, 0x35, 0x3a, 0x66, 0x32, 0x3a, 0x65, 0x39, 0x3a,
  0x62, 0x36, 0x3a, 0x65, 0x31, 0x3a, 0x31, 0x38, 0x3a, 0x31, 0x30, 0x3a,
  0x33, 0x32, 0x3a, 0x36, 0x63, 0x3a, 0x31, 0x35, 0x3a, 0x38, 0x66, 0x3a,
  0x36, 0x63, 0x3a, 0x61, 0x34, 0x3a, 0x32, 0x64, 0x3a, 0x64, 0x35, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x31,
  0x3a, 0x35, 0x39, 0x3a, 0x38, 0x31, 0x3a, 0x39, 0x65, 0x3a, 0x37, 0x34,
  0x3a, 0x62, 0x32, 0x3a, 0x66, 0x35, 0x3a, 0x64, 0x35, 0x3a, 0x34, 0x37,
  0x3a, 0x38, 0x32, 0x3a, 0x34, 0x32, 0x3a, 0x32, 0x61, 0x3a, 0x31, 0x36,
  0x3a, 0x35, 0x32, 0x3a, 0x38, 0x32, 0x3a, 0x30, 0x61, 0x3a, 0x62, 0x63,
  0x3a, 0x32, 0x61, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x37, 0x33, 0x3a, 0x30, 0x39, 0x3a, 0x66, 0x65, 0x3a, 0x38,
  0x63, 0x3a, 0x61, 0x36, 0x3a, 0x34, 0x30, 0x3a, 0x30, 0x63, 0x3a, 0x34,
  0x39, 0x3a, 0x30, 0x36, 0x3a, 0x66, 0x62, 0x3a, 0x31, 0x34, 0x3a, 0x66,
  0x62, 0x3a, 0x35, 0x38, 0x3a, 0x63, 0x30, 0x3a, 0x34, 0x66, 0x3a, 0x36,
  0x32, 0x3a, 0x33, 0x63, 0x3a, 0x65, 0x30, 0x3a, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x61, 0x3a, 0x62, 0x36, 0x3a,
  0x63, 0x38, 0x3a, 0x36, 0x36, 0x3a, 0x38, 0x64, 0x3a, 0x37, 0x37, 0x3a,
  0x63, 0x30, 0x3a, 0x36, 0x62, 0x3a, 0x36, 0x61, 0x3a, 0x64, 0x32, 0x3a,
  0x37, 0x33, 0x3a, 0x39, 0x37, 0x3a, 0x61, 0x35, 0x3a, 0x33, 0x33, 0x3a,
  0x30, 0x63, 0x3a, 0x62, 0x33, 0x3a, 0x64, 0x33, 0x3a, 0x34, 0x62, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x39,
  0x3a, 0x39, 0x33, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47,
  0x49, 0x4e, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41,
  0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x44,
  0x4b, 0x6a, 0x43, 0x43, 0x41, 0x70, 0x4f, 0x67, 0x41, 0x77, 0x49, 0x42,
  0x41, 0x67, 0x49, 0x43, 0x45, 0x41, 0x41, 0x77, 0x44, 0x51, 0x59, 0x4a,
  0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x46,
  0x42, 0x51, 0x41, 0x77, 0x67, 0x61, 0x4d, 0x78, 0x43, 0x7a, 0x41, 0x4a,
  0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59, 0x54, 0x41, 0x6b, 0x5a, 0x53,
  0x0a, 0x4d, 0x52, 0x59, 0x77, 0x46, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51,
  0x49, 0x44, 0x41, 0x31, 0x4a, 0x62, 0x47, 0x55, 0x74, 0x5a, 0x47, 0x55,
  0x74, 0x52, 0x6e, 0x4a, 0x68, 0x62, 0x6d, 0x4e, 0x6c, 0x4d, 0x51, 0x34,
  0x77, 0x44, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51, 0x48, 0x44, 0x41, 0x56,
  0x51, 0x59, 0x58, 0x4a, 0x70, 0x63, 0x7a, 0x45, 0x54, 0x4d, 0x42, 0x45,
  0x47, 0x41, 0x31, 0x55, 0x45, 0x0a, 0x43, 0x67, 0x77, 0x4b, 0x53, 0x57,
  0x35, 0x6d, 0x61, 0x57, 0x35, 0x70, 0x64, 0x43, 0x35, 0x70, 0x62, 0x7a,
  0x45, 0x55, 0x4d, 0x42, 0x49, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x77,
  0x77, 0x4c, 0x52, 0x47, 0x56, 0x32, 0x5a, 0x57, 0x78, 0x76, 0x63, 0x47,
  0x31, 0x6c, 0x62, 0x6e, 0x51, 0x78, 0x46, 0x7a, 0x41, 0x56, 0x42, 0x67,
  0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x44, 0x6b, 0x78, 0x76, 0x0a, 0x64,
  0x57, 0x6c, 0x7a, 0x49, 0x45, 0x5a, 0x46, 0x56, 0x56, 0x5a, 0x53, 0x53,
  0x55, 0x56, 0x53, 0x4d, 0x53, 0x67, 0x77, 0x4a, 0x67, 0x59, 0x4a, 0x4b,
  0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x6b, 0x42, 0x46,
  0x68, 0x6c, 0x73, 0x62, 0x33, 0x56, 0x70, 0x63, 0x79, 0x35, 0x6d, 0x5a,
  0x58, 0x56, 0x32, 0x63, 0x6d, 0x6c, 0x6c, 0x63, 0x6b, 0x42, 0x70, 0x62,
  0x6d, 0x5a, 0x70, 0x0a, 0x62, 0x6d, 0x6c, 0x30, 0x4c, 0x6d, 0x6c, 0x76,
  0x4d, 0x42, 0x34, 0x58, 0x44, 0x54, 0x45, 0x7a, 0x4d, 0x54, 0x49, 0x77,
  0x4e, 0x54, 0x45, 0x77, 0x4e, 0x54, 0x6b, 0x30, 0x4f, 0x46, 0x6f, 0x58,
  0x44, 0x54, 0x45, 0x30, 0x4d, 0x54, 0x49, 0x77, 0x4e, 0x54, 0x45, 0x77,
  0x4e, 0x54, 0x6b, 0x30, 0x4f, 0x46, 0x6f, 0x77, 0x67, 0x5a, 0x4d, 0x78,
  0x43, 0x7a, 0x41, 0x4a, 0x42, 0x67, 0x4e, 0x56, 0x0a, 0x42, 0x41, 0x59,
  0x54, 0x41, 0x6b, 0x5a, 0x53, 0x4d, 0x52, 0x59, 0x77, 0x46, 0x41, 0x59,
  0x44, 0x56, 0x51, 0x51, 0x49, 0x44, 0x41, 0x31, 0x4a, 0x62, 0x47, 0x55,
  0x74, 0x5a, 0x47, 0x55, 0x74, 0x52, 0x6e, 0x4a, 0x68, 0x62, 0x6d, 0x4e,
  0x6c, 0x4d, 0x52, 0x4d, 0x77, 0x45, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51,
  0x4b, 0x44, 0x41, 0x70, 0x4a, 0x62, 0x6d, 0x5a, 0x70, 0x62, 0x6d, 0x6c,
  0x30, 0x0a, 0x4c, 0x6d, 0x6c, 0x76, 0x4d, 0x52, 0x51, 0x77, 0x45, 0x67,
  0x59, 0x44, 0x56, 0x51, 0x51, 0x4c, 0x44, 0x41, 0x74, 0x45, 0x5a, 0x58,
  0x5a, 0x6c, 0x62, 0x47, 0x39, 0x77, 0x62, 0x57, 0x56, 0x75, 0x64, 0x44,
  0x45, 0x58, 0x4d, 0x42, 0x55, 0x47, 0x41, 0x31, 0x55, 0x45, 0x41, 0x77,
  0x77, 0x4f, 0x54, 0x47, 0x39, 0x31, 0x61, 0x58, 0x4d, 0x67, 0x52, 0x6b,
  0x56, 0x56, 0x56, 0x6c, 0x4a, 0x4a, 0x0a, 0x52, 0x56, 0x49, 0x78, 0x4b,
  0x44, 0x41, 0x6d, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39,
  0x77, 0x30, 0x42, 0x43, 0x51, 0x45, 0x57, 0x47, 0x57, 0x78, 0x76, 0x64,
  0x57, 0x6c, 0x7a, 0x4c, 0x6d, 0x5a, 0x6c, 0x64, 0x58, 0x5a, 0x79, 0x61,
  0x57, 0x56, 0x79, 0x51, 0x47, 0x6c, 0x75, 0x5a, 0x6d, 0x6c, 0x75, 0x61,
  0x58, 0x51, 0x75, 0x61, 0x57, 0x38, 0x77, 0x67, 0x5a, 0x38, 0x77, 0x0a,
  0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e,
  0x41, 0x51, 0x45, 0x42, 0x42, 0x51, 0x41, 0x44, 0x67, 0x59, 0x30, 0x41,
  0x4d, 0x49, 0x47, 0x4a, 0x41, 0x6f, 0x47, 0x42, 0x41, 0x4e, 0x44, 0x2f,
  0x6f, 0x45, 0x54, 0x50, 0x35, 0x51, 0x37, 0x45, 0x76, 0x79, 0x4a, 0x54,
  0x32, 0x41, 0x35, 0x70, 0x57, 0x68, 0x6f, 0x2b, 0x48, 0x58, 0x6a, 0x4a,
  0x55, 0x6f, 0x57, 0x41, 0x0a, 0x48, 0x4f, 0x58, 0x74, 0x39, 0x53, 0x73,
  0x48, 0x2f, 0x4d, 0x63, 0x72, 0x79, 0x68, 0x68, 0x31, 0x39, 0x35, 0x46,
  0x61, 0x6b, 0x6e, 0x6c, 0x56, 0x39, 0x75, 0x6c, 0x43, 0x34, 0x4f, 0x43,
  0x6a, 0x33, 0x2f, 0x73, 0x2b, 0x74, 0x45, 0x4c, 0x51, 0x53, 0x2f, 0x58,
  0x72, 0x42, 0x55, 0x51, 0x79, 0x4c, 0x45, 0x71, 0x46, 0x30, 0x4f, 0x47,
  0x6a, 0x62, 0x4b, 0x72, 0x77, 0x41, 0x66, 0x63, 0x53, 0x0a, 0x78, 0x41,
  0x37, 0x2f, 0x41, 0x4b, 0x46, 0x30, 0x30, 0x6d, 0x55, 0x67, 0x32, 0x31,
  0x6f, 0x44, 0x65, 0x4d, 0x64, 0x55, 0x6f, 0x62, 0x7a, 0x58, 0x67, 0x2f,
  0x2b, 0x58, 0x65, 0x4c, 0x30, 0x55, 0x31, 0x6c, 0x45, 0x31, 0x75, 0x6d,
  0x41, 0x62, 0x2f, 0x35, 0x53, 0x2f, 0x66, 0x6b, 0x78, 0x45, 0x71, 0x38,
  0x79, 0x32, 0x6b, 0x77, 0x78, 0x71, 0x58, 0x34, 0x61, 0x4f, 0x4b, 0x47,
  0x75, 0x52, 0x0a, 0x37, 0x53, 0x69, 0x36, 0x53, 0x6d, 0x39, 0x50, 0x4d,
  0x7a, 0x39, 0x46, 0x41, 0x67, 0x4d, 0x42, 0x41, 0x41, 0x47, 0x6a, 0x65,
  0x7a, 0x42, 0x35, 0x4d, 0x41, 0x6b, 0x47, 0x41, 0x31, 0x55, 0x64, 0x45,
  0x77, 0x51, 0x43, 0x4d, 0x41, 0x41, 0x77, 0x4c, 0x41, 0x59, 0x4a, 0x59,
  0x49, 0x5a, 0x49, 0x41, 0x59, 0x62, 0x34, 0x51, 0x67, 0x45, 0x4e, 0x42,
  0x42, 0x38, 0x57, 0x48, 0x55, 0x39, 0x77, 0x0a, 0x5a, 0x57, 0x35, 0x54,
  0x55, 0x30, 0x77, 0x67, 0x52, 0x32, 0x56, 0x75, 0x5a, 0x58, 0x4a, 0x68,
  0x64, 0x47, 0x56, 0x6b, 0x49, 0x45, 0x4e, 0x6c, 0x63, 0x6e, 0x52, 0x70,
  0x5a, 0x6d, 0x6c, 0x6a, 0x59, 0x58, 0x52, 0x6c, 0x4d, 0x42, 0x30, 0x47,
  0x41, 0x31, 0x55, 0x64, 0x44, 0x67, 0x51, 0x57, 0x42, 0x42, 0x54, 0x56,
  0x58, 0x63, 0x59, 0x73, 0x71, 0x78, 0x2b, 0x39, 0x4b, 0x6c, 0x76, 0x6f,
  0x0a, 0x54, 0x38, 0x5a, 0x6f, 0x75, 0x4c, 0x73, 0x79, 0x68, 0x39, 0x51,
  0x64, 0x35, 0x54, 0x41, 0x66, 0x42, 0x67, 0x4e, 0x56, 0x48, 0x53, 0x4d,
  0x45, 0x47, 0x44, 0x41, 0x57, 0x67, 0x42, 0x51, 0x33, 0x69, 0x48, 0x58,
  0x44, 0x54, 0x6b, 0x73, 0x54, 0x38, 0x77, 0x4a, 0x2f, 0x44, 0x4c, 0x33,
  0x51, 0x6e, 0x49, 0x56, 0x47, 0x2b, 0x62, 0x39, 0x42, 0x33, 0x7a, 0x41,
  0x4e, 0x42, 0x67, 0x6b, 0x71, 0x0a, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77,
  0x30, 0x42, 0x41, 0x51, 0x55, 0x46, 0x41, 0x41, 0x4f, 0x42, 0x67, 0x51,
  0x41, 0x71, 0x5a, 0x63, 0x6b, 0x78, 0x2b, 0x65, 0x2b, 0x31, 0x64, 0x2b,
  0x64, 0x32, 0x2b, 0x67, 0x78, 0x4a, 0x32, 0x6a, 0x4e, 0x6a, 0x71, 0x46,
  0x69, 0x44, 0x67, 0x64, 0x72, 0x58, 0x63, 0x6d, 0x58, 0x35, 0x6e, 0x41,
  0x62, 0x68, 0x6c, 0x6d, 0x62, 0x38, 0x69, 0x4b, 0x6a, 0x45, 0x0a, 0x48,
  0x49, 0x2b, 0x2b, 0x5a, 0x70, 0x67, 0x39, 0x32, 0x36, 0x35, 0x69, 0x77,
  0x2f, 0x78, 0x79, 0x2f, 0x43, 0x76, 0x58, 0x62, 0x4a, 0x63, 0x4f, 0x48,
  0x46, 0x4c, 0x35, 0x7a, 0x50, 0x33, 0x6c, 0x38, 0x75, 0x6d, 0x32, 0x34,
  0x52, 0x67, 0x51, 0x4d, 0x6d, 0x77, 0x56, 0x6a, 0x32, 0x79, 0x6b, 0x4c,
  0x64, 0x58, 0x42, 0x57, 0x59, 0x47, 0x65, 0x64, 0x4c, 0x4c, 0x31, 0x31,
  0x55, 0x65, 0x43, 0x0a, 0x51, 0x69, 0x6f, 0x57, 0x55, 0x6f, 0x49, 0x4b,
  0x76, 0x43, 0x70, 0x7a, 0x43, 0x66, 0x36, 0x4d, 0x70, 0x6b, 0x41, 0x4d,
  0x53, 0x51, 0x62, 0x37, 0x46, 0x50, 0x74, 0x59, 0x77, 0x45, 0x39, 0x69,
  0x50, 0x4f, 0x44, 0x4b, 0x74, 0x73, 0x68, 0x6d, 0x6a, 0x58, 0x66, 0x41,
  0x61, 0x32, 0x72, 0x53, 0x63, 0x35, 0x65, 0x6c, 0x4d, 0x77, 0x79, 0x7a,
  0x30, 0x30, 0x73, 0x4a, 0x6b, 0x77, 0x3d, 0x3d, 0x0a, 0x2d, 0x2d, 0x2d,
  0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46,
  0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a,
};

const std::vector<char> server_key =
{
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50,
  0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d,
  0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x43, 0x65, 0x41, 0x49, 0x42,
  0x41, 0x44, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47,
  0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x45, 0x46, 0x41, 0x41, 0x53, 0x43,
  0x41, 0x6d, 0x49, 0x77, 0x67, 0x67, 0x4a, 0x65, 0x41, 0x67, 0x45, 0x41,
  0x41, 0x6f, 0x47, 0x42, 0x41, 0x4e, 0x44, 0x2f, 0x6f, 0x45, 0x54, 0x50,
  0x35, 0x51, 0x37, 0x45, 0x76, 0x79, 0x4a, 0x54, 0x0a, 0x32, 0x41, 0x35,
  0x70, 0x57, 0x68, 0x6f, 0x2b, 0x48, 0x58, 0x6a, 0x4a, 0x55, 0x6f, 0x57,
  0x41, 0x48, 0x4f, 0x58, 0x74, 0x39, 0x53, 0x73, 0x48, 0x2f, 0x4d, 0x63,
  0x72, 0x79, 0x68, 0x68, 0x31, 0x39, 0x35, 0x46, 0x61, 0x6b, 0x6e, 0x6c,
  0x56, 0x39, 0x75, 0x6c, 0x43, 0x34, 0x4f, 0x43, 0x6a, 0x33, 0x2f, 0x73,
  0x2b, 0x74, 0x45, 0x4c, 0x51, 0x53, 0x2f, 0x58, 0x72, 0x42, 0x55, 0x51,
  0x79, 0x0a, 0x4c, 0x45, 0x71, 0x46, 0x30, 0x4f, 0x47, 0x6a, 0x62, 0x4b,
  0x72, 0x77, 0x41, 0x66, 0x63, 0x53, 0x78, 0x41, 0x37, 0x2f, 0x41, 0x4b,
  0x46, 0x30, 0x30, 0x6d, 0x55, 0x67, 0x32, 0x31, 0x6f, 0x44, 0x65, 0x4d,
  0x64, 0x55, 0x6f, 0x62, 0x7a, 0x58, 0x67, 0x2f, 0x2b, 0x58, 0x65, 0x4c,
  0x30, 0x55, 0x31, 0x6c, 0x45, 0x31, 0x75, 0x6d, 0x41, 0x62, 0x2f, 0x35,
  0x53, 0x2f, 0x66, 0x6b, 0x78, 0x45, 0x0a, 0x71, 0x38, 0x79, 0x32, 0x6b,
  0x77, 0x78, 0x71, 0x58, 0x34, 0x61, 0x4f, 0x4b, 0x47, 0x75, 0x52, 0x37,
  0x53, 0x69, 0x36, 0x53, 0x6d, 0x39, 0x50, 0x4d, 0x7a, 0x39, 0x46, 0x41,
  0x67, 0x4d, 0x42, 0x41, 0x41, 0x45, 0x43, 0x67, 0x59, 0x42, 0x53, 0x4c,
  0x4c, 0x41, 0x76, 0x58, 0x69, 0x36, 0x4a, 0x36, 0x41, 0x48, 0x65, 0x31,
  0x57, 0x69, 0x57, 0x41, 0x67, 0x5a, 0x54, 0x57, 0x79, 0x6a, 0x72, 0x0a,
  0x58, 0x50, 0x7a, 0x39, 0x55, 0x4b, 0x6f, 0x4d, 0x48, 0x63, 0x76, 0x50,
  0x35, 0x34, 0x77, 0x55, 0x49, 0x37, 0x75, 0x4b, 0x63, 0x70, 0x65, 0x73,
  0x70, 0x78, 0x67, 0x41, 0x62, 0x54, 0x52, 0x76, 0x38, 0x73, 0x50, 0x49,
  0x6a, 0x36, 0x5a, 0x35, 0x65, 0x75, 0x59, 0x56, 0x66, 0x79, 0x44, 0x65,
  0x79, 0x46, 0x47, 0x42, 0x78, 0x74, 0x68, 0x7a, 0x56, 0x4c, 0x6f, 0x54,
  0x78, 0x36, 0x65, 0x5a, 0x0a, 0x46, 0x4d, 0x70, 0x35, 0x47, 0x68, 0x42,
  0x37, 0x57, 0x64, 0x69, 0x33, 0x59, 0x55, 0x77, 0x50, 0x56, 0x66, 0x4c,
  0x53, 0x73, 0x4c, 0x5a, 0x41, 0x42, 0x71, 0x6c, 0x64, 0x4b, 0x36, 0x74,
  0x6e, 0x4d, 0x39, 0x54, 0x6f, 0x4a, 0x50, 0x38, 0x30, 0x39, 0x2f, 0x4d,
  0x6a, 0x66, 0x4e, 0x44, 0x32, 0x64, 0x36, 0x59, 0x2f, 0x52, 0x75, 0x30,
  0x55, 0x36, 0x73, 0x6f, 0x72, 0x71, 0x50, 0x55, 0x76, 0x0a, 0x56, 0x77,
  0x73, 0x49, 0x4b, 0x78, 0x42, 0x71, 0x57, 0x69, 0x62, 0x6e, 0x56, 0x50,
  0x74, 0x35, 0x41, 0x51, 0x4a, 0x42, 0x41, 0x50, 0x53, 0x68, 0x59, 0x34,
  0x72, 0x31, 0x63, 0x47, 0x38, 0x66, 0x56, 0x70, 0x6e, 0x6b, 0x6e, 0x4b,
  0x45, 0x64, 0x67, 0x31, 0x50, 0x47, 0x78, 0x77, 0x46, 0x68, 0x47, 0x37,
  0x56, 0x44, 0x42, 0x36, 0x74, 0x57, 0x51, 0x37, 0x62, 0x6d, 0x6a, 0x35,
  0x4e, 0x51, 0x0a, 0x53, 0x5a, 0x43, 0x64, 0x64, 0x65, 0x51, 0x5a, 0x6d,
  0x47, 0x66, 0x62, 0x4f, 0x6b, 0x48, 0x6c, 0x31, 0x58, 0x4e, 0x5a, 0x79,
  0x67, 0x56, 0x2b, 0x31, 0x31, 0x6c, 0x6c, 0x71, 0x7a, 0x58, 0x53, 0x38,
  0x51, 0x52, 0x37, 0x69, 0x57, 0x54, 0x68, 0x41, 0x4b, 0x30, 0x43, 0x51,
  0x51, 0x44, 0x61, 0x74, 0x6b, 0x6f, 0x4e, 0x71, 0x72, 0x56, 0x38, 0x68,
  0x6a, 0x6e, 0x72, 0x38, 0x61, 0x55, 0x4a, 0x0a, 0x46, 0x50, 0x63, 0x55,
  0x30, 0x2f, 0x4f, 0x79, 0x77, 0x33, 0x37, 0x54, 0x7a, 0x39, 0x6a, 0x4f,
  0x38, 0x64, 0x75, 0x74, 0x47, 0x34, 0x35, 0x7a, 0x59, 0x67, 0x47, 0x78,
  0x52, 0x61, 0x63, 0x33, 0x37, 0x77, 0x4e, 0x39, 0x51, 0x30, 0x38, 0x38,
  0x76, 0x38, 0x37, 0x50, 0x4d, 0x62, 0x6c, 0x72, 0x38, 0x56, 0x38, 0x31,
  0x63, 0x39, 0x5a, 0x51, 0x6b, 0x6e, 0x35, 0x2f, 0x2f, 0x53, 0x50, 0x4b,
  0x0a, 0x56, 0x39, 0x50, 0x35, 0x41, 0x6b, 0x45, 0x41, 0x67, 0x65, 0x39,
  0x2f, 0x4b, 0x66, 0x33, 0x33, 0x2f, 0x47, 0x34, 0x4f, 0x31, 0x36, 0x73,
  0x41, 0x4c, 0x75, 0x75, 0x34, 0x4a, 0x37, 0x56, 0x37, 0x57, 0x70, 0x59,
  0x7a, 0x32, 0x33, 0x47, 0x42, 0x44, 0x31, 0x62, 0x41, 0x6e, 0x4e, 0x4f,
  0x57, 0x43, 0x30, 0x38, 0x6e, 0x34, 0x2f, 0x4a, 0x65, 0x2f, 0x67, 0x74,
  0x43, 0x55, 0x6c, 0x65, 0x31, 0x0a, 0x64, 0x2b, 0x38, 0x57, 0x45, 0x7a,
  0x44, 0x73, 0x42, 0x30, 0x4d, 0x36, 0x4b, 0x7a, 0x65, 0x2f, 0x57, 0x74,
  0x56, 0x79, 0x51, 0x30, 0x6c, 0x43, 0x7a, 0x78, 0x78, 0x62, 0x2b, 0x51,
  0x4a, 0x42, 0x41, 0x4a, 0x79, 0x49, 0x5a, 0x50, 0x33, 0x64, 0x46, 0x4f,
  0x46, 0x58, 0x79, 0x2f, 0x4c, 0x44, 0x55, 0x77, 0x50, 0x70, 0x2f, 0x6d,
  0x44, 0x6f, 0x78, 0x58, 0x31, 0x48, 0x44, 0x2b, 0x6d, 0x57, 0x0a, 0x30,
  0x36, 0x78, 0x68, 0x53, 0x34, 0x46, 0x63, 0x76, 0x4a, 0x70, 0x32, 0x4a,
  0x5a, 0x48, 0x7a, 0x73, 0x52, 0x65, 0x47, 0x4f, 0x44, 0x41, 0x5a, 0x30,
  0x59, 0x64, 0x41, 0x48, 0x45, 0x73, 0x4d, 0x59, 0x70, 0x49, 0x51, 0x41,
  0x62, 0x31, 0x6d, 0x39, 0x35, 0x64, 0x5a, 0x45, 0x62, 0x4b, 0x57, 0x77,
  0x56, 0x76, 0x62, 0x65, 0x6a, 0x6b, 0x43, 0x51, 0x51, 0x44, 0x52, 0x46,
  0x42, 0x39, 0x73, 0x0a, 0x66, 0x39, 0x68, 0x53, 0x33, 0x57, 0x4d, 0x69,
  0x38, 0x65, 0x47, 0x6e, 0x43, 0x4d, 0x33, 0x58, 0x34, 0x4c, 0x32, 0x32,
  0x7a, 0x68, 0x61, 0x46, 0x42, 0x74, 0x68, 0x33, 0x73, 0x51, 0x7a, 0x78,
  0x72, 0x63, 0x4a, 0x35, 0x51, 0x4a, 0x55, 0x4d, 0x78, 0x57, 0x69, 0x44,
  0x6c, 0x45, 0x4f, 0x72, 0x76, 0x71, 0x47, 0x77, 0x4c, 0x48, 0x79, 0x67,
  0x50, 0x4f, 0x38, 0x59, 0x59, 0x38, 0x58, 0x6c, 0x0a, 0x74, 0x79, 0x59,
  0x63, 0x45, 0x64, 0x6c, 0x43, 0x4c, 0x35, 0x36, 0x71, 0x74, 0x41, 0x34,
  0x59, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x50,
  0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d,
  0x2d, 0x2d, 0x2d, 0x0a,
};

const std::vector<char> server_dh1024 =
{
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x44,
  0x48, 0x20, 0x50, 0x41, 0x52, 0x41, 0x4d, 0x45, 0x54, 0x45, 0x52, 0x53,
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x47, 0x48, 0x41, 0x6f,
  0x47, 0x42, 0x41, 0x4c, 0x50, 0x35, 0x33, 0x68, 0x32, 0x31, 0x59, 0x6d,
  0x6a, 0x47, 0x4a, 0x4f, 0x34, 0x53, 0x2f, 0x38, 0x42, 0x7a, 0x44, 0x61,
  0x57, 0x63, 0x4b, 0x6f, 0x46, 0x6c, 0x6a, 0x56, 0x32, 0x46, 0x37, 0x4f,
  0x66, 0x39, 0x4e, 0x50, 0x33, 0x31, 0x33, 0x4b, 0x54, 0x42, 0x2f, 0x51,
  0x55, 0x62, 0x6c, 0x58, 0x70, 0x6e, 0x65, 0x4e, 0x2b, 0x62, 0x0a, 0x32,
  0x41, 0x70, 0x76, 0x4e, 0x31, 0x32, 0x69, 0x33, 0x51, 0x46, 0x75, 0x52,
  0x2b, 0x4a, 0x6e, 0x4e, 0x70, 0x2b, 0x51, 0x2f, 0x6d, 0x47, 0x7a, 0x34,
  0x6b, 0x77, 0x32, 0x2b, 0x45, 0x48, 0x6d, 0x35, 0x67, 0x65, 0x68, 0x38,
  0x6f, 0x35, 0x54, 0x47, 0x6a, 0x57, 0x6a, 0x57, 0x50, 0x69, 0x33, 0x42,
  0x30, 0x78, 0x6c, 0x4c, 0x76, 0x4e, 0x4a, 0x4c, 0x54, 0x31, 0x32, 0x68,
  0x41, 0x56, 0x42, 0x0a, 0x76, 0x31, 0x6f, 0x38, 0x65, 0x50, 0x68, 0x30,
  0x72, 0x5a, 0x65, 0x66, 0x43, 0x47, 0x7a, 0x74, 0x68, 0x32, 0x4a, 0x2f,
  0x6a, 0x4b, 0x4c, 0x4f, 0x41, 0x57, 0x46, 0x36, 0x30, 0x6e, 0x32, 0x53,
  0x33, 0x45, 0x36, 0x34, 0x37, 0x5a, 0x4a, 0x74, 0x74, 0x32, 0x2f, 0x4b,
  0x47, 0x47, 0x6b, 0x76, 0x37, 0x56, 0x33, 0x62, 0x41, 0x67, 0x45, 0x43,
  0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x44, 0x48,
  0x20, 0x50, 0x41, 0x52, 0x41, 0x4d, 0x45, 0x54, 0x45, 0x52, 0x53, 0x2d,
  0x2d, 0x2d, 0x2d, 0x2d, 0x0a,
};
