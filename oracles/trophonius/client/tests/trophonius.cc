#include <elle/cast.hh>
#include <elle/json/json.hh>
#include <elle/log.hh>
#include <elle/test.hh>
#include <elle/utility/Move.hh>

#include <boost/filesystem.hpp>

#include <infinit/oracles/trophonius/Client.hh>

#include <reactor/network/buffer.hh>
#include <reactor/network/exception.hh>
#include <reactor/network/ssl-server.hh>
#include <reactor/scheduler.hh>
#include <reactor/signal.hh>
#include <reactor/Scope.hh>
#include <reactor/thread.hh>

ELLE_LOG_COMPONENT("infinit.oracles.trophonius.client.test")

#ifdef VALGRIND
# include <valgrind/valgrind.h>
#else
# define RUNNING_ON_VALGRIND 0
#endif

extern const std::vector<unsigned char> fingerprint;
extern const std::vector<char> server_certificate;
extern const std::vector<char> server_key;
extern const std::vector<char> server_dh1024;

enum class NotificationCode
{
  NONE_NOTIFICATION = 0,
  USER_STATUS_NOTIFICATION = 8,
  TRANSACTION_NOTIFICATION = 7,
  NEW_SWAGGER_NOTIFICATION = 9,
  PEER_CONNECTION_UPDATE_NOTIFICATION = 11,
  NETWORK_UPDATE_NOTIFICATION = 128,
  MESSAGE_NOTIFICATION = 217,
  PING_NOTIFICATION = 208,
  CONNECTION_ENABLED_NOTIFICATION = -666,
  SUICIDE_NOTIFICATION = 666,
};

class Trophonius
{
public:
    Trophonius():
      Trophonius(true)
    {}

  Trophonius(bool start):
    _certificate(nullptr),
    _server(nullptr),
    _port(),
    _accepter()
  {
    if (!start)
    {
      this->_port = 42;
      return;
    }

    this->_certificate.reset(new reactor::network::SSLCertificate(
      server_certificate,
      server_key,
      server_dh1024));
    this->_server.reset(new reactor::network::SSLServer(
      std::move(this->_certificate)));
    this->_server->listen(0);
    this->_port = this->_server->port();
    ELLE_LOG("%s: listen on port %s", *this, this->_port);
    this->_accepter.reset(new reactor::Thread(
      *reactor::Scheduler::scheduler(),
      "accepter",
      std::bind(&Trophonius::_handle_connection, std::ref(*this))));
  }

  ~Trophonius()
  {
    if (this->_accepter)
      this->_accepter->terminate_now();
    ELLE_LOG("%s: finalize", *this);
  }

  ELLE_ATTRIBUTE_RX(reactor::Signal, poked);

  ELLE_ATTRIBUTE(std::unique_ptr<reactor::network::SSLCertificate>,
                 certificate);
  ELLE_ATTRIBUTE(std::unique_ptr<reactor::network::SSLServer>, server);
  ELLE_ATTRIBUTE_R(int, port);
  ELLE_ATTRIBUTE(std::unique_ptr<reactor::Thread>, accepter);

protected:
  reactor::network::SSLServer&
  server()
  {
    return *this->_server;
  }

  virtual
  void
  _handle_connection()
  {
    try
    {
      while (true)
      {
        std::unique_ptr<reactor::network::Socket> socket(
          this->_server->accept());
        ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
        auto poke_read = elle::json::read(*socket);
        auto poke = boost::any_cast<elle::json::Object>(poke_read);
        elle::json::write(*socket, poke);
        ELLE_LOG("%s replied to poke", *this);
        this->_serve(*socket);
      }
    }
    catch (reactor::network::ConnectionClosed const&)
    {
      ELLE_LOG("%s: ignore connection closed on killing accepter", *this);
    }
  }

  void
  _send_notification(reactor::network::Socket& socket,
                     std::string const& message)
  {
    elle::json::Object notification;
    notification["notification_type"] =
      int(NotificationCode::MESSAGE_NOTIFICATION);
    notification["sender_id"] = std::string("id");
    notification["message"] = message;
    ELLE_LOG("%s: write: %s",
             *this,
             elle::json::pretty_print(notification));
    elle::json::write(socket, notification);
  }

  virtual
  void
  _serve(reactor::network::Socket& socket) = 0;

  virtual
  void
  _login_response(reactor::network::Socket& socket)
  {
    this->_login_response(socket, true);
  }

  void
  _login_response(reactor::network::Socket& socket, bool success)
  {
    elle::json::Object login_response;
    login_response["notification_type"] =
      int(NotificationCode::CONNECTION_ENABLED_NOTIFICATION);
    login_response["response_code"] = success ? int(200) : int(500);
    login_response["response_details"] = std::string("nothing");
    ELLE_LOG("%s: login response: %s",
             *this,
             elle::json::pretty_print(login_response));
    elle::json::write(socket, login_response);
  }
};

/*-----.
| Poke |
`-----*/

// Check that the client's poke reports connectivity correctly.

class PokeTrophonius:
  public Trophonius
{
public:
  PokeTrophonius(int round):
    PokeTrophonius(true, round)
  {
    ELLE_DEBUG("making trophonius for round %s", round);
  }

  PokeTrophonius(bool start, int round):
    Trophonius(start),
    _round(round)
  {}

  ELLE_ATTRIBUTE_R(int, round);

protected:
  virtual
  void
  _handle_connection()
  {
    ELLE_DEBUG("server in round: %s", this->_round);
    if (this->round() == 0) // Normal case.
    {
      std::unique_ptr<reactor::network::Socket> socket(
        this->server().accept());
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
      auto poke = boost::any_cast<elle::json::Object>(poke_read);
      elle::json::write(*socket, poke);
      ELLE_LOG("%s replied to poke", *this);
      reactor::wait(this->poked());
    }
    else if (this->round() == 1) // No poke reply.
    {
      std::unique_ptr<reactor::network::Socket> socket(
        this->server().accept());
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
      reactor::wait(this->poked());
    }
    else if (this->round() == 2) // Unable to resolve.
    {
      // Do nothing.
      reactor::wait(this->poked());
    }
    else if (this->round() == 3) // Wrong JSON reply.
    {
      std::unique_ptr<reactor::network::Socket> socket(
        this->server().accept());
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
      elle::json::Object rubbish;
      rubbish["poke"] = std::string("rubbish");
      elle::json::write(*socket, rubbish);
      ELLE_LOG("%s replied incorrect JSON to poke", *this);
      reactor::wait(this->poked());
    }
    else if (this->round() == 4) // HTML reply.
    {
      std::unique_ptr<reactor::network::Socket> socket(
        this->server().accept());
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
      std::string rubbish(
        "<h1>Some random HTML</h1>\n<p>shouldn't break anything</p>");
      socket->write(rubbish);
      ELLE_LOG("%s replied HTML to poke", *this);
      reactor::wait(this->poked());
    }
    else if (this->round() == 5) // Connection refused.
    {
      // Do nothing.
      reactor::wait(this->poked());
    }
  }

  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    // Do nothing.
  }

};

ELLE_TEST_SCHEDULED(poke)
{
  using namespace infinit::oracles::trophonius;
  std::unique_ptr<PokeTrophonius> tropho;
  int total_rounds = 6;
  reactor::Duration poke_timeout = 200_ms;
  std::unique_ptr<Client> client;
  for (int round = 0; round < total_rounds; round++)
  {
    if (round == total_rounds - 1)
      tropho.reset(new PokeTrophonius(false, round));
    else
      tropho.reset(new PokeTrophonius(round));

    reactor::sleep(50_ms);

    client.reset(new Client(
      "127.0.0.1",
      tropho->port(),
      [] (bool) {}, // connect callback
      [] (void) {}, // reconnection failed callback
      fingerprint)
    );
    ELLE_LOG("round: %s", round);
    BOOST_CHECK_EQUAL(tropho->round(), round);
    if (round == 0) // Normal case.
    {
      ELLE_LOG("normal case");
      BOOST_CHECK_EQUAL(client->poke(poke_timeout), true);
      tropho->poked().signal();
    }
    else if (round == 1) // No poke reply.
    {
      ELLE_LOG("no poke reply");
      BOOST_CHECK_EQUAL(client->poke(poke_timeout), false);
      tropho->poked().signal();
    }
    else if (round == 2) // Unable to resolve.
    {
      ELLE_LOG("unable to resolve");
      client.reset(new Client(
        "does.not.exist",
        tropho->port(),
        [] (bool) {}, // connect callback
        [] (void) {}, // reconnection failed callback
        fingerprint)
      );
      BOOST_CHECK_EQUAL(client->poke(poke_timeout), false);
      tropho->poked().signal();
    }
    else if (round == 3) // Wrong JSON reply.
    {
      ELLE_LOG("wrong json reply");
      BOOST_CHECK_EQUAL(client->poke(poke_timeout), false);
      tropho->poked().signal();
    }
    else if (round == 4) // HTML response
    {
      ELLE_LOG("HTML response");
      BOOST_CHECK_EQUAL(client->poke(poke_timeout), false);
      tropho->poked().signal();
    }
    else if (round == 5) // Connection refused.
    {
      ELLE_LOG("connection refused");
      BOOST_CHECK_EQUAL(client->poke(poke_timeout), false);
    }
  }
}

/*-------------.
| Notification |
`-------------*/

// Check that a client can receive a simple notification message and will
// reconnect when the socket is closed.

class NotificationTrophonius:
  public Trophonius
{
protected:
  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    ELLE_LOG("serve notification test");
    reactor::wait(this->poked());
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_LOG("%s: got connect message: %s",
             *this,
             elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
    this->_send_notification(socket, "hello");
  }
};

ELLE_TEST_SCHEDULED(notification)
{
  static int const reconnections = 5;
  NotificationTrophonius tropho;
  {
    using namespace infinit::oracles::trophonius;
    std::unique_ptr<Client> client;
    client.reset(new Client(
      "127.0.0.1",
      tropho.port(),
      [] (bool) {}, // connect callback
      [] (void) {}, // reconnection failed callback
      fingerprint)
    );
    elle::With<reactor::Scope>() << [&] (reactor::Scope& scope)
    {
      // We need to poke the server before connecting so that we have a valid
      // socket. After that the fake server is controlled by signalling the end
      // of pokes and connections.
      scope.run_background("notification check", [&]
      {
        reactor::wait(tropho.poked());
        client->connect("0", "0", "0");
        reactor::wait(client->connected());
        for (int i = 0; i < reconnections; ++i)
        {
          ELLE_LOG("poll notifications");
          std::unique_ptr<Notification> notification = client->poll();
          ELLE_DEBUG("back from poll");
          BOOST_CHECK_EQUAL(client->reconnected(), i);
          BOOST_CHECK(notification);
          ELLE_LOG("got notification type: %s", notification->notification_type);
          BOOST_CHECK_EQUAL(notification->notification_type,
                            NotificationType::message);
          // Wait for us to be connected before running test again.
          // This is done by forwarding the client's signals to our fake server.
          reactor::wait(client->poked());
          tropho.poked().signal();
          reactor::wait(client->connected());
        }
      });
      scope.run_background("poke server", [&]
      {
        BOOST_CHECK_EQUAL(client->poke(), true);
        tropho.poked().signal();
      });
      scope.wait();
    };
  }
}


/*-----.
| Ping |
`-----*/

// Check the client pings every period.

class PingTrophonius:
  public Trophonius
{
public:
  PingTrophonius(boost::posix_time::time_duration const& period):
    Trophonius(),
    _ping_received(0),
    _period(period)
  {}

ELLE_ATTRIBUTE_R(int, ping_received);

protected:
  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    reactor::wait(this->poked());
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_LOG("%s: got connect message: %s",
             *this,
             elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
    ELLE_LOG("start serving ping");
    elle::With<reactor::Scope>() << [&] (reactor::Scope& scope)
    {
      scope.run_background("pinger", [&]
      {
        while (true)
        {
          elle::json::Object msg;
          msg["notification_type"] = int(NotificationCode::PING_NOTIFICATION);
          ELLE_LOG("send ping");
          elle::json::write(socket, msg);
          reactor::sleep(this->_period);
        }
      });
      scope.run_background("ping checker", [&]
      {
        auto previous = boost::posix_time::microsec_clock::local_time();
        boost::posix_time::time_duration periods;
        while (true)
        {
          auto data_read = elle::json::read(socket);
          auto now = boost::posix_time::microsec_clock::local_time();
          auto ping = boost::any_cast<elle::json::Object>(data_read);
          auto diff = now - previous;
          ELLE_LOG("got ping after %s: %s",
                   diff,
                   elle::json::pretty_print(ping));
          periods += diff;
          previous = now;
          ++this->_ping_received;
        }
        // Check the mean ping time is 20% around the expected period.
        BOOST_CHECK_LT(periods / this->_ping_received, this->_period * 12 / 10);
      });
      scope.wait();
    };
  }

private:
  ELLE_ATTRIBUTE(boost::posix_time::time_duration, period);
};

ELLE_TEST_SCHEDULED(ping)
{
  boost::posix_time::time_duration const period = 500_ms;
  boost::posix_time::time_duration const run_time = 10_sec;
  int periods = run_time.total_milliseconds() / period.total_milliseconds();

  PingTrophonius tropho(period);

  using namespace infinit::oracles::trophonius;
  elle::With<reactor::Scope>() << [&] (reactor::Scope& scope)
  {
    std::unique_ptr<Client> client;
    client.reset(new Client(
      "127.0.0.1",
      tropho.port(),
      [] (bool) {}, // connect callback
      [] (void) {}, // reconnection failed callback
      fingerprint)
    );
    scope.run_background("initial poke", [&]
    {
      BOOST_CHECK(client->poke());
      tropho.poked().signal();
    });
    scope.run_background("client", [&]
    {
      reactor::wait(tropho.poked());
      client->ping_period(period);
      client->connect("0", "0", "0");
      reactor::wait(client->connected());
      reactor::sleep(run_time);
    });
    scope.wait(run_time);
    BOOST_CHECK_EQUAL(client->reconnected(), 0);
    BOOST_CHECK_LE(std::abs(tropho.ping_received() - periods), 1);
  };
}

/*--------.
| No ping |
`--------*/

// Check a client not receiving pings reconnects every 2 periods.

class NoPingTrophonius:
  public Trophonius
{
public:
  NoPingTrophonius(boost::posix_time::time_duration const& period):
    Trophonius(),
    _ping_received(0),
    _period(period)
  {}

  ELLE_ATTRIBUTE_R(int, ping_received);

protected:
  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    reactor::wait(this->poked());
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_DEBUG("%s: got connect message: %s",
               *this,
               elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
    auto previous = boost::posix_time::microsec_clock::local_time();
    ELLE_LOG("serving no ping");
    boost::posix_time::time_duration periods;
    try
    {
      while (true)
      {
        auto data_read = elle::json::read(socket);
        auto now = boost::posix_time::microsec_clock::local_time();
        auto ping = boost::any_cast<elle::json::Object>(data_read);
        auto diff = now - previous;
        ELLE_LOG("got ping after %s: %s", diff, elle::json::pretty_print(ping));
        periods += diff;
        previous = now;
        ++this->_ping_received;
      }
    }
    catch(reactor::network::ConnectionClosed const&)
    {
      BOOST_CHECK_LT(periods / this->_ping_received, this->_period * 12 / 10);
      // As the client will not be receiving any pings, it will disconnect
      auto disconnection_time =
        boost::posix_time::microsec_clock::local_time() - previous;
      ELLE_LOG("%s: disconnection after %s", *this, disconnection_time);
      BOOST_CHECK_GE(this->ping_received(), 1);
      BOOST_CHECK_LT(disconnection_time, this->_period * 22 / 10);
    }
  }

private:
  ELLE_ATTRIBUTE(boost::posix_time::time_duration, period);
};

ELLE_TEST_SCHEDULED(no_ping)
{
  boost::posix_time::time_duration const period = 500_ms;
  boost::posix_time::time_duration const run_time = 10_sec;
  int periods = run_time.total_milliseconds() / period.total_milliseconds();

  NoPingTrophonius tropho(period);

  using namespace infinit::oracles::trophonius;
  elle::With<reactor::Scope>() << [&] (reactor::Scope& scope)
  {
    std::unique_ptr<Client> client;
    client.reset(new Client(
      "127.0.0.1",
      tropho.port(),
      [] (bool) {}, // connect callback
      [] (void) {}, // reconnection failed callback
      fingerprint)
    );
    scope.run_background("initial poke", [&]
    {
      BOOST_CHECK(client->poke());
      tropho.poked().signal();
      while (true)
      {
        reactor::wait(client->poked());
        tropho.poked().signal();
      }
    });
    scope.run_background("client", [&]
    {
      reactor::wait(tropho.poked());
      client->ping_period(period);
      client->connect("0", "0", "0");
    });
    scope.wait(run_time);
    // Approximate test as we don't know how long a poke, connect, disconnect
    // cycle will take.
    BOOST_CHECK_LT(std::abs(client->reconnected() - (periods / 2)), 5);
    scope.terminate_now();
  };
}

/*-------------.
| Reconnection |
`-------------*/

// Ensure that we read the correct notification on losing connection and
// reconnecting.

class ReconnectionTrophonius:
  public Trophonius
{
public:
  ReconnectionTrophonius():
    Trophonius(),
    _first(true)
  {}

protected:
  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    reactor::wait(this->poked());
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_DEBUG("%s: got connect message: %s",
               *this,
               elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
    if (this->_first)
    {
      this->_first = false;
      this->_send_notification(socket, "0");
      this->_send_notification(socket, "1");
      ELLE_LOG("wait for disconnection")
      // Read pings until disconnected.
      {
        try
        {
          while (true)
          {
            auto ping = elle::json::read(socket);
          }
        }
        catch (reactor::network::ConnectionClosed const&)
        {}
      }
    }
    else
    {
      this->_send_notification(socket, "2");
      // Wait forever.
      reactor::Scheduler::scheduler()->current()->Waitable::wait();
    }
  }

private:
  ELLE_ATTRIBUTE(bool, first);
};

ELLE_TEST_SCHEDULED(reconnection)
{
  reactor::Barrier reconnecting;
  reactor::Signal end_test;
  bool synchronized = false;
  bool first_connect = true;
  ReconnectionTrophonius tropho;
  using namespace infinit::oracles::trophonius;
  elle::With<reactor::Scope>() << [&] (reactor::Scope& scope)
  {
    std::unique_ptr<Client> client;
    client.reset(new Client(
      "127.0.0.1",
      tropho.port(),
      [&] (bool connected) // connect callback
      {
        if (connected)
        {
          if (first_connect)
          {
            // Wait to check that the client doesn't get notification '2' yet.
            reactor::sleep(1_sec);
            synchronized = true;
            first_connect = false;
          }
        }
        else
        {
          ELLE_LOG("client got disconnected");
          reconnecting.open();
        }
      },
      [] (void) {},  // reconnection failed callback
      fingerprint)
    );
    client->ping_period(1_sec);
    scope.run_background("forward pokes", [&]
    {
      while (true)
      {
        reactor::wait(client->poked());
        tropho.poked().signal();
      }
    });
    scope.run_background("end test", [&]
    {
      reactor::wait(end_test);
      scope.terminate_now();
    });
    scope.run_background("initial poke", [&]
    {
      BOOST_CHECK(client->poke());
      tropho.poked().signal();
    });
    scope.run_background("client", [&]
    {
      reactor::wait(tropho.poked());
      ELLE_LOG("connect");
      client->connect("0", "0", "0");
      ELLE_LOG("read notification 0");
      {
        auto notification =
          elle::cast<MessageNotification>::runtime(client->poll());
          BOOST_CHECK_EQUAL(notification->message, "0");
      }
      reactor::wait(reconnecting);
      reactor::wait(client->connected());
      ELLE_LOG("waited for ping timeout")
      {
        // Check notification 1 was discarded
        ELLE_LOG("read notification 2")
        {
          auto notification =
            elle::cast<MessageNotification>::runtime(client->poll());
          BOOST_CHECK(synchronized);
          BOOST_CHECK_EQUAL(notification->message, "2");
          end_test.signal();
        }
      }
    });
    scope.wait();
    scope.terminate_now();
  };
}

/*---------------------------.
| Connection callback throws |
`---------------------------*/

// Check that the reconnection callback is called and that it throws.

class SilentTrophonius:
  public Trophonius
{
protected:
  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    reactor::wait(this->poked());
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_DEBUG("%s: got connect message: %s",
               *this,
               elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
    // Wait forever.
    reactor::Scheduler::scheduler()->current()->Waitable::wait();
  }
};

ELLE_TEST_SCHEDULED_THROWS(connection_callback_throws, std::runtime_error)
{
  bool beacon = false;
  SilentTrophonius tropho;
  using namespace infinit::oracles::trophonius;
  elle::With<reactor::Scope>() << [&] (reactor::Scope& scope)
  {
    std::unique_ptr<Client> client;
    client.reset(new Client(
      "127.0.0.1",
      tropho.port(),
      [&] (bool connected) // connect callback
      {
        beacon = true;
        throw std::runtime_error("sync failed");
      },
      [] (void) {},  // reconnection failed callback
      fingerprint)
    );
    client->ping_period(100_ms);
    scope.run_background("initial poke", [&]
    {
      BOOST_CHECK(client->poke());
      tropho.poked().signal();
    });
    scope.run_background("client", [&]
    {
      reactor::wait(client->poked());
      ELLE_LOG("connect");
      client->connect("0", "0", "0");
      reactor::sleep(1_sec);
    });
    scope.wait();
  };
  BOOST_CHECK(beacon);
}

/*-----------------------------.
| Reconnection failed callback |
`-----------------------------*/

// Simulate reconnection on different network where there is no access to
// Trophonius, i.e.: server could be resolved but not contacted. This means that
// the reconnection failed callback should be called.

class ReconnectionFailTrophohius:
  public Trophonius
{
public:
  ReconnectionFailTrophohius():
    Trophonius()
  {}

protected:
  virtual
  void
  _handle_connection()
  {
    try
    {
      ELLE_LOG("first connection to server");
      std::unique_ptr<reactor::network::Socket> socket(
        this->server().accept());
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
      auto poke = boost::any_cast<elle::json::Object>(poke_read);
      elle::json::write(*socket, poke);
      ELLE_LOG("%s replied to poke", *this);
      this->_serve(*socket);
    }
    catch (reactor::network::ConnectionClosed const&)
    {
      ELLE_LOG("%s: ignore connection closed on killing accepter", *this);
    }
  }

  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    reactor::wait(this->poked());
    auto connect_data = elle::json::read(socket);
    auto connect_msg = boost::any_cast<elle::json::Object>(connect_data);
    ELLE_DEBUG("%s: got connect message: %s",
               *this,
               elle::json::pretty_print(connect_msg));
    this->_login_response(socket);
  }
};

ELLE_TEST_SCHEDULED(reconnection_failed_callback)
{
  ReconnectionFailTrophohius tropho;
  reactor::Signal end_test;
  bool callback_called = false;
  using namespace infinit::oracles::trophonius;
  elle::With<reactor::Scope>() << [&] (reactor::Scope& scope)
  {
    std::unique_ptr<Client> client;
    client.reset(new Client(
      "127.0.0.1",
      tropho.port(),
      [] (bool) {}, // connect callback
      [&] (void)    // reconnection failed callback
      {
        callback_called = true;
        reactor::Scheduler::scheduler()->terminate();
      },
      fingerprint)
    );
    client->poke_timeout(500_ms);

    client->ping_period(2_sec);
    scope.run_background("initial poke", [&]
    {
      BOOST_CHECK(client->poke());
      tropho.poked().signal();
    });
    scope.run_background("client", [&]
    {
      reactor::wait(tropho.poked());
      ELLE_LOG("connect");
      client->connect("0", "0", "0");
      reactor::sleep();
    });
    scope.wait();
  };
  BOOST_CHECK(callback_called);
}

/*------------------------.
| Close socket after poke |
`------------------------*/

// Test for the following bug: If connection is closed during _connect(), the
// client would never reopen the socket but keep retrying to authenticate in
// a loop.

class SocketClosedTrophonius:
  public Trophonius
{
public:
  SocketClosedTrophonius():
    Trophonius()
  {}

protected:
  virtual
  void
  _handle_connection()
  {
    try
    {
      ELLE_LOG("first connection to server");
      std::unique_ptr<reactor::network::Socket> socket(
        this->server().accept());
      ELLE_TRACE("%s: accept connection from %s", *this, socket->peer());
      auto poke_read = elle::json::read(*socket);
      auto poke = boost::any_cast<elle::json::Object>(poke_read);
      elle::json::write(*socket, poke);
      ELLE_LOG("%s replied to poke", *this);
      this->_serve(*socket);
    }
    catch (reactor::network::ConnectionClosed const&)
    {
      ELLE_LOG("%s: ignore connection closed on killing accepter", *this);
    }
  }

  virtual
  void
  _serve(reactor::network::Socket& socket)
  {
    reactor::wait(this->poked());
    socket.close();
    ELLE_LOG("socket closed");
  }
};

ELLE_TEST_SCHEDULED(socket_close_after_poke)
{
  SocketClosedTrophonius tropho;
  using namespace infinit::oracles::trophonius;
  elle::With<reactor::Scope>() << [&] (reactor::Scope& scope)
  {
    std::unique_ptr<Client> client;
    client.reset(new Client(
      "127.0.0.1",
      tropho.port(),
      [] (bool) {}, // connect callback
      [] (void) {}, // reconnection failed callback
      fingerprint)
    );

    client->ping_period(200_ms);
    scope.run_background("initial poke", [&]
    {
      BOOST_CHECK(client->poke());
      tropho.poked().signal();
    });
    scope.run_background("client", [&]
    {
      reactor::wait(tropho.poked());
      ELLE_LOG("try to connect"); // should fail immediately
      BOOST_CHECK(!client->connect("0", "0", "0"));
    });
    scope.wait();
  };
}

// Test sending a notification and disconnecting concurrently. This use to
// assert !this->_notifications.empty() because the poll thread would wake up
// but the disconnection would empty the notifications before it is executed.

class NotifyDisconnectTrophonius
  : public Trophonius
{
public:
  NotifyDisconnectTrophonius()
    : Trophonius()
  {}

protected:
  virtual
  void
  _serve(reactor::network::Socket& socket) override
  {
    ELLE_LOG("%s: get login", *this);
    auto connect_data = elle::json::read(socket);
    ELLE_LOG("%s: answer login", *this);
    this->_login_response(socket);
    ELLE_LOG("%s: send notification", *this);
    this->_send_notification(socket, "poke");
  }
};

ELLE_TEST_SCHEDULED(notify_disconnect)
{
  NotifyDisconnectTrophonius tropho;
  infinit::oracles::trophonius::Client client(
    "127.0.0.1",
    tropho.port(),
    [&client] (bool connected)
    {
      if (!connected)
        client.ping_period(30_sec);
    },
    [] (void) {},
    fingerprint);
  client.ping_period(0_sec);
  BOOST_CHECK(client.poke());
  tropho.poked().signal();
  client.connect("0", "0", "0");
  ELLE_LOG("%s: poll", client)
    client.poll();
}

// Test suite

ELLE_TEST_SUITE()
{
  auto timeout = RUNNING_ON_VALGRIND ? 15 : 3;
  auto& suite = boost::unit_test::framework::master_test_suite();
  suite.add(BOOST_TEST_CASE(poke), 0, timeout);
  suite.add(BOOST_TEST_CASE(notification), 0, timeout);
  suite.add(BOOST_TEST_CASE(ping), 0, 5 * timeout);
  suite.add(BOOST_TEST_CASE(no_ping), 0, 5 * timeout);
  suite.add(BOOST_TEST_CASE(reconnection), 0, 2 * timeout);
  suite.add(BOOST_TEST_CASE(connection_callback_throws), 0, timeout);
  suite.add(BOOST_TEST_CASE(reconnection_failed_callback), 0, 2 * timeout);
  suite.add(BOOST_TEST_CASE(socket_close_after_poke), 0, timeout);
  suite.add(BOOST_TEST_CASE(notify_disconnect), 0, timeout);
}

const std::vector<unsigned char> fingerprint =
{
  0x66, 0x84, 0x68, 0xEB, 0xBE, 0x83, 0xA0, 0x5C, 0x6A, 0x32,
  0xAD, 0xD2, 0x58, 0x62, 0x01, 0x31, 0x79, 0x96, 0x78, 0xB8
};

const std::vector<char> server_certificate =
{
  0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x44, 0x61, 0x74, 0x61, 0x3a, 0x0a, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69,
  0x6f, 0x6e, 0x3a, 0x20, 0x33, 0x20, 0x28, 0x30, 0x78, 0x32, 0x29, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x65, 0x72, 0x69,
  0x61, 0x6c, 0x20, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x3a, 0x20, 0x34,
  0x30, 0x39, 0x36, 0x20, 0x28, 0x30, 0x78, 0x31, 0x30, 0x30, 0x30, 0x29,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,
  0x72, 0x65, 0x20, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d,
  0x3a, 0x20, 0x73, 0x68, 0x61, 0x31, 0x57, 0x69, 0x74, 0x68, 0x52, 0x53,
  0x41, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x49, 0x73, 0x73, 0x75,
  0x65, 0x72, 0x3a, 0x20, 0x43, 0x3d, 0x46, 0x52, 0x2c, 0x20, 0x53, 0x54,
  0x3d, 0x49, 0x6c, 0x65, 0x2d, 0x64, 0x65, 0x2d, 0x46, 0x72, 0x61, 0x6e,
  0x63, 0x65, 0x2c, 0x20, 0x4c, 0x3d, 0x50, 0x61, 0x72, 0x69, 0x73, 0x2c,
  0x20, 0x4f, 0x3d, 0x49, 0x6e, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x2e, 0x69,
  0x6f, 0x2c, 0x20, 0x4f, 0x55, 0x3d, 0x44, 0x65, 0x76, 0x65, 0x6c, 0x6f,
  0x70, 0x6d, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x43, 0x4e, 0x3d, 0x4c, 0x6f,
  0x75, 0x69, 0x73, 0x20, 0x46, 0x45, 0x55, 0x56, 0x52, 0x49, 0x45, 0x52,
  0x2f, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
  0x73, 0x3d, 0x6c, 0x6f, 0x75, 0x69, 0x73, 0x2e, 0x66, 0x65, 0x75, 0x76,
  0x72, 0x69, 0x65, 0x72, 0x40, 0x69, 0x6e, 0x66, 0x69, 0x6e, 0x69, 0x74,
  0x2e, 0x69, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x56, 0x61, 0x6c, 0x69, 0x64, 0x69, 0x74, 0x79, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4e, 0x6f, 0x74,
  0x20, 0x42, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x3a, 0x20, 0x44, 0x65, 0x63,
  0x20, 0x20, 0x35, 0x20, 0x31, 0x30, 0x3a, 0x35, 0x39, 0x3a, 0x34, 0x38,
  0x20, 0x32, 0x30, 0x31, 0x33, 0x20, 0x47, 0x4d, 0x54, 0x0a, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4e, 0x6f,
  0x74, 0x20, 0x41, 0x66, 0x74, 0x65, 0x72, 0x20, 0x3a, 0x20, 0x44, 0x65,
  0x63, 0x20, 0x20, 0x35, 0x20, 0x31, 0x30, 0x3a, 0x35, 0x39, 0x3a, 0x34,
  0x38, 0x20, 0x32, 0x30, 0x31, 0x34, 0x20, 0x47, 0x4d, 0x54, 0x0a, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x75, 0x62, 0x6a, 0x65,
  0x63, 0x74, 0x3a, 0x20, 0x43, 0x3d, 0x46, 0x52, 0x2c, 0x20, 0x53, 0x54,
  0x3d, 0x49, 0x6c, 0x65, 0x2d, 0x64, 0x65, 0x2d, 0x46, 0x72, 0x61, 0x6e,
  0x63, 0x65, 0x2c, 0x20, 0x4f, 0x3d, 0x49, 0x6e, 0x66, 0x69, 0x6e, 0x69,
  0x74, 0x2e, 0x69, 0x6f, 0x2c, 0x20, 0x4f, 0x55, 0x3d, 0x44, 0x65, 0x76,
  0x65, 0x6c, 0x6f, 0x70, 0x6d, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x43, 0x4e,
  0x3d, 0x4c, 0x6f, 0x75, 0x69, 0x73, 0x20, 0x46, 0x45, 0x55, 0x56, 0x52,
  0x49, 0x45, 0x52, 0x2f, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x41, 0x64, 0x64,
  0x72, 0x65, 0x73, 0x73, 0x3d, 0x6c, 0x6f, 0x75, 0x69, 0x73, 0x2e, 0x66,
  0x65, 0x75, 0x76, 0x72, 0x69, 0x65, 0x72, 0x40, 0x69, 0x6e, 0x66, 0x69,
  0x6e, 0x69, 0x74, 0x2e, 0x69, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x53, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x50,
  0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x4b, 0x65, 0x79, 0x20, 0x49, 0x6e,
  0x66, 0x6f, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x4b,
  0x65, 0x79, 0x20, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d,
  0x3a, 0x20, 0x72, 0x73, 0x61, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,
  0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x50, 0x75, 0x62, 0x6c,
  0x69, 0x63, 0x2d, 0x4b, 0x65, 0x79, 0x3a, 0x20, 0x28, 0x31, 0x30, 0x32,
  0x34, 0x20, 0x62, 0x69, 0x74, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4d,
  0x6f, 0x64, 0x75, 0x6c, 0x75, 0x73, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x30, 0x30, 0x3a, 0x64, 0x30, 0x3a, 0x66, 0x66,
  0x3a, 0x61, 0x30, 0x3a, 0x34, 0x34, 0x3a, 0x63, 0x66, 0x3a, 0x65, 0x35,
  0x3a, 0x30, 0x65, 0x3a, 0x63, 0x34, 0x3a, 0x62, 0x66, 0x3a, 0x32, 0x32,
  0x3a, 0x35, 0x33, 0x3a, 0x64, 0x38, 0x3a, 0x30, 0x65, 0x3a, 0x36, 0x39,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x61,
  0x3a, 0x31, 0x61, 0x3a, 0x33, 0x65, 0x3a, 0x31, 0x64, 0x3a, 0x37, 0x38,
  0x3a, 0x63, 0x39, 0x3a, 0x35, 0x32, 0x3a, 0x38, 0x35, 0x3a, 0x38, 0x30,
  0x3a, 0x31, 0x63, 0x3a, 0x65, 0x35, 0x3a, 0x65, 0x64, 0x3a, 0x66, 0x35,
  0x3a, 0x32, 0x62, 0x3a, 0x30, 0x37, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x66, 0x63, 0x3a, 0x63, 0x37, 0x3a, 0x32, 0x62,
  0x3a, 0x63, 0x61, 0x3a, 0x31, 0x38, 0x3a, 0x37, 0x35, 0x3a, 0x66, 0x37,
  0x3a, 0x39, 0x31, 0x3a, 0x35, 0x61, 0x3a, 0x39, 0x32, 0x3a, 0x37, 0x39,
  0x3a, 0x35, 0x35, 0x3a, 0x66, 0x36, 0x3a, 0x65, 0x39, 0x3a, 0x34, 0x32,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x30,
  0x3a, 0x65, 0x30, 0x3a, 0x61, 0x33, 0x3a, 0x64, 0x66, 0x3a, 0x66, 0x62,
  0x3a, 0x33, 0x65, 0x3a, 0x62, 0x34, 0x3a, 0x34, 0x32, 0x3a, 0x64, 0x30,
  0x3a, 0x34, 0x62, 0x3a, 0x66, 0x35, 0x3a, 0x65, 0x62, 0x3a, 0x30, 0x35,
  0x3a, 0x34, 0x34, 0x3a, 0x33, 0x32, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x32, 0x63, 0x3a, 0x34, 0x61, 0x3a, 0x38, 0x35,
  0x3a, 0x64, 0x30, 0x3a, 0x65, 0x31, 0x3a, 0x61, 0x33, 0x3a, 0x36, 0x63,
  0x3a, 0x61, 0x61, 0x3a, 0x66, 0x30, 0x3a, 0x30, 0x31, 0x3a, 0x66, 0x37,
  0x3a, 0x31, 0x32, 0x3a, 0x63, 0x34, 0x3a, 0x30, 0x65, 0x3a, 0x66, 0x66,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x30,
  0x3a, 0x61, 0x31, 0x3a, 0x37, 0x34, 0x3a, 0x64, 0x32, 0x3a, 0x36, 0x35,
  0x3a, 0x32, 0x30, 0x3a, 0x64, 0x62, 0x3a, 0x35, 0x61, 0x3a, 0x30, 0x33,
  0x3a, 0x37, 0x38, 0x3a, 0x63, 0x37, 0x3a, 0x35, 0x34, 0x3a, 0x61, 0x31,
  0x3a, 0x62, 0x63, 0x3a, 0x64, 0x37, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x38, 0x33, 0x3a, 0x66, 0x66, 0x3a, 0x39, 0x37,
  0x3a, 0x37, 0x38, 0x3a, 0x62, 0x64, 0x3a, 0x31, 0x34, 0x3a, 0x64, 0x36,
  0x3a, 0x35, 0x31, 0x3a, 0x33, 0x35, 0x3a, 0x62, 0x61, 0x3a, 0x36, 0x30,
  0x3a, 0x31, 0x62, 0x3a, 0x66, 0x66, 0x3a, 0x39, 0x34, 0x3a, 0x62, 0x66,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x37, 0x65,
  0x3a, 0x34, 0x63, 0x3a, 0x34, 0x34, 0x3a, 0x61, 0x62, 0x3a, 0x63, 0x63,
  0x3a, 0x62, 0x36, 0x3a, 0x39, 0x33, 0x3a, 0x30, 0x63, 0x3a, 0x36, 0x61,
  0x3a, 0x35, 0x66, 0x3a, 0x38, 0x36, 0x3a, 0x38, 0x65, 0x3a, 0x32, 0x38,
  0x3a, 0x36, 0x62, 0x3a, 0x39, 0x31, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x65, 0x64, 0x3a, 0x32, 0x38, 0x3a, 0x62, 0x61,
  0x3a, 0x34, 0x61, 0x3a, 0x36, 0x66, 0x3a, 0x34, 0x66, 0x3a, 0x33, 0x33,
  0x3a, 0x33, 0x66, 0x3a, 0x34, 0x35, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x45,
  0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x3a, 0x20, 0x36, 0x35, 0x35,
  0x33, 0x37, 0x20, 0x28, 0x30, 0x78, 0x31, 0x30, 0x30, 0x30, 0x31, 0x29,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x58, 0x35, 0x30,
  0x39, 0x76, 0x33, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f,
  0x6e, 0x73, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x58, 0x35, 0x30, 0x39, 0x76, 0x33, 0x20, 0x42,
  0x61, 0x73, 0x69, 0x63, 0x20, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61,
  0x69, 0x6e, 0x74, 0x73, 0x3a, 0x20, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x43,
  0x41, 0x3a, 0x46, 0x41, 0x4c, 0x53, 0x45, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4e, 0x65, 0x74, 0x73,
  0x63, 0x61, 0x70, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74,
  0x3a, 0x20, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4f, 0x70, 0x65, 0x6e, 0x53,
  0x53, 0x4c, 0x20, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64,
  0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x58, 0x35, 0x30, 0x39, 0x76, 0x33, 0x20, 0x53, 0x75, 0x62, 0x6a,
  0x65, 0x63, 0x74, 0x20, 0x4b, 0x65, 0x79, 0x20, 0x49, 0x64, 0x65, 0x6e,
  0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x3a, 0x20, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x44, 0x35, 0x3a, 0x35, 0x44, 0x3a, 0x43, 0x36, 0x3a, 0x32, 0x43,
  0x3a, 0x41, 0x42, 0x3a, 0x31, 0x46, 0x3a, 0x42, 0x44, 0x3a, 0x32, 0x41,
  0x3a, 0x35, 0x42, 0x3a, 0x45, 0x38, 0x3a, 0x34, 0x46, 0x3a, 0x43, 0x36,
  0x3a, 0x36, 0x38, 0x3a, 0x42, 0x38, 0x3a, 0x42, 0x42, 0x3a, 0x33, 0x32,
  0x3a, 0x38, 0x37, 0x3a, 0x44, 0x34, 0x3a, 0x31, 0x44, 0x3a, 0x45, 0x35,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x58, 0x35, 0x30, 0x39, 0x76, 0x33, 0x20, 0x41, 0x75, 0x74, 0x68,
  0x6f, 0x72, 0x69, 0x74, 0x79, 0x20, 0x4b, 0x65, 0x79, 0x20, 0x49, 0x64,
  0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x3a, 0x20, 0x0a, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x6b, 0x65, 0x79, 0x69, 0x64, 0x3a, 0x33, 0x37, 0x3a,
  0x38, 0x38, 0x3a, 0x37, 0x35, 0x3a, 0x43, 0x33, 0x3a, 0x34, 0x45, 0x3a,
  0x34, 0x42, 0x3a, 0x31, 0x33, 0x3a, 0x46, 0x33, 0x3a, 0x30, 0x32, 0x3a,
  0x37, 0x46, 0x3a, 0x30, 0x43, 0x3a, 0x42, 0x44, 0x3a, 0x44, 0x30, 0x3a,
  0x39, 0x43, 0x3a, 0x38, 0x35, 0x3a, 0x34, 0x36, 0x3a, 0x46, 0x39, 0x3a,
  0x42, 0x46, 0x3a, 0x34, 0x31, 0x3a, 0x44, 0x46, 0x0a, 0x0a, 0x20, 0x20,
  0x20, 0x20, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x20,
  0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x3a, 0x20, 0x73,
  0x68, 0x61, 0x31, 0x57, 0x69, 0x74, 0x68, 0x52, 0x53, 0x41, 0x45, 0x6e,
  0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x32, 0x61, 0x3a, 0x36, 0x35, 0x3a,
  0x63, 0x39, 0x3a, 0x33, 0x31, 0x3a, 0x66, 0x39, 0x3a, 0x65, 0x66, 0x3a,
  0x62, 0x35, 0x3a, 0x37, 0x37, 0x3a, 0x65, 0x37, 0x3a, 0x37, 0x36, 0x3a,
  0x66, 0x61, 0x3a, 0x30, 0x63, 0x3a, 0x34, 0x39, 0x3a, 0x64, 0x61, 0x3a,
  0x33, 0x33, 0x3a, 0x36, 0x33, 0x3a, 0x61, 0x38, 0x3a, 0x35, 0x38, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x33,
  0x3a, 0x38, 0x31, 0x3a, 0x64, 0x61, 0x3a, 0x64, 0x37, 0x3a, 0x37, 0x32,
  0x3a, 0x36, 0x35, 0x3a, 0x66, 0x39, 0x3a, 0x39, 0x63, 0x3a, 0x30, 0x36,
  0x3a, 0x65, 0x31, 0x3a, 0x39, 0x36, 0x3a, 0x36, 0x36, 0x3a, 0x66, 0x63,
  0x3a, 0x38, 0x38, 0x3a, 0x61, 0x38, 0x3a, 0x63, 0x34, 0x3a, 0x31, 0x63,
  0x3a, 0x38, 0x66, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x62, 0x65, 0x3a, 0x36, 0x36, 0x3a, 0x39, 0x38, 0x3a, 0x33,
  0x64, 0x3a, 0x64, 0x62, 0x3a, 0x61, 0x65, 0x3a, 0x36, 0x32, 0x3a, 0x63,
  0x33, 0x3a, 0x66, 0x63, 0x3a, 0x37, 0x32, 0x3a, 0x66, 0x63, 0x3a, 0x32,
  0x62, 0x3a, 0x64, 0x37, 0x3a, 0x36, 0x63, 0x3a, 0x39, 0x37, 0x3a, 0x30,
  0x65, 0x3a, 0x31, 0x63, 0x3a, 0x35, 0x32, 0x3a, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x39, 0x3a, 0x63, 0x63, 0x3a,
  0x66, 0x64, 0x3a, 0x65, 0x35, 0x3a, 0x66, 0x32, 0x3a, 0x65, 0x39, 0x3a,
  0x62, 0x36, 0x3a, 0x65, 0x31, 0x3a, 0x31, 0x38, 0x3a, 0x31, 0x30, 0x3a,
  0x33, 0x32, 0x3a, 0x36, 0x63, 0x3a, 0x31, 0x35, 0x3a, 0x38, 0x66, 0x3a,
  0x36, 0x63, 0x3a, 0x61, 0x34, 0x3a, 0x32, 0x64, 0x3a, 0x64, 0x35, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x31,
  0x3a, 0x35, 0x39, 0x3a, 0x38, 0x31, 0x3a, 0x39, 0x65, 0x3a, 0x37, 0x34,
  0x3a, 0x62, 0x32, 0x3a, 0x66, 0x35, 0x3a, 0x64, 0x35, 0x3a, 0x34, 0x37,
  0x3a, 0x38, 0x32, 0x3a, 0x34, 0x32, 0x3a, 0x32, 0x61, 0x3a, 0x31, 0x36,
  0x3a, 0x35, 0x32, 0x3a, 0x38, 0x32, 0x3a, 0x30, 0x61, 0x3a, 0x62, 0x63,
  0x3a, 0x32, 0x61, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x37, 0x33, 0x3a, 0x30, 0x39, 0x3a, 0x66, 0x65, 0x3a, 0x38,
  0x63, 0x3a, 0x61, 0x36, 0x3a, 0x34, 0x30, 0x3a, 0x30, 0x63, 0x3a, 0x34,
  0x39, 0x3a, 0x30, 0x36, 0x3a, 0x66, 0x62, 0x3a, 0x31, 0x34, 0x3a, 0x66,
  0x62, 0x3a, 0x35, 0x38, 0x3a, 0x63, 0x30, 0x3a, 0x34, 0x66, 0x3a, 0x36,
  0x32, 0x3a, 0x33, 0x63, 0x3a, 0x65, 0x30, 0x3a, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x61, 0x3a, 0x62, 0x36, 0x3a,
  0x63, 0x38, 0x3a, 0x36, 0x36, 0x3a, 0x38, 0x64, 0x3a, 0x37, 0x37, 0x3a,
  0x63, 0x30, 0x3a, 0x36, 0x62, 0x3a, 0x36, 0x61, 0x3a, 0x64, 0x32, 0x3a,
  0x37, 0x33, 0x3a, 0x39, 0x37, 0x3a, 0x61, 0x35, 0x3a, 0x33, 0x33, 0x3a,
  0x30, 0x63, 0x3a, 0x62, 0x33, 0x3a, 0x64, 0x33, 0x3a, 0x34, 0x62, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x39,
  0x3a, 0x39, 0x33, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47,
  0x49, 0x4e, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41,
  0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x44,
  0x4b, 0x6a, 0x43, 0x43, 0x41, 0x70, 0x4f, 0x67, 0x41, 0x77, 0x49, 0x42,
  0x41, 0x67, 0x49, 0x43, 0x45, 0x41, 0x41, 0x77, 0x44, 0x51, 0x59, 0x4a,
  0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x46,
  0x42, 0x51, 0x41, 0x77, 0x67, 0x61, 0x4d, 0x78, 0x43, 0x7a, 0x41, 0x4a,
  0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59, 0x54, 0x41, 0x6b, 0x5a, 0x53,
  0x0a, 0x4d, 0x52, 0x59, 0x77, 0x46, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51,
  0x49, 0x44, 0x41, 0x31, 0x4a, 0x62, 0x47, 0x55, 0x74, 0x5a, 0x47, 0x55,
  0x74, 0x52, 0x6e, 0x4a, 0x68, 0x62, 0x6d, 0x4e, 0x6c, 0x4d, 0x51, 0x34,
  0x77, 0x44, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51, 0x48, 0x44, 0x41, 0x56,
  0x51, 0x59, 0x58, 0x4a, 0x70, 0x63, 0x7a, 0x45, 0x54, 0x4d, 0x42, 0x45,
  0x47, 0x41, 0x31, 0x55, 0x45, 0x0a, 0x43, 0x67, 0x77, 0x4b, 0x53, 0x57,
  0x35, 0x6d, 0x61, 0x57, 0x35, 0x70, 0x64, 0x43, 0x35, 0x70, 0x62, 0x7a,
  0x45, 0x55, 0x4d, 0x42, 0x49, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x77,
  0x77, 0x4c, 0x52, 0x47, 0x56, 0x32, 0x5a, 0x57, 0x78, 0x76, 0x63, 0x47,
  0x31, 0x6c, 0x62, 0x6e, 0x51, 0x78, 0x46, 0x7a, 0x41, 0x56, 0x42, 0x67,
  0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x44, 0x6b, 0x78, 0x76, 0x0a, 0x64,
  0x57, 0x6c, 0x7a, 0x49, 0x45, 0x5a, 0x46, 0x56, 0x56, 0x5a, 0x53, 0x53,
  0x55, 0x56, 0x53, 0x4d, 0x53, 0x67, 0x77, 0x4a, 0x67, 0x59, 0x4a, 0x4b,
  0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x6b, 0x42, 0x46,
  0x68, 0x6c, 0x73, 0x62, 0x33, 0x56, 0x70, 0x63, 0x79, 0x35, 0x6d, 0x5a,
  0x58, 0x56, 0x32, 0x63, 0x6d, 0x6c, 0x6c, 0x63, 0x6b, 0x42, 0x70, 0x62,
  0x6d, 0x5a, 0x70, 0x0a, 0x62, 0x6d, 0x6c, 0x30, 0x4c, 0x6d, 0x6c, 0x76,
  0x4d, 0x42, 0x34, 0x58, 0x44, 0x54, 0x45, 0x7a, 0x4d, 0x54, 0x49, 0x77,
  0x4e, 0x54, 0x45, 0x77, 0x4e, 0x54, 0x6b, 0x30, 0x4f, 0x46, 0x6f, 0x58,
  0x44, 0x54, 0x45, 0x30, 0x4d, 0x54, 0x49, 0x77, 0x4e, 0x54, 0x45, 0x77,
  0x4e, 0x54, 0x6b, 0x30, 0x4f, 0x46, 0x6f, 0x77, 0x67, 0x5a, 0x4d, 0x78,
  0x43, 0x7a, 0x41, 0x4a, 0x42, 0x67, 0x4e, 0x56, 0x0a, 0x42, 0x41, 0x59,
  0x54, 0x41, 0x6b, 0x5a, 0x53, 0x4d, 0x52, 0x59, 0x77, 0x46, 0x41, 0x59,
  0x44, 0x56, 0x51, 0x51, 0x49, 0x44, 0x41, 0x31, 0x4a, 0x62, 0x47, 0x55,
  0x74, 0x5a, 0x47, 0x55, 0x74, 0x52, 0x6e, 0x4a, 0x68, 0x62, 0x6d, 0x4e,
  0x6c, 0x4d, 0x52, 0x4d, 0x77, 0x45, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51,
  0x4b, 0x44, 0x41, 0x70, 0x4a, 0x62, 0x6d, 0x5a, 0x70, 0x62, 0x6d, 0x6c,
  0x30, 0x0a, 0x4c, 0x6d, 0x6c, 0x76, 0x4d, 0x52, 0x51, 0x77, 0x45, 0x67,
  0x59, 0x44, 0x56, 0x51, 0x51, 0x4c, 0x44, 0x41, 0x74, 0x45, 0x5a, 0x58,
  0x5a, 0x6c, 0x62, 0x47, 0x39, 0x77, 0x62, 0x57, 0x56, 0x75, 0x64, 0x44,
  0x45, 0x58, 0x4d, 0x42, 0x55, 0x47, 0x41, 0x31, 0x55, 0x45, 0x41, 0x77,
  0x77, 0x4f, 0x54, 0x47, 0x39, 0x31, 0x61, 0x58, 0x4d, 0x67, 0x52, 0x6b,
  0x56, 0x56, 0x56, 0x6c, 0x4a, 0x4a, 0x0a, 0x52, 0x56, 0x49, 0x78, 0x4b,
  0x44, 0x41, 0x6d, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39,
  0x77, 0x30, 0x42, 0x43, 0x51, 0x45, 0x57, 0x47, 0x57, 0x78, 0x76, 0x64,
  0x57, 0x6c, 0x7a, 0x4c, 0x6d, 0x5a, 0x6c, 0x64, 0x58, 0x5a, 0x79, 0x61,
  0x57, 0x56, 0x79, 0x51, 0x47, 0x6c, 0x75, 0x5a, 0x6d, 0x6c, 0x75, 0x61,
  0x58, 0x51, 0x75, 0x61, 0x57, 0x38, 0x77, 0x67, 0x5a, 0x38, 0x77, 0x0a,
  0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e,
  0x41, 0x51, 0x45, 0x42, 0x42, 0x51, 0x41, 0x44, 0x67, 0x59, 0x30, 0x41,
  0x4d, 0x49, 0x47, 0x4a, 0x41, 0x6f, 0x47, 0x42, 0x41, 0x4e, 0x44, 0x2f,
  0x6f, 0x45, 0x54, 0x50, 0x35, 0x51, 0x37, 0x45, 0x76, 0x79, 0x4a, 0x54,
  0x32, 0x41, 0x35, 0x70, 0x57, 0x68, 0x6f, 0x2b, 0x48, 0x58, 0x6a, 0x4a,
  0x55, 0x6f, 0x57, 0x41, 0x0a, 0x48, 0x4f, 0x58, 0x74, 0x39, 0x53, 0x73,
  0x48, 0x2f, 0x4d, 0x63, 0x72, 0x79, 0x68, 0x68, 0x31, 0x39, 0x35, 0x46,
  0x61, 0x6b, 0x6e, 0x6c, 0x56, 0x39, 0x75, 0x6c, 0x43, 0x34, 0x4f, 0x43,
  0x6a, 0x33, 0x2f, 0x73, 0x2b, 0x74, 0x45, 0x4c, 0x51, 0x53, 0x2f, 0x58,
  0x72, 0x42, 0x55, 0x51, 0x79, 0x4c, 0x45, 0x71, 0x46, 0x30, 0x4f, 0x47,
  0x6a, 0x62, 0x4b, 0x72, 0x77, 0x41, 0x66, 0x63, 0x53, 0x0a, 0x78, 0x41,
  0x37, 0x2f, 0x41, 0x4b, 0x46, 0x30, 0x30, 0x6d, 0x55, 0x67, 0x32, 0x31,
  0x6f, 0x44, 0x65, 0x4d, 0x64, 0x55, 0x6f, 0x62, 0x7a, 0x58, 0x67, 0x2f,
  0x2b, 0x58, 0x65, 0x4c, 0x30, 0x55, 0x31, 0x6c, 0x45, 0x31, 0x75, 0x6d,
  0x41, 0x62, 0x2f, 0x35, 0x53, 0x2f, 0x66, 0x6b, 0x78, 0x45, 0x71, 0x38,
  0x79, 0x32, 0x6b, 0x77, 0x78, 0x71, 0x58, 0x34, 0x61, 0x4f, 0x4b, 0x47,
  0x75, 0x52, 0x0a, 0x37, 0x53, 0x69, 0x36, 0x53, 0x6d, 0x39, 0x50, 0x4d,
  0x7a, 0x39, 0x46, 0x41, 0x67, 0x4d, 0x42, 0x41, 0x41, 0x47, 0x6a, 0x65,
  0x7a, 0x42, 0x35, 0x4d, 0x41, 0x6b, 0x47, 0x41, 0x31, 0x55, 0x64, 0x45,
  0x77, 0x51, 0x43, 0x4d, 0x41, 0x41, 0x77, 0x4c, 0x41, 0x59, 0x4a, 0x59,
  0x49, 0x5a, 0x49, 0x41, 0x59, 0x62, 0x34, 0x51, 0x67, 0x45, 0x4e, 0x42,
  0x42, 0x38, 0x57, 0x48, 0x55, 0x39, 0x77, 0x0a, 0x5a, 0x57, 0x35, 0x54,
  0x55, 0x30, 0x77, 0x67, 0x52, 0x32, 0x56, 0x75, 0x5a, 0x58, 0x4a, 0x68,
  0x64, 0x47, 0x56, 0x6b, 0x49, 0x45, 0x4e, 0x6c, 0x63, 0x6e, 0x52, 0x70,
  0x5a, 0x6d, 0x6c, 0x6a, 0x59, 0x58, 0x52, 0x6c, 0x4d, 0x42, 0x30, 0x47,
  0x41, 0x31, 0x55, 0x64, 0x44, 0x67, 0x51, 0x57, 0x42, 0x42, 0x54, 0x56,
  0x58, 0x63, 0x59, 0x73, 0x71, 0x78, 0x2b, 0x39, 0x4b, 0x6c, 0x76, 0x6f,
  0x0a, 0x54, 0x38, 0x5a, 0x6f, 0x75, 0x4c, 0x73, 0x79, 0x68, 0x39, 0x51,
  0x64, 0x35, 0x54, 0x41, 0x66, 0x42, 0x67, 0x4e, 0x56, 0x48, 0x53, 0x4d,
  0x45, 0x47, 0x44, 0x41, 0x57, 0x67, 0x42, 0x51, 0x33, 0x69, 0x48, 0x58,
  0x44, 0x54, 0x6b, 0x73, 0x54, 0x38, 0x77, 0x4a, 0x2f, 0x44, 0x4c, 0x33,
  0x51, 0x6e, 0x49, 0x56, 0x47, 0x2b, 0x62, 0x39, 0x42, 0x33, 0x7a, 0x41,
  0x4e, 0x42, 0x67, 0x6b, 0x71, 0x0a, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77,
  0x30, 0x42, 0x41, 0x51, 0x55, 0x46, 0x41, 0x41, 0x4f, 0x42, 0x67, 0x51,
  0x41, 0x71, 0x5a, 0x63, 0x6b, 0x78, 0x2b, 0x65, 0x2b, 0x31, 0x64, 0x2b,
  0x64, 0x32, 0x2b, 0x67, 0x78, 0x4a, 0x32, 0x6a, 0x4e, 0x6a, 0x71, 0x46,
  0x69, 0x44, 0x67, 0x64, 0x72, 0x58, 0x63, 0x6d, 0x58, 0x35, 0x6e, 0x41,
  0x62, 0x68, 0x6c, 0x6d, 0x62, 0x38, 0x69, 0x4b, 0x6a, 0x45, 0x0a, 0x48,
  0x49, 0x2b, 0x2b, 0x5a, 0x70, 0x67, 0x39, 0x32, 0x36, 0x35, 0x69, 0x77,
  0x2f, 0x78, 0x79, 0x2f, 0x43, 0x76, 0x58, 0x62, 0x4a, 0x63, 0x4f, 0x48,
  0x46, 0x4c, 0x35, 0x7a, 0x50, 0x33, 0x6c, 0x38, 0x75, 0x6d, 0x32, 0x34,
  0x52, 0x67, 0x51, 0x4d, 0x6d, 0x77, 0x56, 0x6a, 0x32, 0x79, 0x6b, 0x4c,
  0x64, 0x58, 0x42, 0x57, 0x59, 0x47, 0x65, 0x64, 0x4c, 0x4c, 0x31, 0x31,
  0x55, 0x65, 0x43, 0x0a, 0x51, 0x69, 0x6f, 0x57, 0x55, 0x6f, 0x49, 0x4b,
  0x76, 0x43, 0x70, 0x7a, 0x43, 0x66, 0x36, 0x4d, 0x70, 0x6b, 0x41, 0x4d,
  0x53, 0x51, 0x62, 0x37, 0x46, 0x50, 0x74, 0x59, 0x77, 0x45, 0x39, 0x69,
  0x50, 0x4f, 0x44, 0x4b, 0x74, 0x73, 0x68, 0x6d, 0x6a, 0x58, 0x66, 0x41,
  0x61, 0x32, 0x72, 0x53, 0x63, 0x35, 0x65, 0x6c, 0x4d, 0x77, 0x79, 0x7a,
  0x30, 0x30, 0x73, 0x4a, 0x6b, 0x77, 0x3d, 0x3d, 0x0a, 0x2d, 0x2d, 0x2d,
  0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46,
  0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a,
};

const std::vector<char> server_key =
{
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50,
  0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d,
  0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x43, 0x65, 0x41, 0x49, 0x42,
  0x41, 0x44, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47,
  0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x45, 0x46, 0x41, 0x41, 0x53, 0x43,
  0x41, 0x6d, 0x49, 0x77, 0x67, 0x67, 0x4a, 0x65, 0x41, 0x67, 0x45, 0x41,
  0x41, 0x6f, 0x47, 0x42, 0x41, 0x4e, 0x44, 0x2f, 0x6f, 0x45, 0x54, 0x50,
  0x35, 0x51, 0x37, 0x45, 0x76, 0x79, 0x4a, 0x54, 0x0a, 0x32, 0x41, 0x35,
  0x70, 0x57, 0x68, 0x6f, 0x2b, 0x48, 0x58, 0x6a, 0x4a, 0x55, 0x6f, 0x57,
  0x41, 0x48, 0x4f, 0x58, 0x74, 0x39, 0x53, 0x73, 0x48, 0x2f, 0x4d, 0x63,
  0x72, 0x79, 0x68, 0x68, 0x31, 0x39, 0x35, 0x46, 0x61, 0x6b, 0x6e, 0x6c,
  0x56, 0x39, 0x75, 0x6c, 0x43, 0x34, 0x4f, 0x43, 0x6a, 0x33, 0x2f, 0x73,
  0x2b, 0x74, 0x45, 0x4c, 0x51, 0x53, 0x2f, 0x58, 0x72, 0x42, 0x55, 0x51,
  0x79, 0x0a, 0x4c, 0x45, 0x71, 0x46, 0x30, 0x4f, 0x47, 0x6a, 0x62, 0x4b,
  0x72, 0x77, 0x41, 0x66, 0x63, 0x53, 0x78, 0x41, 0x37, 0x2f, 0x41, 0x4b,
  0x46, 0x30, 0x30, 0x6d, 0x55, 0x67, 0x32, 0x31, 0x6f, 0x44, 0x65, 0x4d,
  0x64, 0x55, 0x6f, 0x62, 0x7a, 0x58, 0x67, 0x2f, 0x2b, 0x58, 0x65, 0x4c,
  0x30, 0x55, 0x31, 0x6c, 0x45, 0x31, 0x75, 0x6d, 0x41, 0x62, 0x2f, 0x35,
  0x53, 0x2f, 0x66, 0x6b, 0x78, 0x45, 0x0a, 0x71, 0x38, 0x79, 0x32, 0x6b,
  0x77, 0x78, 0x71, 0x58, 0x34, 0x61, 0x4f, 0x4b, 0x47, 0x75, 0x52, 0x37,
  0x53, 0x69, 0x36, 0x53, 0x6d, 0x39, 0x50, 0x4d, 0x7a, 0x39, 0x46, 0x41,
  0x67, 0x4d, 0x42, 0x41, 0x41, 0x45, 0x43, 0x67, 0x59, 0x42, 0x53, 0x4c,
  0x4c, 0x41, 0x76, 0x58, 0x69, 0x36, 0x4a, 0x36, 0x41, 0x48, 0x65, 0x31,
  0x57, 0x69, 0x57, 0x41, 0x67, 0x5a, 0x54, 0x57, 0x79, 0x6a, 0x72, 0x0a,
  0x58, 0x50, 0x7a, 0x39, 0x55, 0x4b, 0x6f, 0x4d, 0x48, 0x63, 0x76, 0x50,
  0x35, 0x34, 0x77, 0x55, 0x49, 0x37, 0x75, 0x4b, 0x63, 0x70, 0x65, 0x73,
  0x70, 0x78, 0x67, 0x41, 0x62, 0x54, 0x52, 0x76, 0x38, 0x73, 0x50, 0x49,
  0x6a, 0x36, 0x5a, 0x35, 0x65, 0x75, 0x59, 0x56, 0x66, 0x79, 0x44, 0x65,
  0x79, 0x46, 0x47, 0x42, 0x78, 0x74, 0x68, 0x7a, 0x56, 0x4c, 0x6f, 0x54,
  0x78, 0x36, 0x65, 0x5a, 0x0a, 0x46, 0x4d, 0x70, 0x35, 0x47, 0x68, 0x42,
  0x37, 0x57, 0x64, 0x69, 0x33, 0x59, 0x55, 0x77, 0x50, 0x56, 0x66, 0x4c,
  0x53, 0x73, 0x4c, 0x5a, 0x41, 0x42, 0x71, 0x6c, 0x64, 0x4b, 0x36, 0x74,
  0x6e, 0x4d, 0x39, 0x54, 0x6f, 0x4a, 0x50, 0x38, 0x30, 0x39, 0x2f, 0x4d,
  0x6a, 0x66, 0x4e, 0x44, 0x32, 0x64, 0x36, 0x59, 0x2f, 0x52, 0x75, 0x30,
  0x55, 0x36, 0x73, 0x6f, 0x72, 0x71, 0x50, 0x55, 0x76, 0x0a, 0x56, 0x77,
  0x73, 0x49, 0x4b, 0x78, 0x42, 0x71, 0x57, 0x69, 0x62, 0x6e, 0x56, 0x50,
  0x74, 0x35, 0x41, 0x51, 0x4a, 0x42, 0x41, 0x50, 0x53, 0x68, 0x59, 0x34,
  0x72, 0x31, 0x63, 0x47, 0x38, 0x66, 0x56, 0x70, 0x6e, 0x6b, 0x6e, 0x4b,
  0x45, 0x64, 0x67, 0x31, 0x50, 0x47, 0x78, 0x77, 0x46, 0x68, 0x47, 0x37,
  0x56, 0x44, 0x42, 0x36, 0x74, 0x57, 0x51, 0x37, 0x62, 0x6d, 0x6a, 0x35,
  0x4e, 0x51, 0x0a, 0x53, 0x5a, 0x43, 0x64, 0x64, 0x65, 0x51, 0x5a, 0x6d,
  0x47, 0x66, 0x62, 0x4f, 0x6b, 0x48, 0x6c, 0x31, 0x58, 0x4e, 0x5a, 0x79,
  0x67, 0x56, 0x2b, 0x31, 0x31, 0x6c, 0x6c, 0x71, 0x7a, 0x58, 0x53, 0x38,
  0x51, 0x52, 0x37, 0x69, 0x57, 0x54, 0x68, 0x41, 0x4b, 0x30, 0x43, 0x51,
  0x51, 0x44, 0x61, 0x74, 0x6b, 0x6f, 0x4e, 0x71, 0x72, 0x56, 0x38, 0x68,
  0x6a, 0x6e, 0x72, 0x38, 0x61, 0x55, 0x4a, 0x0a, 0x46, 0x50, 0x63, 0x55,
  0x30, 0x2f, 0x4f, 0x79, 0x77, 0x33, 0x37, 0x54, 0x7a, 0x39, 0x6a, 0x4f,
  0x38, 0x64, 0x75, 0x74, 0x47, 0x34, 0x35, 0x7a, 0x59, 0x67, 0x47, 0x78,
  0x52, 0x61, 0x63, 0x33, 0x37, 0x77, 0x4e, 0x39, 0x51, 0x30, 0x38, 0x38,
  0x76, 0x38, 0x37, 0x50, 0x4d, 0x62, 0x6c, 0x72, 0x38, 0x56, 0x38, 0x31,
  0x63, 0x39, 0x5a, 0x51, 0x6b, 0x6e, 0x35, 0x2f, 0x2f, 0x53, 0x50, 0x4b,
  0x0a, 0x56, 0x39, 0x50, 0x35, 0x41, 0x6b, 0x45, 0x41, 0x67, 0x65, 0x39,
  0x2f, 0x4b, 0x66, 0x33, 0x33, 0x2f, 0x47, 0x34, 0x4f, 0x31, 0x36, 0x73,
  0x41, 0x4c, 0x75, 0x75, 0x34, 0x4a, 0x37, 0x56, 0x37, 0x57, 0x70, 0x59,
  0x7a, 0x32, 0x33, 0x47, 0x42, 0x44, 0x31, 0x62, 0x41, 0x6e, 0x4e, 0x4f,
  0x57, 0x43, 0x30, 0x38, 0x6e, 0x34, 0x2f, 0x4a, 0x65, 0x2f, 0x67, 0x74,
  0x43, 0x55, 0x6c, 0x65, 0x31, 0x0a, 0x64, 0x2b, 0x38, 0x57, 0x45, 0x7a,
  0x44, 0x73, 0x42, 0x30, 0x4d, 0x36, 0x4b, 0x7a, 0x65, 0x2f, 0x57, 0x74,
  0x56, 0x79, 0x51, 0x30, 0x6c, 0x43, 0x7a, 0x78, 0x78, 0x62, 0x2b, 0x51,
  0x4a, 0x42, 0x41, 0x4a, 0x79, 0x49, 0x5a, 0x50, 0x33, 0x64, 0x46, 0x4f,
  0x46, 0x58, 0x79, 0x2f, 0x4c, 0x44, 0x55, 0x77, 0x50, 0x70, 0x2f, 0x6d,
  0x44, 0x6f, 0x78, 0x58, 0x31, 0x48, 0x44, 0x2b, 0x6d, 0x57, 0x0a, 0x30,
  0x36, 0x78, 0x68, 0x53, 0x34, 0x46, 0x63, 0x76, 0x4a, 0x70, 0x32, 0x4a,
  0x5a, 0x48, 0x7a, 0x73, 0x52, 0x65, 0x47, 0x4f, 0x44, 0x41, 0x5a, 0x30,
  0x59, 0x64, 0x41, 0x48, 0x45, 0x73, 0x4d, 0x59, 0x70, 0x49, 0x51, 0x41,
  0x62, 0x31, 0x6d, 0x39, 0x35, 0x64, 0x5a, 0x45, 0x62, 0x4b, 0x57, 0x77,
  0x56, 0x76, 0x62, 0x65, 0x6a, 0x6b, 0x43, 0x51, 0x51, 0x44, 0x52, 0x46,
  0x42, 0x39, 0x73, 0x0a, 0x66, 0x39, 0x68, 0x53, 0x33, 0x57, 0x4d, 0x69,
  0x38, 0x65, 0x47, 0x6e, 0x43, 0x4d, 0x33, 0x58, 0x34, 0x4c, 0x32, 0x32,
  0x7a, 0x68, 0x61, 0x46, 0x42, 0x74, 0x68, 0x33, 0x73, 0x51, 0x7a, 0x78,
  0x72, 0x63, 0x4a, 0x35, 0x51, 0x4a, 0x55, 0x4d, 0x78, 0x57, 0x69, 0x44,
  0x6c, 0x45, 0x4f, 0x72, 0x76, 0x71, 0x47, 0x77, 0x4c, 0x48, 0x79, 0x67,
  0x50, 0x4f, 0x38, 0x59, 0x59, 0x38, 0x58, 0x6c, 0x0a, 0x74, 0x79, 0x59,
  0x63, 0x45, 0x64, 0x6c, 0x43, 0x4c, 0x35, 0x36, 0x71, 0x74, 0x41, 0x34,
  0x59, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x50,
  0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d,
  0x2d, 0x2d, 0x2d, 0x0a,
};

const std::vector<char> server_dh1024 =
{
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x44,
  0x48, 0x20, 0x50, 0x41, 0x52, 0x41, 0x4d, 0x45, 0x54, 0x45, 0x52, 0x53,
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x47, 0x48, 0x41, 0x6f,
  0x47, 0x42, 0x41, 0x4c, 0x50, 0x35, 0x33, 0x68, 0x32, 0x31, 0x59, 0x6d,
  0x6a, 0x47, 0x4a, 0x4f, 0x34, 0x53, 0x2f, 0x38, 0x42, 0x7a, 0x44, 0x61,
  0x57, 0x63, 0x4b, 0x6f, 0x46, 0x6c, 0x6a, 0x56, 0x32, 0x46, 0x37, 0x4f,
  0x66, 0x39, 0x4e, 0x50, 0x33, 0x31, 0x33, 0x4b, 0x54, 0x42, 0x2f, 0x51,
  0x55, 0x62, 0x6c, 0x58, 0x70, 0x6e, 0x65, 0x4e, 0x2b, 0x62, 0x0a, 0x32,
  0x41, 0x70, 0x76, 0x4e, 0x31, 0x32, 0x69, 0x33, 0x51, 0x46, 0x75, 0x52,
  0x2b, 0x4a, 0x6e, 0x4e, 0x70, 0x2b, 0x51, 0x2f, 0x6d, 0x47, 0x7a, 0x34,
  0x6b, 0x77, 0x32, 0x2b, 0x45, 0x48, 0x6d, 0x35, 0x67, 0x65, 0x68, 0x38,
  0x6f, 0x35, 0x54, 0x47, 0x6a, 0x57, 0x6a, 0x57, 0x50, 0x69, 0x33, 0x42,
  0x30, 0x78, 0x6c, 0x4c, 0x76, 0x4e, 0x4a, 0x4c, 0x54, 0x31, 0x32, 0x68,
  0x41, 0x56, 0x42, 0x0a, 0x76, 0x31, 0x6f, 0x38, 0x65, 0x50, 0x68, 0x30,
  0x72, 0x5a, 0x65, 0x66, 0x43, 0x47, 0x7a, 0x74, 0x68, 0x32, 0x4a, 0x2f,
  0x6a, 0x4b, 0x4c, 0x4f, 0x41, 0x57, 0x46, 0x36, 0x30, 0x6e, 0x32, 0x53,
  0x33, 0x45, 0x36, 0x34, 0x37, 0x5a, 0x4a, 0x74, 0x74, 0x32, 0x2f, 0x4b,
  0x47, 0x47, 0x6b, 0x76, 0x37, 0x56, 0x33, 0x62, 0x41, 0x67, 0x45, 0x43,
  0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x44, 0x48,
  0x20, 0x50, 0x41, 0x52, 0x41, 0x4d, 0x45, 0x54, 0x45, 0x52, 0x53, 0x2d,
  0x2d, 0x2d, 0x2d, 0x2d, 0x0a,
};
