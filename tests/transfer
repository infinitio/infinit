#! /usr/bin/env python3

import infinit.oracles.servers
import reactor
import elle.log

import os
import state
import utils
import unittest
import time
import datetime
import tempfile
import traceback
import sys
import threading

from utils import expect_raise, TemporaryData, FileMatch

ELLE_LOG_COMPONENT = 'test'

def exiter():
  print('#################### EXIT #############')
  os._exit(1)
# Setup emergency timeout in case teardown gets stuck
abort_timer = threading.Timer(600, exiter)

def transaction_callback(notification, state, rules, default_action,
                         statuses=None):
  """ Receives a transaction notification and potentially reply with an action
  Rules is of the form [{'condition':{'key': NOTIF_FIELD, 'value': EXPECTED_VALUE}, 'action': ACTION_NAME}]
  ACTION_NAME is a transaction action among accept,reject,join,cancel,pause,interrupt,reset
  NOTIF_FIELD is one of the keys in the notification
  @param statuses: updated with id->status
  """
  if statuses is not None:
    # in case messages are async, ensure we do not overwrite a final state
    if statuses.get(notification['transaction_id'], '') not in final_statuses:
      statuses[notification['transaction_id']] = notification['status']
  #print('TRANSACTION_CB %s transaction_id=%s status=%s' % (len(statuses), notification['transaction_id'], notification['status']))
  action = default_action
  for r in rules:
    for cond in r['conditions']:
      k = cond['key']
      v = cond['value']
      if notification.get(k, '<unset>') != v:
        break
      action = r['action']
  if action:
    #print('TRANSACTION_CB replying %s' % action)
    getattr(state, 'transaction_' + action)(notification['transaction_id'])



def check_explain(checker):
  """ Run the checker in verbose mode if possible
  """
  val = checker()
  if not val and hasattr(checker, 'explain'):
    checker.explain()
  return val

def wait_helper(timeout, condition, raise_on_timeout = True):
  result = advance([], timeout, condition)
  if not result and raise_on_timeout:
    raise Exception('timeout of %s reached' % timeout)

# Run the test until timeout in seconds or condition becomes true
def advance(states, timeout, condition):
  i = 0
  while i < timeout * 10 and not condition():
    for s in states:
      s.poll()
    reactor.sleep(datetime.timedelta(milliseconds = 100))
    i = i +1
  return condition()

final_statuses = ['transaction_finished', 'transaction_failed',
                  'transaction_canceled', 'transaction_rejected']

accept_rules = [{'conditions':[{'key': 'status',
                                'value': 'transaction_waiting_accept'}],
                 'action': 'accept'}]

reject_rules = [{'conditions':[{'key': 'status',
                                'value': 'transaction_waiting_accept'}],
                 'action': 'reject'}]

test_credentials = [('mefyl@infinit.io', 'mefyl'), ('mefyl2@infinit.io', 'mefyl2')]

class TransferPeer:
  """ Handles one peer, expecting only one transaction at most.
  """
  def __init__(self, oracles, credentials):
    self.oracles = oracles
    self.credentials = credentials
    self.state = None
    self.statuses = dict() # transaction_id -> status
    self.rules = []
    self.poll_thread = None
    self.interrupt = False
    self.logged_in = False
  def create(self, force=True):
    if self.state is not None and not force:
      return
    self.delete()
    self.state = self.oracles.state()
    self.state.attach_transaction_callback(
      lambda t: transaction_callback(t, self.state, self.rules, '',
                                     self.statuses))
    def poller():
      while not self.interrupt:
        self.state.poll()
        reactor.sleep(datetime.timedelta(milliseconds = 100))
    self.poll_thread = reactor.Thread('state_poller', poller)
  def delete(self):
    if self.state is None:
      return
    self.state.logout()
    self.interrupt = True
    self.poll_thread.wait()
    self.interrupt = False
    self.poll_thread = None
    self.state = None
  def set_rules(self, rules):
    """ Set event reply rules as per attach_transaction_callback()"""
    self.rules[:] = rules # modify in place
  def login(self):
    self.create(force=False)
    self.statuses = dict() #old transaction_id no longuer has sense
    self.state.login(self.credentials[0],
      state.hash_password(self.credentials[0], self.credentials[1]))
    self.logged_in = True
  def logout(self):
    if self.state is None:
      return
    self.state.logout()
    self.logged_in = False
  def check_progress(self, tid, progress):
    """ Check if progress greater than value, throw if it can never be"""
    if self.state.transaction_progress(tid) >= progress:
      return True
    if self.status in final_statuses:
      raise Exception('Progress unreachable: state=%s' % self.status)
    return False
  def wait_transaction_id(self, timeout=10):
    """ Wait for a transaction id to be available or throw"""
    wait_helper(timeout, lambda: len(self.statuses))
    return list(self.statuses.keys())[0]
  def wait_transaction_progress(self, progress, timeout=1000):
    """ Wait for transaction progress to be above given threshold or throw"""
    tid = self.wait_transaction_id(timeout)
    return wait_helper(timeout, lambda: self.check_progress(tid, progress))
  def wait_transaction_status(self, status, timeout=1000):
    tid = self.wait_transaction_id(timeout)
    if self.state.transaction_status(tid) == status:
      return True
    return wait_helper(timeout, lambda: self.statuses[tid] == status)
  def wait_transaction_final(self, timeout=1000):
    tid = self.wait_transaction_id(timeout)
    if self.state.transaction_status(tid) in final_statuses:
      return True
    return wait_helper(timeout, lambda: self.statuses[tid] in final_statuses)
  @property
  def status(self):
    """ Transaction status string (transaction_{canceled, finished, started...}"""
    tid = self.wait_transaction_id(1000)
    if self.logged_in:
      return self.state.transaction_status(tid)
    else:
      return self.statuses[tid]
  @property
  def transaction(self):
    """ Return the transaction metadata"""
    tid = self.wait_transaction_id(1000)
    return self.state.transaction(tid)

class Transfer:
  def __init__(self, credentials, files, *args, **kvargs):
    self.files = files
    self.data_args = args
    self.data_kvargs = kvargs
    self.peers = [None, None]
    self.credentials = credentials
  def __enter__(self):
    self.oracles = infinit.oracles.servers.Oracles(
      mongo_dump = '%s/two-users' % os.environ['DUMPS'])
    self.oracles.__enter__()
    self.data = TemporaryData(*self.data_args, **self.data_kvargs)
    self.data.__enter__()
    self.files = list(map(lambda x: os.path.join(self.data.directory, x), self.files))
    self.peers = [TransferPeer(self.oracles, self.credentials[0]),
                  TransferPeer(self.oracles, self.credentials[1])]
    self.peers[0].create()
    self.peers[1].create()
    return self
  def __exit__(self, *args, **kvargs):
    self.data.__exit__()
    self.oracles.__exit__()
  def start(self):
    self.sender.state.send_files(self.credentials[1][0], self.files, "Receive this.")
  @property
  def sender(self):
    return self.peers[0]
  @property
  def recipient(self):
    return self.peers[1]
  def wait_transaction_final(self, timeout):
    """ Wait for a final state on both ends"""
    if self.sender.logged_in:
      self.sender.wait_transaction_final(timeout)
    if self.recipient.logged_in:
      self.recipient.wait_transaction_final(timeout)
    # We can get the final state notification with still transaction threads
    # running, and they don't like beings asploded. Yes its a bug of some sort.
    reactor.sleep(datetime.timedelta(milliseconds = 300))
  def assertSuccess(self, test, total_size = None, is_directory = None,
                    files_count = None, files = None):
    """ Validates transaction success, metadata content, disk file data"""
    ts = None
    tr = None
    if self.recipient.logged_in:
      test.assertEqual(self.recipient.status, 'transaction_finished')
      tr = self.recipient.transaction
    if self.sender.logged_in:
      test.assertEqual(self.sender.status, 'transaction_finished')
      ts = self.sender.transaction
    expect = {
      'message': 'Receive this.',
      'recipient_fullname': test_credentials[1][0].split('@')[0],
      'sender_fullname': test_credentials[0][0].split('@')[0],
    };
    if total_size is not None:
      expect['total_size'] = total_size
    if is_directory is not None:
      expect['is_directory'] = is_directory
    if files_count is not None:
      expect['files_count'] = files_count
    if files is not None:
      expect['files'] = files
    # Filter out unexpected keys
    # FIXME: broken: PeerTransaction content is empty (deserialisation glitch?)
    #if ts is not None:
    #  ts = { k: ts[k] for k in expect.keys() }
    #  test.assertEqual(ts, expect)
    #if tr is not None:
    #  tr = { k: tr[k] for k in expect.keys() }
    #  test.assertEqual(tr, expect)
    test.assertTrue(check_explain(
      FileMatch(self.data.directory, self.oracles.download_dir)))

class TestBasicTransfer(unittest.TestCase):
  def transfer_test(self, files, files_data,
                    expect_total_size = None, expect_is_directory = None,
                    expect_files_count = None, expect_files = None):
    """ Run one test transfer
    @param files: files to announce to send_files (relative)
    @param files_data: arguments to TemporaryData ctor
    Rest of parameters are stuff that will be validated in transaction metadata
    """
    with Transfer(test_credentials, files,
                  **files_data) as transfer:
      transfer.recipient.login()
      transfer.sender.login()
      wait_helper(3, lambda: False, False)
      transfer.recipient.set_rules(accept_rules)
      transfer.start()
      transfer.wait_transaction_final(30)
      transfer.assertSuccess(self, expect_total_size, expect_is_directory,
                             expect_files_count, expect_files)

  def test_p2p_basic(self):
    return self.transfer_test(['100k'], {'name': '100k','size': 100000},
                              expect_total_size=100000, expect_files_count=1,
                              expect_is_directory = False
                              )
  def test_p2p_multiples(self):
    return self.transfer_test([''], {'names': list(map(str, range(10))), 'size':100})
  def test_p2p_multiples_2(self): # Pass file names instead of dir to send_files
    names = list(map(str, range(10)))
    return self.transfer_test(names, {'names': names, 'size':100})
  def test_p2p_many_files(self):
    names = list(map(str, range(200)))
    return self.transfer_test(names, {'names': names, 'size':100})
  def test_p2p_complex_layout(self):
    names = ['f1', 'd1/f2', 'd1/f1', 'd2/d3/f4', 'f2']
    return self.transfer_test([''], {'names': names, 'size':100})
  def test_p2p_complex_layout_2(self):
    names = ['f1', 'd1/f2', 'd1/f1', 'd2/d3/f4', 'f2']
    return self.transfer_test(['f1', 'd1', 'd2', 'f2'], {'names': names, 'size':100})
  def test_p2p_empty_files(self):
    names = list(map(str, range(10)))
    return self.transfer_test(names, {'names': names, 'size':0})


class TestResumeTransfer(unittest.TestCase):
  def parse_sequence(self, sequence):
    """ Parse string and generate sequence of test instructions:
    s,r,S,R: logout/login for sender/recipient
    {s,r}<PERCENTAGE>: wait until given progress (ex: s100)
    d<MILLISECONDS>: delay given time
    start: start transfer (call send_files)

    Note: file size must be big enough for waits to be accurate
    Note: Starting point is sender logged in, recipient is not
    """
    s = sequence.split(' ')
    result = []
    e = ''
    lastWait = True # was last action pushed a wait
    def action(isWait, a): # append an action
      nonlocal lastWait
      if not isWait and not lastWait:
        result.append(('d', lambda t: wait_helper(1, lambda: False, False)))
      result.append((e, a))
      lastWait = isWait
    def isInt(s):
      """ Integral value of argument or None"""
      try:
        return int(s)
      except:
        return None
    # Wrapper for proper argument capture
    def call(method_get, *args):
      return lambda t: method_get(t)(*args)
    for e in s:
      elle.log.trace('processing "%s"' % e)
      if e == 's':
        action(False, lambda t: t.sender.logout())
      elif e == 'r':
        action(False, lambda t: t.recipient.logout())
      elif e == 'S':
        action(False, lambda t: t.sender.login())
      elif e == 'R':
        action(False, lambda t: t.recipient.login())
      elif e == 'start':
        action(False, lambda t: t.start())
      elif isInt(e) is not None:
        action(True, call(lambda t: t.sender.wait_transaction_progress, int(e) / 100.0))
      elif e[0] == 's' and isInt(e[1:]) is not None:
        action(True, call(lambda t: t.sender.wait_transaction_progress, int(e[1:]) / 100.0))
      elif e[0] == 'r' and isInt(e[1:]) is not None:
        action(True, call(lambda t: t.recipient.wait_transaction_progress, int(e[1:]) / 100.0))
      elif e[0] == 'd' and isInt(e[1:]) is not None:
        action(True, call(lambda t: reactor.sleep, datetime.timedelta(milliseconds = int(e[1:]))))
      else:
        raise Exception('Unknown entry "%s"' % e)
    return result
  def transfer_test(self, files, files_data, sequence,
                    expect_total_size = None, expect_is_directory = None,
                    expect_files_count = None, expect_files = None):
    if isinstance(sequence, str):
      sequence = self.parse_sequence(sequence)
    with Transfer(test_credentials, files,
                  **files_data) as transfer:
      transfer.sender.login()
      wait_helper(3, lambda: False, False)
      transfer.recipient.set_rules(accept_rules)
      for e in sequence:
        elle.log.trace('Executing %s' % e[0])
        e[1](transfer)
      transfer.wait_transaction_final(30)
      transfer.assertSuccess(self, expect_total_size, expect_is_directory,
                             expect_files_count, expect_files)
  #def test_self(self): # tests the test system
  #  return self.transfer_test(['100k'], {'name': '100k','size': 100000},
  #                            'R start 10 20 30 100',
  #                            expect_total_size=100000, expect_files_count=1)
  def test_all_cloud(self): # sender and recipient are never logged in together
    return self.transfer_test(['100k'], {'name': '100k','size': 100000},
                              'start s100 s R r100 r S',
                              expect_total_size=100000, expect_files_count=1)
  def test_all_cloud_2(self): # final state variant
    return self.transfer_test(['100k'], {'name': '100k','size': 100000},
                              'start s100 s R r100 r S R',
                              expect_total_size=100000, expect_files_count=1)
  def test_all_cloud_3(self): # final state variant
    return self.transfer_test(['100k'], {'name': '100k','size': 100000},
                              'start s100 s R r100 r S R s',
                              expect_total_size=100000, expect_files_count=1)
  def test_all_cloud_many(self):
    names = list(map(str, range(50)))
    return self.transfer_test([''], {'names':  names, 'size': 100},
                              'start s100 s R r100 r S R',
                              expect_total_size=100000, expect_files_count=1)
  def test_all_cloud_bigger(self):
    names = list(map(str, range(3)))
    return self.transfer_test([''], {'names':  names, 'size': 513000},
                              'start s100 s R r100 r S R',
                              expect_total_size=100000, expect_files_count=1)
  # Testing mode switch between p2p and cloud, requires bigger files
  # WARNING FIXME: depends heavily on available bandwith with cloud!
  def test_switch_recipient(self): #sender on, recipient flickers
    return self.transfer_test(['big'], {'name': 'big','size': 1000000},
                              'start s10 R s20 r s30 R s40 r s50 R s60 r s70 R s80 r s90 R')
  def test_switch_send_cloud(self):
    #sender all cloud, recipient on, sender flickers
    # recipient should get all from cloud and not be disturbed
    return self.transfer_test(['big'], {'name': 'big','size': 1000000},
                              'start s100 R r20 s r30 S r40 s r50 S r60 s r70 S r80 s r90 S')
  def test_switch_send_p2p(self):
    # sender flickers, recipient always on, no cloud
    # Note: cannot finish with S, sS sequence does not get the finished notification
    # because transaction goes to history and our python binding doesn't have that 
    return self.transfer_test(['big'], {'name': 'big','size': 1000000},
                              'R start r10 s S r20 s S r30 s S r40 s S r50 s S r60 s S r70 s S r80 s S r90 s S r100 s')
  def test_switch_both(self):
    return self.transfer_test(['big'], {'name': 'big','size': 1000000},
                              'start s40 R r10 r s R r20 r R r30 r R r40 r S s80 s R r50 S')

utils.run(unittest.main)

