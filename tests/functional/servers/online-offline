#!/usr/bin/env python3.2

import itertools
import plasma
import pythia
import time
import utils

ADMIN_TOKEN = pythia.constants.ADMIN_TOKEN

trophonius_control_port = 39075

def run(N: "Number of users"):
    with utils.Servers() as (meta, tropho):

        proto, addr, port = meta.url.split(":")
        addr = addr.replace('/', '')
        port = port.replace('/', '')

        admin = plasma.Meta("127.0.0.1", int(port))
        admin.token = ADMIN_TOKEN
        def register(i):
            meta_client = plasma.Meta("127.0.0.1", int(port))
            email = 'user{}@infinit.io'.format(i)
            password = '#' * 64
            res = meta_client.register(
                email, "User Name",
                password, "bitebite"
            )
            assert res.success
            login = meta_client.login(email, password)
            assert login.success
            return meta_client

        def create_users(number):
            users = []
            for i in range(number):
                print("Creating user %s" % (i + 1))
                users.append(register(i))
            return users

        user_list = create_users(N)
        combinations = list(itertools.combinations(user_list, 2))
        for idx, pair in enumerate(combinations):
            u1, u2 = pair
            print("%s / %s: Make swagger" % (idx, len(combinations)), u1.self().id, "and", u2.self().id)
            admin.add_swaggers(u1.self().id, u2.self().id)

        def create_device(user):
            res = user.create_device("device");
            return res.id

        def connect_tropho(user, device_id):
            res = plasma.Trophonius(tropho.host, tropho.port, lambda: None)
            res.connect(user.self().id, user.token, device_id)
            return res

        tropho_connections = []
        for user in user_list:
            print("* Connecting", user.self().id)
            device = create_device(user)
            tropho_connections.append(connect_tropho(user, device))
            time.sleep(.1)

        def poll(client):
            notifications = []
            notif = client.poll()
            while notif is not None:
                notifications.append(notif)
                notif = client.poll()
            return notifications

        online_status = 0
        offline_status = 0
        for i in range(N):
            print("\t* Round", i + 1)
            print("\t -> Polling", len(tropho_connections), "connections")
            all_notifications = list(map(poll, tropho_connections))
            print("\t -> Polling done")
            for idx, notifications in enumerate(all_notifications):
                online_notification_list = list(
                    n for n in notifications
                    if n.type == 'user_status' and n.status
                )
                offline_notification_list = list(
                    n for n in notifications
                    if n.type == 'user_status' and not n.status
                )
                online_count = len(online_notification_list)
                offline_count = len(offline_notification_list)
                if online_count + offline_count:
                    print("\t\tUser %s (%s) got %s online notifications (%s) and %s offline notifications (%s)" % (
                        idx + 1,
                        user_list[idx].self().id,
                        online_count,
                        list(n.user_id for n in online_notification_list),
                        offline_count,
                        list(n.user_id for n in offline_notification_list),
                    ))
                online_status += online_count
                offline_status += offline_count
            print("\t -> Logout user", user_list[0].self().id)
            user_list[0].logout()
            user_list.pop(0)
            tropho_connections.pop(0)
            time.sleep(.5)

        print("Got", online_status, "online status notifications, expected is", sum(range(N)))
        print("Got", offline_status, "offline status notifications, expected is", sum(range(N)))
        return online_status == sum(range(N)) and offline_status == sum(range(N))

if __name__ == '__main__':
    for i in range(1, 11):
        print("Running tests with", i, "users")
        run(i)
