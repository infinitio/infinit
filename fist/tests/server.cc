#include "server.hh"

#include <boost/uuid/random_generator.hpp>
#include <boost/uuid/string_generator.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <boost/algorithm/string.hpp>

#include <elle/Buffer.hh>
#include <elle/log.hh>
#include <elle/os/path.hh>
#include <elle/finally.hh>
#include <elle/container/map.hh>
#include <elle/serialization/json/SerializerIn.hh>
#include <elle/system/home_directory.hh>

#include <reactor/network/exception.hh>

#include <papier/Authority.hh>

#include <version.hh>

ELLE_LOG_COMPONENT("fist.tests");

extern const std::vector<unsigned char> fingerprint;
extern const std::vector<char> server_certificate;
extern const std::vector<char> server_key;
extern const std::vector<char> server_dh1024;

class KeyPair:
  public infinit::cryptography::KeyPair
{
public:
  KeyPair()
    : infinit::cryptography::KeyPair(
      infinit::cryptography::KeyPair::generate(
        infinit::cryptography::Cryptosystem::rsa, 1024))
  {}
};

KeyPair authority_keys;
papier::Authority authority(authority_keys);

papier::Identity
generate_identity(cryptography::KeyPair const& keypair,
                  std::string const& id,
                  std::string const& description,
                  std::string const& password)
{
  ELLE_LOG_SCOPE("generate identity, encrypt with password %s", password);
  papier::Identity identity;
  if (identity.Create(id, description, keypair) == elle::Status::Error)
    throw std::runtime_error("unable to create the identity");
  if (identity.Encrypt(password) == elle::Status::Error)
    throw std::runtime_error("unable to encrypt the identity");
  if (identity.Seal(authority) == elle::Status::Error)
    throw std::runtime_error("unable to seal the identity");

  // ELLE_ASSERT(identity.Decrypt(password) != elle::Status::Error);
  // ELLE_ASSERT(identity.Clear() != elle::Status::Error);

  return identity;
}

TemporaryHome::TemporaryHome()
  : _temporary_home()
{
  elle::os::setenv("INFINIT_NO_DIR_CACHE", "1", true);
  elle::os::setenv("INFINIT_HOME", this->temporary_home().path().string(), true);
}

Trophonius::Trophonius()
  : _server(elle::make_unique<reactor::network::SSLCertificate>(
              server_certificate,
              server_key,
              server_dh1024))
  , _accepter(new reactor::Thread{elle::sprintf("%s accepter", *this),
                                    boost::bind(&Trophonius::_serve, this)})
{
  this->_server.listen();
}

Trophonius::~Trophonius()
{
  this->_accepter->terminate_now();
}

std::string
Trophonius::json() const
{
  return elle::sprintf(
    "{"
    "  \"host\": \"127.0.0.1\","
    "  \"port\": 0,"
    "  \"port_ssl\": %s"
    "}",
    this->port());
}

int
Trophonius::port() const
{
  return this->_server.port();
}

void
Trophonius::_serve()
{
  elle::With<reactor::Scope>() << [this] (reactor::Scope& scope)
  {
    while (true)
    {
      auto socket = elle::utility::move_on_copy(this->_server.accept());
      scope.run_background(
        elle::sprintf("serve %s", *socket),
        [socket, this]
        {
          this->_serve(std::move(*socket));
        });
    }
  };
}

void
Trophonius::disconnect_all_users()
{
  this->_accepter->terminate_now();
  this->_accepter.reset(new reactor::Thread{
      elle::sprintf("%s accepter", *this), boost::bind(&Trophonius::_serve, this)});
}

void
Trophonius::_serve(std::unique_ptr<reactor::network::SSLSocket> socket)
{
  std::string key{};
  while (key.empty())
  {
    auto json_read = elle::json::read(*socket);
    auto json = boost::any_cast<elle::json::Object>(json_read);
    if (json.find("poke") != json.end())
    {
      auto poke = json["poke"];
      elle::json::write(*socket, json);
      continue;
    }
    if (json.find("user_id") == json.end())
      continue;
    auto device_id = boost::uuids::string_generator()(boost::any_cast<std::string>(json["device_id"]));
    auto user_id = boost::uuids::string_generator()(boost::any_cast<std::string>(json["user_id"]));
    key = elle::sprintf("%s+%s", user_id, device_id);
  }
  ELLE_LOG("Trophonius, new connection")

  elle::SafeFinally remove{[&] { try { this->_clients.erase(key); } catch (...) { }}};
  this->_clients.emplace(key, std::move(socket));

  this->_clients.at(key)->write("{\"notification_type\": -666, \"response_code\": 200, \"response_details\": \"details\"}\n");
  try
  {
    while (true)
      this->_clients.at(key)->read_until("\n");
  }
  catch (reactor::network::ConnectionClosed const&)
  {}
}

std::vector<reactor::network::SSLSocket*>
Trophonius::clients(boost::uuids::uuid const& user_id)
{
  std::vector<reactor::network::SSLSocket*> sockets;
  for (auto& socket: this->_clients)
  {
    std::vector<std::string> strs;
    boost::split(strs, socket.first, boost::is_any_of("+"));
    if (boost::uuids::string_generator()(strs[0]) == user_id)
      sockets.push_back(socket.second.get());
  }
  return sockets;
}

reactor::network::SSLSocket*
Trophonius::device(boost::uuids::uuid const& device_id)
{
  for (auto& socket: this->_clients)
  {
    std::vector<std::string> strs;
    boost::split(strs, socket.first, boost::is_any_of("+"));
    if (boost::uuids::string_generator()(strs[1]) == device_id)
      return socket.second.get();
  }
  return nullptr;
}

Server::Device::Device(cryptography::PublicKey const& key,
                       boost::optional<boost::uuids::uuid> device)
  : _id(device ? device.get() : boost::uuids::random_generator()())
  , _passport(boost::lexical_cast<std::string>(this->_id), "osef", key, authority)
{
}

std::string
Server::Device::json() const
{
  std::string passport_string;
  if (this->_passport.Save(passport_string) == elle::Status::Error)
    throw std::runtime_error("unabled to save the passport");
  return elle::sprintf(
    "{"
    "  \"id\" : \"%s\","
    "  \"name\": \"device\","
    "  \"passport\": \"%s\""
    "}",
    this->id(),
    passport_string);
}

static
std::string
link_representation(infinit::oracles::LinkTransaction const& link)
{
  return elle::sprintf(
    "{"
    "  \"id\": \"%s\","
    "  \"click_count\": 3,"
    "  \"ctime\": 319234,"
    "  \"message\": \"\","
    "  \"mtime\": 319293,"
    "  \"name\": \"foo\","
    "  \"sender_device_id\": \"%s\","
    "  \"sender_id\": \"%s\","
    "  \"share_link\": \"http://stuff.com\","
    "  \"status\": %s"
    "}",
    link.id,
    link.sender_device_id,
    link.sender_id,
    (int) link.status);
}

Server::User::User(boost::uuids::uuid id,
                   std::string email,
                   boost::optional<cryptography::KeyPair> keys,
                   boost::optional<papier::Identity> identity)
  : _id(std::move(id))
  , _email(std::move(email))
  , _keys(keys)
  , _identity(identity)
{}

std::string
Server::User::links_json() const
{
  // I wish I could use elle::serialization::SerializerOut.
  std::string str = "[";
  for (auto const& link: this->links)
    str += link_representation(link) + ", ";

  if (!this->links.empty())
    str = str.substr(0, str.length() - 2  );
  str += "]";
  return str;
}

std::string
Server::User::swaggers_json() const
{
  std::string str = "[";
  for (auto const& user: this->swaggers)
    str += user->json() + ", ";

  if (!this->swaggers.empty())
    str = str.substr(0, str.length() - 2);
  str += "]";
  return str;
}

void
Server::User::print(std::ostream& stream) const
{
  stream << "User(" << this->email() << ", " << this->id() << ")";
}

std::string
Server::User::devices_json() const
{
  std::string str = "[";
  for (auto const& device: this->connected_devices)
    str += elle::sprintf("\"%s\", ", device);
  if (!this->connected_devices.empty())
    str = str.substr(0, str.length() - 2);
  str += "]";
  return str;
}

std::string
Server::User::json() const
{
  std::string public_key_serialized;
  if (this->_keys)
    this->_keys.get().K().Save(public_key_serialized);

  auto res = elle::sprintf(
    "{"
    "  \"id\": \"%s\","
    "  \"public_key\": \"%s\","
    "  \"fullname\": \"%s\","
    "  \"handle\": \"%s\","
    "  \"connected_devices\": %s,"
    "  \"status\": %s,"
    "  \"register_status\": \"%s\","
    "  \"_id\": \"%s\""
    "}",
    this->id(),
    public_key_serialized,
    this->email(),
    this->email(),
    this->devices_json(),
    this->connected_devices.empty() ? "false" : "true",
    this->_keys ? "ok" : "ghost",
    this->id());
  return res;
}

std::string
Server::User::self_json() const
{
  std::string identity_serialized;
  this->_identity.get().Save(identity_serialized);

  std::string public_key_serialized;
  this->_keys.get().K().Save(public_key_serialized);
  return elle::sprintf(
    "{"
    "  \"id\": \"%s\","
    "  \"public_key\": \"%s\","
    "  \"fullname\": \"\","
    "  \"handle\": \"\","
    "  \"connected_devices\": %s,"
    "  \"register_status\": \"\","
    "  \"email\": \"%s\","
    "  \"identity\": \"%s\","
    "  \"devices\": [],"
    "  \"favorites\": [],"
    "  \"success\": true"
    "}",
    this->id(),
    public_key_serialized,
    this->devices_json(),
    this->email(),
    identity_serialized);
}

Server::Client::Client(Server& server,
                       User& user)
  : _server(server)
  , device_id(boost::uuids::random_generator()())
  , user(user)
  , state(server, device_id)
{
  state.attach_callback<surface::gap::State::ConnectionStatus>(
    [&] (surface::gap::State::ConnectionStatus const& notif)
    {
      ELLE_TRACE_SCOPE("connection status notification: %s", notif);
    }
    );

  state.attach_callback<surface::gap::State::UserStatusNotification>(
    [&] (surface::gap::State::UserStatusNotification const& notif)
    {
      ELLE_TRACE_SCOPE("user status notification: %s", notif);
    });
}

Server::Client::~Client()
{
  this->logout();
}

Server::Client::Client(Server& server,
                       std::string const& email,
                       std::string const& password)
  : Client(server, server.register_user(email, password))
{
}

void
Server::Client::login(std::string const& password)
{
  this->state.login(this->user.email(), password);
  this->state.logged_in().wait();
  this->user.connected_devices.insert(this->device_id);
}

void
Server::Client::logout()
{
  this->state.logout();
  this->user.connected_devices.erase(this->device_id);
  this->state.logged_out().wait();
}

Server::Server()
  : _session_id(boost::uuids::random_generator()())
  , trophonius()
  , _cloud_buffered(false)
{
  this->headers()["X-Fist-Meta-Version"] = INFINIT_VERSION;

  this->register_route(
    "/status",
    reactor::http::Method::GET,
    [] (Server::Headers const&,
        Server::Cookies const&,
        Server::Parameters const&,
        elle::Buffer const&)
    {
      return "{\"status\" : true}";
    });

  this->register_route(
    "/login",
    reactor::http::Method::POST,
    [&] (Server::Headers const&,
         Server::Cookies const&,
         Server::Parameters const&,
         elle::Buffer const& content)
    {
      elle::IOStream stream(new elle::InputStreamBuffer<elle::Buffer>(content));
      elle::serialization::json::SerializerIn input(stream, false);
      std::string email;
      input.serialize("email", email);
      std::string device_id_str;
      input.serialize("device_id", device_id_str);
      auto device_id = boost::uuids::string_generator()(device_id_str);
      auto& users = this->_users.get<1>();
      auto it = users.find(email);
      if (it == users.end())
        throw reactor::http::tests::Server::Exception(
          "/login",
          reactor::http::StatusCode::Not_Found,
          "user not found");
      auto& user = **it;
      this->headers()["Set-Cookie"] = elle::sprintf("session-id=%s+%s", user.id(), device_id_str);
      if (this->_devices.find(device_id) == this->_devices.end())
        this->register_device(user, device_id);
      auto& device = this->_devices.at(device_id);

      return elle::sprintf(
         "{"
         " \"self\": %s,"
         " \"device\": %s,"
         " \"features\": [],"
         " \"trophonius\" : %s"
         "}",
         user.self_json(),
         device.json(),
         this->trophonius.json());
    });
  this->register_route(
    "/trophonius",
    reactor::http::Method::GET,
    std::bind(&Server::_get_trophonius,
              this,
              std::placeholders::_1,
              std::placeholders::_2,
              std::placeholders::_3,
              std::placeholders::_4));

  this->register_route(
    "/user/synchronize",
    reactor::http::Method::GET,
    [&] (Server::Headers const&,
        Server::Cookies const& cookies,
         Server::Parameters const& parameters,
         elle::Buffer const&)
    {
      auto const& user = this->user(cookies);

      // XXX: Transactions.
      // std::vector<Transaction> trs;
      // for (auto const& tr: this->_transactions.get<0>())
      //   ELLE_LOG("%s", *tr);

      return elle::sprintf(
        "{"
        "  \"swaggers\": %s,"
        "  \"running_transactions\": [],"
        "  \"final_transactions\": [],"
        "  \"links\": %s"
        "}",
        user.swaggers_json(),
        user.links_json());
    });

  this->register_route(
    "/logout",
    reactor::http::Method::POST,
    [] (Server::Headers const&,
        Server::Cookies const&,
        Server::Parameters const&,
        elle::Buffer const&)
    {
      return "{\"success\": true}";
    });
  // auto self =
  //   [&] (Server::Headers const&,
  //        Server::Cookies const&,
  //        Server::Parameters const&,
  //        elle::Buffer const&)
  //   {
  //     return elle::sprintf(
  //       "{"
  //       "  \"id\": \"%s\","
  //       "  \"public_key\": \"\","
  //       "  \"fullname\": \"\","
  //       "  \"handle\": \"\","
  //       "  \"connected_devices\": [],"
  //       "  \"register_status\": \"\","
  //       "  \"email\": \"\","
  //       "  \"identity\": \"\","
  //       "  \"devices\": [],"
  //       "  \"favorites\": [],"
  //       "  \"success\": true"
  //       "}",
  //       this->_identity.id());
  //   };
  // this->register_route(
  //   elle::sprintf("/users/%s", this->_identity.id()),
  //   reactor::http::Method::GET,
  //   self);
  this->register_route(
    "/user/full_swaggers",
    reactor::http::Method::GET,
    [&] (Server::Headers const&,
         Server::Cookies const&,
         Server::Parameters const&,
         elle::Buffer const&)
    {
      return "{\"success\": true, \"swaggers\": []}";
    });
  this->register_route(
    "/transactions",
    reactor::http::Method::GET,
    [&] (Server::Headers const&,
         Server::Cookies const&,
         Server::Parameters const&,
         elle::Buffer const&)
    {
      return "{\"success\": true, \"transactions\": []}";
    });
  this->register_route(
    "/links",
    reactor::http::Method::GET,
    [&] (Server::Headers const&,
         Server::Cookies const&,
         Server::Parameters const&,
         elle::Buffer const&)
    {
      return "{\"success\": true, \"links\": []}";
    });

  this->register_route(
    "/link",
    reactor::http::Method::POST,
    [&] (Server::Headers const&,
         Server::Cookies const& cookies,
         Server::Parameters const&,
         elle::Buffer const&)
    {
      auto& user = this->user(cookies);
      auto device = this->device(cookies);
      infinit::oracles::LinkTransaction t;
      t.click_count = 3;
      t.id = boost::lexical_cast<std::string>(boost::uuids::random_generator()());
      t.ctime = 2173213;
      t.sender_id = boost::lexical_cast<std::string>(user.id());
      t.sender_device_id = boost::lexical_cast<std::string>(device.id());
      t.status = infinit::oracles::Transaction::Status::initialized;
      user.links.push_back(t);

      this->register_route(
        elle::sprintf("/link/%s", t.id),
        reactor::http::Method::POST,
        [&, t] (Server::Headers const&,
                Server::Cookies const& cookies,
                Server::Parameters const& parameters,
                elle::Buffer const& body)
        {
          elle::IOStream stream(
            new elle::InputStreamBuffer<elle::Buffer>(body));
          elle::serialization::json::SerializerIn input(stream, false);
          int status;
          input.serialize("status", status);
          auto& user = this->user(cookies);
          for (auto& link: user.links)
            if (link.id == t.id)
              link.status =
                static_cast<infinit::oracles::Transaction::Status>(status);
          return "{\"success\": true}";
        });

      this->register_route(
        elle::sprintf("/s3/%s/filename", t.id),
        reactor::http::Method::POST,
        [&, t] (Server::Headers const&,
                Server::Cookies const&,
                Server::Parameters const& parameters,
                elle::Buffer const&)
        {
          static bool b = true;
          elle::SafeFinally f([&] { b = false; });
          if (b)
            return std::string{
              "<InitiateMultipartUploadResult>"
              "  <Bucket>bucket</Bucket>"
              "  <Key>filename</Key>"
              "  <UploadId>VXBsb2FkIElEIGZvciA2aWWpbmcncyBteS1tb3ZpZS5tMnRzIHVwbG9hZA</UploadId>"
              "</InitiateMultipartUploadResult>"};
          else
            return elle::sprintf(
              "<CompleteMultipartUploadResult>"
              "<Location></Location>"
              "<Bucket>bucket</Bucket>"
              "<Key>filename</Key>"
              "<ETag>%s</ETag>"
              "</CompleteMultipartUploadResult>",
              this->headers()["ETag"]);
        });

      this->register_route(
        elle::sprintf("/s3/%s/filename", t.id),
        reactor::http::Method::PUT,
        [&, t] (Server::Headers const&,
                Server::Cookies const&,
                Server::Parameters const& parameters,
                elle::Buffer const&)
        {
          this->headers()["ETag"] = boost::lexical_cast<std::string>(boost::uuids::random_generator()());
          return elle::sprintf(
            "<CompleteMultipartUploadResult>"
            "<Location></Location>"
            "<Bucket>bucket</Bucket>"
            "<Key>filename</Key>"
            "<ETag>%s</ETag>"
            "</CompleteMultipartUploadResult>",
            this->headers()["ETag"]);
        });

      this->register_route(
        elle::sprintf("/s3/%s_data", t.id),
        reactor::http::Method::PUT,
        [] (Server::Headers const&,
            Server::Cookies const&,
            Server::Parameters const&,
            elle::Buffer const&)
        {
          return "";
        });

      this->register_route(
        elle::sprintf("/s3/%s/000000000000_0000", t.id),
        reactor::http::Method::PUT,
        [this] (Server::Headers const&,
                Server::Cookies const&,
                Server::Parameters const&,
                elle::Buffer const&)
        {
          return "";
        });

      return elle::sprintf(
        "{"
        "  \"transaction\": %s,"
        "  \"aws_credentials\": "
        "  {"
        "    \"access_key_id\": \"\","
        "    \"bucket\": \"\","
        "    \"expiration\": \"2016-01-12T09-37-42Z\","
        "    \"folder\": \"%s\","
        "    \"protocol\": \"aws\","
        "    \"region\": \"us-east-1\","
        "    \"secret_access_key\": \"\","
        "    \"session_token\": \"\","
        "    \"current_time\": \"2015-01-12T09-37-42Z\""
        "  }"
        "}",
        link_representation(t),
        t.id);
    });

  this->register_route(
    "/transaction/create",
    reactor::http::Method::POST,
    [&] (Server::Headers const&,
         Server::Cookies const& cookies,
         Server::Parameters const&,
         elle::Buffer const& content)
    {
      auto& user = this->user(cookies);
      auto device = this->device(cookies);
      ELLE_TRACE_SCOPE("%s: create transaction", *this);
      elle::IOStream stream(new elle::InputStreamBuffer<elle::Buffer>(content));
      elle::serialization::json::SerializerIn input(stream, false);
      std::string recipient_email;
      input.serialize("id_or_email", recipient_email);
      std::list<std::string> files;
      input.serialize("files", files);

      auto t = elle::make_unique<Transaction>();
      t->id = boost::lexical_cast<std::string>(boost::uuids::random_generator()());
      t->sender_id = boost::lexical_cast<std::string>(user.id());
      t->sender_device_id = boost::lexical_cast<std::string>(device.id());
      t->files = files;
      t->status_copy(infinit::oracles::Transaction::Status::created);
      t->status = infinit::oracles::Transaction::Status::created;
      auto& users_by_email = this->_users.get<1>();
      auto recipient = users_by_email.find(recipient_email);
      bool ghost = (recipient == users_by_email.end());
      auto& rec = ghost
        ? generate_ghost_user(recipient_email)
        : **recipient;
      t->recipient_id = boost::lexical_cast<std::string>(rec.id());
      t->is_ghost = ghost;
      rec.swaggers.insert(&user);
      user.swaggers.insert(&rec);

      auto res = elle::sprintf(
        "{"
        "  \"created_transaction_id\": \"%s\","
        "  \"recipient_is_ghost\": %s,"
        "  \"recipient\": %s"
        "}",
        t->id,
        ghost ? "true" : "false",
        rec.json());

      std::string id = t->id;
      this->register_route(
        elle::sprintf("/transaction/%s", id),
        reactor::http::Method::GET,
        [&, id] (Server::Headers const&,
                 Server::Cookies const& cookies,
                 Server::Parameters const&,
                 elle::Buffer const& content)
        {
          auto& tr = **this->_transactions.find(id);
          std::stringstream notification_stream;
          {
            typename elle::serialization::json::SerializerOut output(notification_stream);
            tr.serialize(output);
          }
          return notification_stream.str();
        });

      this->register_route(
        elle::sprintf("/transaction/%s/endpoints", id),
        reactor::http::Method::PUT,
        [&, id] (Server::Headers const&,
                 Server::Cookies const& cookies,
                 Server::Parameters const&,
                 elle::Buffer const& content)
        {
          typedef std::vector<std::pair<std::string, int>> Locals;
          Locals locals;

          // XXX: Doesn't work.
          // elle::IOStream stream(new elle::InputStreamBuffer<elle::Buffer>(content));
          // elle::serialization::json::SerializerIn input(stream, false);
          // typedef std::vector<std::pair<std::string, int>> Locals;
          // Locals locals;
          // input.serialize("locals", locals);
          // for (auto const& elt_: locals)
          // {
          //   auto const& elt = boost::any_cast<elle::json::Object>(elt_);
          //   auto ip = boost::any_cast<std::string>(elt.at("ip"));
          //   auto port = boost::any_cast<int64_t>(elt.at("port"));
          //   // locals.push_back(std::pair<std::string, int>(ip, port));
          // }

          static std::unordered_map<std::string, Locals> first_time;
          if (first_time.find(id) == first_time.end())
            first_time[id] = locals;
          else
          {
            auto& tr = **this->_transactions.find(id);
            auto notif = elle::sprint("{"
                                      "transaction_id: %s,"
                                      "peer_endpoints:[{'locals':%s,'externals':[]}],"
                                      "devices:[%s, %s],"
                                      "status:true"
                                      "}",
                                      id,
                                      locals,
                                      tr.sender_device_id,
                                      tr.recipient_device_id);
            this->trophonius.device(boost::uuids::string_generator()(tr.sender_device_id))->write(notif);
            this->trophonius.device(boost::uuids::string_generator()(tr.recipient_device_id))->write(notif);
          }
          return "{}";
        });

      this->register_route(
        elle::sprintf("/transaction/%s/cloud_buffer", t->id),
        reactor::http::Method::GET,
        [&] (Server::Headers const&,
             Server::Cookies const&,
             Server::Parameters const&,
             elle::Buffer const&)
        {
          auto now = boost::posix_time::second_clock::universal_time();
          auto tomorrow = now + boost::posix_time::hours(24);
          return elle::sprintf(
            "{"
            "  \"access_key_id\": \"\","
            "  \"secret_access_key\": \"\","
            "  \"session_token\": \"\","
            "  \"region\": \"region\","
            "  \"bucket\": \"bucket\","
            "  \"folder\": \"folder\","
            "  \"expiration\": \"%s\","
            "  \"current_time\": \"%s\""
            "}",
            boost::posix_time::to_iso_extended_string(tomorrow),
            boost::posix_time::to_iso_extended_string(now));
        });
      this->_transactions.insert(std::move(t));
      return res;
    });


  this->register_route(
    "/transaction/update",
    reactor::http::Method::POST,
    [&] (Server::Headers const&,
         Server::Cookies const& cookies,
         Server::Parameters const&,
         elle::Buffer const& content)
    {
      elle::IOStream stream(new elle::InputStreamBuffer<elle::Buffer>(content));
      elle::serialization::json::SerializerIn input(stream, false);
      std::string id;
      int status;
      input.serialize("transaction_id", id);
      input.serialize("status", status);
      auto it = this->_transactions.find(id);
      if (it == this->_transactions.end())
      {
        throw reactor::http::tests::Server::Exception(
          "/transaction/update",
          reactor::http::StatusCode::Not_Found,
          "transaction not found");
      }
      auto& t = **it;
      t.status = infinit::oracles::Transaction::Status(status);
      if (t.status == infinit::oracles::Transaction::Status::accepted)
      {
        auto const& user = this->user(cookies);
        auto device = this->device(cookies);
        t.recipient_id = boost::lexical_cast<std::string>(user.id());
        t.recipient_device_id = boost::lexical_cast<std::string>(device.id());
      }
      t.status_changed()(t.status);
      auto& tr = **this->_transactions.find(id);
      std::stringstream notification_stream;
      {
        typename elle::serialization::json::SerializerOut output(notification_stream);
        tr.serialize(output);
      }
      std::string transaction_notification = notification_stream.str();
      transaction_notification.insert(1, "\"notification_type\":7,");
      for (auto& socket: this->trophonius.clients(boost::uuids::string_generator()(tr.sender_id)))
        socket->write(transaction_notification);
      for (auto& socket: this->trophonius.clients(boost::uuids::string_generator()(tr.recipient_id)))
        socket->write(transaction_notification);
      auto res = elle::sprintf(
        "{"
        "%s"
        "  \"updated_transaction_id\": \"%s\""
        "}",
        t.status == infinit::oracles::Transaction::Status::accepted
        ? elle::sprintf("  \"recipent_device_id\": \"%s\", \"recipient_device_name\": \"bite\", ", tr.recipient_device_id)
        : std::string{},
        tr.id
      );
      return res;
    });

  this->register_route(
    "/s3/folder/filename",
    reactor::http::Method::POST,
    [] (Server::Headers const&,
        Server::Cookies const&,
        Server::Parameters const& parameters,
        elle::Buffer const&)
    {
      if (contains(parameters, "uploads"))
        return
          "<InitiateMultipartUploadResult>"
          "  <UploadId>upload-id</UploadId>"
          "</InitiateMultipartUploadResult>";
      else
        return
          "<CompleteMultipartUploadResult>"
          "</CompleteMultipartUploadResult>";
    });
  this->register_route(
    "/s3/folder/filename",
    reactor::http::Method::PUT,
    [] (Server::Headers const&,
        Server::Cookies const&,
        Server::Parameters const&,
        elle::Buffer const&)
    {
      return "";
    });
  this->register_route(
    "/s3/folder/meta_data",
    reactor::http::Method::PUT,
    [] (Server::Headers const&,
        Server::Cookies const&,
        Server::Parameters const&,
        elle::Buffer const&)
    {
      return "";
    });
  this->register_route(
    "/s3/folder/000000000000_0",
    reactor::http::Method::PUT,
    [this] (Server::Headers const&,
            Server::Cookies const&,
            Server::Parameters const&,
            elle::Buffer const&)
    {
      this->_cloud_buffered = true;
      return "";
    });
}

Server::User&
Server::user(Server::Cookies const& cookies) const
{
  try
  {
    if (contains(cookies, "session-id"))
    {
      auto& users = this->_users.get<0>();
      std::string session_id = cookies.at("session-id");
      std::vector<std::string> strs;
      boost::split(strs, session_id, boost::is_any_of("+"));
      auto const& user = users.find(boost::uuids::string_generator()(strs[0]));
      if (user != users.end())
      {
        if (*user != nullptr)
          return **user;
      }
    }
  }
  catch (...)
  {}
  ELLE_LOG("cookies: %s", cookies);
  for (auto const& user: this->_users.get<0>())
    ELLE_LOG("user: %s", *user);
  throw Server::Exception(" ", reactor::http::StatusCode::Forbidden, " ");
}

Server::Device
Server::device(Server::Cookies const& cookies) const
{
  try
  {
    if (contains(cookies, "session-id"))
    {
      auto& devices = this->_devices;
      std::string session_id = cookies.at("session-id");
      std::vector<std::string> strs;
      boost::split(strs, session_id, boost::is_any_of("+"));
      auto const& device = devices.find(boost::uuids::string_generator()(strs[1]));
      if (device != devices.end())
      {
        return device->second;
      }
    }
  }
  catch (...)
  {}
  ELLE_LOG("cookies: %s", cookies);
  throw Server::Exception(" ", reactor::http::StatusCode::Forbidden, " ");
}

Server::User&
Server::register_user(std::string const& email,
                      std::string const& password)
{
  auto password_hash = infinit::oracles::meta::old_password_hash(email, password);
  auto generator = boost::uuids::random_generator();
  auto id = generator();
  auto keys =
    cryptography::KeyPair::generate(cryptography::Cryptosystem::rsa,
                                    papier::Identity::keypair_length);
  ELLE_TRACE_SCOPE("%s: generate user %s", *this, id);
  auto identity = generate_identity(
    keys, boost::lexical_cast<std::string>(id), "my identity", password_hash);
  std::string identity_serialized;
  identity.Save(identity_serialized);
  auto response =
    [this, id, email, identity_serialized, keys]
    (Server::Headers const&,
     Server::Cookies const&,
     Server::Parameters const&,
     elle::Buffer const&)
    {
      ELLE_TRACE_SCOPE("%s: fetch user %s (%s)", *this, id, email);
      std::string public_key;
      keys.K().Save(public_key);
      return elle::sprintf(
        "{"
        "  \"id\": \"%s\","
        "  \"email\": \"%s\","
        "  \"identity\": \"%s\","
        "  \"public_key\": \"%s\","
        "  \"fullname\": \"John User\","
        "  \"handle\": \"john\","
        "  \"connected_devices\": [],"
        "  \"status\": false,"
        "  \"devices\": [],"
        "  \"favorites\": [],"
        "  \"register_status\": \"ok\""
        "}",
        id, email, identity_serialized, public_key);
    };
  this->register_route(elle::sprintf("/users/%s", email),
                       reactor::http::Method::GET, response);
  this->register_route(elle::sprintf("/users/%s", id),
                       reactor::http::Method::GET, response);
  this->register_route("/user/self",
                       reactor::http::Method::GET, response);

  auto user = elle::make_unique<User>(
    id,
    std::move(email),
    std::move(keys),
    std::move(identity));
  auto raw = user.get();
  this->_users.insert(std::move(user));
  return *raw;
}

Server::User&
Server::generate_ghost_user(std::string const& email)
{
  ELLE_ASSERT(this->_users.get<1>().find(email) == this->_users.get<1>().end());
  auto id = boost::uuids::random_generator()();

  auto user = elle::make_unique<User>(
    id,
    std::move(email),
    boost::optional<cryptography::KeyPair>{},
    boost::optional<papier::Identity>{});

  auto response =
    [this, id, email]
    (Server::Headers const&,
     Server::Cookies const&,
     Server::Parameters const&,
     elle::Buffer const&)
    {
      ELLE_TRACE_SCOPE("%s: fetch ghost user %s (%s)", *this, id, email);
      return elle::sprintf(
        "{"
        "  \"id\": \"%s\","
        "  \"public_key\": \"\","
        "  \"fullname\": \"Eric Draven\","
        "  \"handle\": \"thecrow\","
        "  \"connected_devices\": [],"
        "  \"status\": false,"
        "  \"register_status\": \"ghost\""
        "}",
        id);
    };
  this->register_route(elle::sprintf("/users/%s", email),
                       reactor::http::Method::GET, response);
  this->register_route(elle::sprintf("/users/%s", id),
                       reactor::http::Method::GET, response);

  auto raw = user.get();
  this->_users.insert(std::move(user));
  return *raw;
}

void
Server::register_device(User& user,
                        boost::optional<boost::uuids::uuid> device_id)
{
  Device device{ user.identity().get().pair().K(), device_id };
  user.devices.insert(device.id());
  this->_devices.emplace(device.id(), device);
  this->register_route(
    elle::sprintf("/device/%s/view", device.id()),
    reactor::http::Method::GET,
    [device] (Server::Headers const&,
                           Server::Cookies const&,
                           Server::Parameters const&,
              elle::Buffer const&)
    {
      return device.json();
    });
}

std::string
Server::_get_trophonius(Headers const&,
                        Cookies const&,
                        Parameters const&,
                        elle::Buffer const&) const
{
  return elle::sprintf(
    "{"
    "  \"host\": \"127.0.0.1\","
    "  \"port\": 0,"
    "  \"port_ssl\": %s"
    "}",
    this->trophonius.port());
}

Server::Transaction&
Server::transaction(std::string const& id)
{
  auto it = this->_transactions.find(id);
  ELLE_ASSERT(it != this->_transactions.end());
  return **it;
}

void
Server::session_id(boost::uuids::uuid id)
{
  this->_session_id = std::move(id);
}

Server::Transaction::Transaction()
{
  this->id = boost::lexical_cast<std::string>(
    boost::uuids::random_generator()());
}

std::string
Server::Transaction::json() const
{
  return elle::sprintf(
    "{"
    "  _id: \"%s\","
    "  sender_id:\"%s\","
    "  sender_fullname: \"osef\","
    "  sender_device_id:\"%s\","
    "  recipient_id:\"%s\","
    "  recipient_fullname:\"osef aussi\","
    "  recipient_device_id:\"%s\","
    "  recipient_device_name:\"osef aussi\","
    "  message:\"quedalle\","
    "  files:\"%s\","
    "  files_count: %s,"
    "  total_size: 3291,"
    "  ctime: 15323203,",
    "  mtime:15323203,"
    "  is_directory: 0"
    "}",
    this->id,
    this->sender_id,
    this->sender_device_id,
    this->recipient_id,
    this->recipient_device_id,
    this->files,
    this->files.size()
  );
}

void
Server::Transaction::print(std::ostream& out) const
{
  out << "Transaction("
      << this->id << ", "
      << this->status
      << ")";
}

State::State(Server& server,
             boost::uuids::uuid device_id)
  : TemporaryHome{}
  , surface::gap::State(
    "http", "127.0.0.1", server.port(),
    std::move(device_id), fingerprint,
    elle::os::path::join(elle::system::home_directory().string(), "Downloads"))
{
  this->s3_hostname(aws::URL{"http://",
                             elle::sprintf("localhost:%s", server.port()),
                             "/s3"});
}

const std::vector<unsigned char> fingerprint =
{
  0x66, 0x84, 0x68, 0xEB, 0xBE, 0x83, 0xA0, 0x5C, 0x6A, 0x32,
  0xAD, 0xD2, 0x58, 0x62, 0x01, 0x31, 0x79, 0x96, 0x78, 0xB8
};

const std::vector<char> server_certificate =
{
  0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x44, 0x61, 0x74, 0x61, 0x3a, 0x0a, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69,
  0x6f, 0x6e, 0x3a, 0x20, 0x33, 0x20, 0x28, 0x30, 0x78, 0x32, 0x29, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x65, 0x72, 0x69,
  0x61, 0x6c, 0x20, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x3a, 0x20, 0x34,
  0x30, 0x39, 0x36, 0x20, 0x28, 0x30, 0x78, 0x31, 0x30, 0x30, 0x30, 0x29,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,
  0x72, 0x65, 0x20, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d,
  0x3a, 0x20, 0x73, 0x68, 0x61, 0x31, 0x57, 0x69, 0x74, 0x68, 0x52, 0x53,
  0x41, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x49, 0x73, 0x73, 0x75,
  0x65, 0x72, 0x3a, 0x20, 0x43, 0x3d, 0x46, 0x52, 0x2c, 0x20, 0x53, 0x54,
  0x3d, 0x49, 0x6c, 0x65, 0x2d, 0x64, 0x65, 0x2d, 0x46, 0x72, 0x61, 0x6e,
  0x63, 0x65, 0x2c, 0x20, 0x4c, 0x3d, 0x50, 0x61, 0x72, 0x69, 0x73, 0x2c,
  0x20, 0x4f, 0x3d, 0x49, 0x6e, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x2e, 0x69,
  0x6f, 0x2c, 0x20, 0x4f, 0x55, 0x3d, 0x44, 0x65, 0x76, 0x65, 0x6c, 0x6f,
  0x70, 0x6d, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x43, 0x4e, 0x3d, 0x4c, 0x6f,
  0x75, 0x69, 0x73, 0x20, 0x46, 0x45, 0x55, 0x56, 0x52, 0x49, 0x45, 0x52,
  0x2f, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
  0x73, 0x3d, 0x6c, 0x6f, 0x75, 0x69, 0x73, 0x2e, 0x66, 0x65, 0x75, 0x76,
  0x72, 0x69, 0x65, 0x72, 0x40, 0x69, 0x6e, 0x66, 0x69, 0x6e, 0x69, 0x74,
  0x2e, 0x69, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x56, 0x61, 0x6c, 0x69, 0x64, 0x69, 0x74, 0x79, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4e, 0x6f, 0x74,
  0x20, 0x42, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x3a, 0x20, 0x44, 0x65, 0x63,
  0x20, 0x20, 0x35, 0x20, 0x31, 0x30, 0x3a, 0x35, 0x39, 0x3a, 0x34, 0x38,
  0x20, 0x32, 0x30, 0x31, 0x33, 0x20, 0x47, 0x4d, 0x54, 0x0a, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4e, 0x6f,
  0x74, 0x20, 0x41, 0x66, 0x74, 0x65, 0x72, 0x20, 0x3a, 0x20, 0x44, 0x65,
  0x63, 0x20, 0x20, 0x35, 0x20, 0x31, 0x30, 0x3a, 0x35, 0x39, 0x3a, 0x34,
  0x38, 0x20, 0x32, 0x30, 0x31, 0x34, 0x20, 0x47, 0x4d, 0x54, 0x0a, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x75, 0x62, 0x6a, 0x65,
  0x63, 0x74, 0x3a, 0x20, 0x43, 0x3d, 0x46, 0x52, 0x2c, 0x20, 0x53, 0x54,
  0x3d, 0x49, 0x6c, 0x65, 0x2d, 0x64, 0x65, 0x2d, 0x46, 0x72, 0x61, 0x6e,
  0x63, 0x65, 0x2c, 0x20, 0x4f, 0x3d, 0x49, 0x6e, 0x66, 0x69, 0x6e, 0x69,
  0x74, 0x2e, 0x69, 0x6f, 0x2c, 0x20, 0x4f, 0x55, 0x3d, 0x44, 0x65, 0x76,
  0x65, 0x6c, 0x6f, 0x70, 0x6d, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x43, 0x4e,
  0x3d, 0x4c, 0x6f, 0x75, 0x69, 0x73, 0x20, 0x46, 0x45, 0x55, 0x56, 0x52,
  0x49, 0x45, 0x52, 0x2f, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x41, 0x64, 0x64,
  0x72, 0x65, 0x73, 0x73, 0x3d, 0x6c, 0x6f, 0x75, 0x69, 0x73, 0x2e, 0x66,
  0x65, 0x75, 0x76, 0x72, 0x69, 0x65, 0x72, 0x40, 0x69, 0x6e, 0x66, 0x69,
  0x6e, 0x69, 0x74, 0x2e, 0x69, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x53, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x50,
  0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x4b, 0x65, 0x79, 0x20, 0x49, 0x6e,
  0x66, 0x6f, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x4b,
  0x65, 0x79, 0x20, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d,
  0x3a, 0x20, 0x72, 0x73, 0x61, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,
  0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x50, 0x75, 0x62, 0x6c,
  0x69, 0x63, 0x2d, 0x4b, 0x65, 0x79, 0x3a, 0x20, 0x28, 0x31, 0x30, 0x32,
  0x34, 0x20, 0x62, 0x69, 0x74, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4d,
  0x6f, 0x64, 0x75, 0x6c, 0x75, 0x73, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x30, 0x30, 0x3a, 0x64, 0x30, 0x3a, 0x66, 0x66,
  0x3a, 0x61, 0x30, 0x3a, 0x34, 0x34, 0x3a, 0x63, 0x66, 0x3a, 0x65, 0x35,
  0x3a, 0x30, 0x65, 0x3a, 0x63, 0x34, 0x3a, 0x62, 0x66, 0x3a, 0x32, 0x32,
  0x3a, 0x35, 0x33, 0x3a, 0x64, 0x38, 0x3a, 0x30, 0x65, 0x3a, 0x36, 0x39,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x61,
  0x3a, 0x31, 0x61, 0x3a, 0x33, 0x65, 0x3a, 0x31, 0x64, 0x3a, 0x37, 0x38,
  0x3a, 0x63, 0x39, 0x3a, 0x35, 0x32, 0x3a, 0x38, 0x35, 0x3a, 0x38, 0x30,
  0x3a, 0x31, 0x63, 0x3a, 0x65, 0x35, 0x3a, 0x65, 0x64, 0x3a, 0x66, 0x35,
  0x3a, 0x32, 0x62, 0x3a, 0x30, 0x37, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x66, 0x63, 0x3a, 0x63, 0x37, 0x3a, 0x32, 0x62,
  0x3a, 0x63, 0x61, 0x3a, 0x31, 0x38, 0x3a, 0x37, 0x35, 0x3a, 0x66, 0x37,
  0x3a, 0x39, 0x31, 0x3a, 0x35, 0x61, 0x3a, 0x39, 0x32, 0x3a, 0x37, 0x39,
  0x3a, 0x35, 0x35, 0x3a, 0x66, 0x36, 0x3a, 0x65, 0x39, 0x3a, 0x34, 0x32,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x30,
  0x3a, 0x65, 0x30, 0x3a, 0x61, 0x33, 0x3a, 0x64, 0x66, 0x3a, 0x66, 0x62,
  0x3a, 0x33, 0x65, 0x3a, 0x62, 0x34, 0x3a, 0x34, 0x32, 0x3a, 0x64, 0x30,
  0x3a, 0x34, 0x62, 0x3a, 0x66, 0x35, 0x3a, 0x65, 0x62, 0x3a, 0x30, 0x35,
  0x3a, 0x34, 0x34, 0x3a, 0x33, 0x32, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x32, 0x63, 0x3a, 0x34, 0x61, 0x3a, 0x38, 0x35,
  0x3a, 0x64, 0x30, 0x3a, 0x65, 0x31, 0x3a, 0x61, 0x33, 0x3a, 0x36, 0x63,
  0x3a, 0x61, 0x61, 0x3a, 0x66, 0x30, 0x3a, 0x30, 0x31, 0x3a, 0x66, 0x37,
  0x3a, 0x31, 0x32, 0x3a, 0x63, 0x34, 0x3a, 0x30, 0x65, 0x3a, 0x66, 0x66,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x30,
  0x3a, 0x61, 0x31, 0x3a, 0x37, 0x34, 0x3a, 0x64, 0x32, 0x3a, 0x36, 0x35,
  0x3a, 0x32, 0x30, 0x3a, 0x64, 0x62, 0x3a, 0x35, 0x61, 0x3a, 0x30, 0x33,
  0x3a, 0x37, 0x38, 0x3a, 0x63, 0x37, 0x3a, 0x35, 0x34, 0x3a, 0x61, 0x31,
  0x3a, 0x62, 0x63, 0x3a, 0x64, 0x37, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x38, 0x33, 0x3a, 0x66, 0x66, 0x3a, 0x39, 0x37,
  0x3a, 0x37, 0x38, 0x3a, 0x62, 0x64, 0x3a, 0x31, 0x34, 0x3a, 0x64, 0x36,
  0x3a, 0x35, 0x31, 0x3a, 0x33, 0x35, 0x3a, 0x62, 0x61, 0x3a, 0x36, 0x30,
  0x3a, 0x31, 0x62, 0x3a, 0x66, 0x66, 0x3a, 0x39, 0x34, 0x3a, 0x62, 0x66,
  0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x37, 0x65,
  0x3a, 0x34, 0x63, 0x3a, 0x34, 0x34, 0x3a, 0x61, 0x62, 0x3a, 0x63, 0x63,
  0x3a, 0x62, 0x36, 0x3a, 0x39, 0x33, 0x3a, 0x30, 0x63, 0x3a, 0x36, 0x61,
  0x3a, 0x35, 0x66, 0x3a, 0x38, 0x36, 0x3a, 0x38, 0x65, 0x3a, 0x32, 0x38,
  0x3a, 0x36, 0x62, 0x3a, 0x39, 0x31, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x65, 0x64, 0x3a, 0x32, 0x38, 0x3a, 0x62, 0x61,
  0x3a, 0x34, 0x61, 0x3a, 0x36, 0x66, 0x3a, 0x34, 0x66, 0x3a, 0x33, 0x33,
  0x3a, 0x33, 0x66, 0x3a, 0x34, 0x35, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x45,
  0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x3a, 0x20, 0x36, 0x35, 0x35,
  0x33, 0x37, 0x20, 0x28, 0x30, 0x78, 0x31, 0x30, 0x30, 0x30, 0x31, 0x29,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x58, 0x35, 0x30,
  0x39, 0x76, 0x33, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f,
  0x6e, 0x73, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x58, 0x35, 0x30, 0x39, 0x76, 0x33, 0x20, 0x42,
  0x61, 0x73, 0x69, 0x63, 0x20, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61,
  0x69, 0x6e, 0x74, 0x73, 0x3a, 0x20, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x43,
  0x41, 0x3a, 0x46, 0x41, 0x4c, 0x53, 0x45, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4e, 0x65, 0x74, 0x73,
  0x63, 0x61, 0x70, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74,
  0x3a, 0x20, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4f, 0x70, 0x65, 0x6e, 0x53,
  0x53, 0x4c, 0x20, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64,
  0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x58, 0x35, 0x30, 0x39, 0x76, 0x33, 0x20, 0x53, 0x75, 0x62, 0x6a,
  0x65, 0x63, 0x74, 0x20, 0x4b, 0x65, 0x79, 0x20, 0x49, 0x64, 0x65, 0x6e,
  0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x3a, 0x20, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x44, 0x35, 0x3a, 0x35, 0x44, 0x3a, 0x43, 0x36, 0x3a, 0x32, 0x43,
  0x3a, 0x41, 0x42, 0x3a, 0x31, 0x46, 0x3a, 0x42, 0x44, 0x3a, 0x32, 0x41,
  0x3a, 0x35, 0x42, 0x3a, 0x45, 0x38, 0x3a, 0x34, 0x46, 0x3a, 0x43, 0x36,
  0x3a, 0x36, 0x38, 0x3a, 0x42, 0x38, 0x3a, 0x42, 0x42, 0x3a, 0x33, 0x32,
  0x3a, 0x38, 0x37, 0x3a, 0x44, 0x34, 0x3a, 0x31, 0x44, 0x3a, 0x45, 0x35,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x58, 0x35, 0x30, 0x39, 0x76, 0x33, 0x20, 0x41, 0x75, 0x74, 0x68,
  0x6f, 0x72, 0x69, 0x74, 0x79, 0x20, 0x4b, 0x65, 0x79, 0x20, 0x49, 0x64,
  0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x3a, 0x20, 0x0a, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x6b, 0x65, 0x79, 0x69, 0x64, 0x3a, 0x33, 0x37, 0x3a,
  0x38, 0x38, 0x3a, 0x37, 0x35, 0x3a, 0x43, 0x33, 0x3a, 0x34, 0x45, 0x3a,
  0x34, 0x42, 0x3a, 0x31, 0x33, 0x3a, 0x46, 0x33, 0x3a, 0x30, 0x32, 0x3a,
  0x37, 0x46, 0x3a, 0x30, 0x43, 0x3a, 0x42, 0x44, 0x3a, 0x44, 0x30, 0x3a,
  0x39, 0x43, 0x3a, 0x38, 0x35, 0x3a, 0x34, 0x36, 0x3a, 0x46, 0x39, 0x3a,
  0x42, 0x46, 0x3a, 0x34, 0x31, 0x3a, 0x44, 0x46, 0x0a, 0x0a, 0x20, 0x20,
  0x20, 0x20, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x20,
  0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x3a, 0x20, 0x73,
  0x68, 0x61, 0x31, 0x57, 0x69, 0x74, 0x68, 0x52, 0x53, 0x41, 0x45, 0x6e,
  0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x32, 0x61, 0x3a, 0x36, 0x35, 0x3a,
  0x63, 0x39, 0x3a, 0x33, 0x31, 0x3a, 0x66, 0x39, 0x3a, 0x65, 0x66, 0x3a,
  0x62, 0x35, 0x3a, 0x37, 0x37, 0x3a, 0x65, 0x37, 0x3a, 0x37, 0x36, 0x3a,
  0x66, 0x61, 0x3a, 0x30, 0x63, 0x3a, 0x34, 0x39, 0x3a, 0x64, 0x61, 0x3a,
  0x33, 0x33, 0x3a, 0x36, 0x33, 0x3a, 0x61, 0x38, 0x3a, 0x35, 0x38, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x33,
  0x3a, 0x38, 0x31, 0x3a, 0x64, 0x61, 0x3a, 0x64, 0x37, 0x3a, 0x37, 0x32,
  0x3a, 0x36, 0x35, 0x3a, 0x66, 0x39, 0x3a, 0x39, 0x63, 0x3a, 0x30, 0x36,
  0x3a, 0x65, 0x31, 0x3a, 0x39, 0x36, 0x3a, 0x36, 0x36, 0x3a, 0x66, 0x63,
  0x3a, 0x38, 0x38, 0x3a, 0x61, 0x38, 0x3a, 0x63, 0x34, 0x3a, 0x31, 0x63,
  0x3a, 0x38, 0x66, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x62, 0x65, 0x3a, 0x36, 0x36, 0x3a, 0x39, 0x38, 0x3a, 0x33,
  0x64, 0x3a, 0x64, 0x62, 0x3a, 0x61, 0x65, 0x3a, 0x36, 0x32, 0x3a, 0x63,
  0x33, 0x3a, 0x66, 0x63, 0x3a, 0x37, 0x32, 0x3a, 0x66, 0x63, 0x3a, 0x32,
  0x62, 0x3a, 0x64, 0x37, 0x3a, 0x36, 0x63, 0x3a, 0x39, 0x37, 0x3a, 0x30,
  0x65, 0x3a, 0x31, 0x63, 0x3a, 0x35, 0x32, 0x3a, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x39, 0x3a, 0x63, 0x63, 0x3a,
  0x66, 0x64, 0x3a, 0x65, 0x35, 0x3a, 0x66, 0x32, 0x3a, 0x65, 0x39, 0x3a,
  0x62, 0x36, 0x3a, 0x65, 0x31, 0x3a, 0x31, 0x38, 0x3a, 0x31, 0x30, 0x3a,
  0x33, 0x32, 0x3a, 0x36, 0x63, 0x3a, 0x31, 0x35, 0x3a, 0x38, 0x66, 0x3a,
  0x36, 0x63, 0x3a, 0x61, 0x34, 0x3a, 0x32, 0x64, 0x3a, 0x64, 0x35, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x31,
  0x3a, 0x35, 0x39, 0x3a, 0x38, 0x31, 0x3a, 0x39, 0x65, 0x3a, 0x37, 0x34,
  0x3a, 0x62, 0x32, 0x3a, 0x66, 0x35, 0x3a, 0x64, 0x35, 0x3a, 0x34, 0x37,
  0x3a, 0x38, 0x32, 0x3a, 0x34, 0x32, 0x3a, 0x32, 0x61, 0x3a, 0x31, 0x36,
  0x3a, 0x35, 0x32, 0x3a, 0x38, 0x32, 0x3a, 0x30, 0x61, 0x3a, 0x62, 0x63,
  0x3a, 0x32, 0x61, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x37, 0x33, 0x3a, 0x30, 0x39, 0x3a, 0x66, 0x65, 0x3a, 0x38,
  0x63, 0x3a, 0x61, 0x36, 0x3a, 0x34, 0x30, 0x3a, 0x30, 0x63, 0x3a, 0x34,
  0x39, 0x3a, 0x30, 0x36, 0x3a, 0x66, 0x62, 0x3a, 0x31, 0x34, 0x3a, 0x66,
  0x62, 0x3a, 0x35, 0x38, 0x3a, 0x63, 0x30, 0x3a, 0x34, 0x66, 0x3a, 0x36,
  0x32, 0x3a, 0x33, 0x63, 0x3a, 0x65, 0x30, 0x3a, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x61, 0x3a, 0x62, 0x36, 0x3a,
  0x63, 0x38, 0x3a, 0x36, 0x36, 0x3a, 0x38, 0x64, 0x3a, 0x37, 0x37, 0x3a,
  0x63, 0x30, 0x3a, 0x36, 0x62, 0x3a, 0x36, 0x61, 0x3a, 0x64, 0x32, 0x3a,
  0x37, 0x33, 0x3a, 0x39, 0x37, 0x3a, 0x61, 0x35, 0x3a, 0x33, 0x33, 0x3a,
  0x30, 0x63, 0x3a, 0x62, 0x33, 0x3a, 0x64, 0x33, 0x3a, 0x34, 0x62, 0x3a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x39,
  0x3a, 0x39, 0x33, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47,
  0x49, 0x4e, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41,
  0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x44,
  0x4b, 0x6a, 0x43, 0x43, 0x41, 0x70, 0x4f, 0x67, 0x41, 0x77, 0x49, 0x42,
  0x41, 0x67, 0x49, 0x43, 0x45, 0x41, 0x41, 0x77, 0x44, 0x51, 0x59, 0x4a,
  0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x46,
  0x42, 0x51, 0x41, 0x77, 0x67, 0x61, 0x4d, 0x78, 0x43, 0x7a, 0x41, 0x4a,
  0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59, 0x54, 0x41, 0x6b, 0x5a, 0x53,
  0x0a, 0x4d, 0x52, 0x59, 0x77, 0x46, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51,
  0x49, 0x44, 0x41, 0x31, 0x4a, 0x62, 0x47, 0x55, 0x74, 0x5a, 0x47, 0x55,
  0x74, 0x52, 0x6e, 0x4a, 0x68, 0x62, 0x6d, 0x4e, 0x6c, 0x4d, 0x51, 0x34,
  0x77, 0x44, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51, 0x48, 0x44, 0x41, 0x56,
  0x51, 0x59, 0x58, 0x4a, 0x70, 0x63, 0x7a, 0x45, 0x54, 0x4d, 0x42, 0x45,
  0x47, 0x41, 0x31, 0x55, 0x45, 0x0a, 0x43, 0x67, 0x77, 0x4b, 0x53, 0x57,
  0x35, 0x6d, 0x61, 0x57, 0x35, 0x70, 0x64, 0x43, 0x35, 0x70, 0x62, 0x7a,
  0x45, 0x55, 0x4d, 0x42, 0x49, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x77,
  0x77, 0x4c, 0x52, 0x47, 0x56, 0x32, 0x5a, 0x57, 0x78, 0x76, 0x63, 0x47,
  0x31, 0x6c, 0x62, 0x6e, 0x51, 0x78, 0x46, 0x7a, 0x41, 0x56, 0x42, 0x67,
  0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x44, 0x6b, 0x78, 0x76, 0x0a, 0x64,
  0x57, 0x6c, 0x7a, 0x49, 0x45, 0x5a, 0x46, 0x56, 0x56, 0x5a, 0x53, 0x53,
  0x55, 0x56, 0x53, 0x4d, 0x53, 0x67, 0x77, 0x4a, 0x67, 0x59, 0x4a, 0x4b,
  0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x6b, 0x42, 0x46,
  0x68, 0x6c, 0x73, 0x62, 0x33, 0x56, 0x70, 0x63, 0x79, 0x35, 0x6d, 0x5a,
  0x58, 0x56, 0x32, 0x63, 0x6d, 0x6c, 0x6c, 0x63, 0x6b, 0x42, 0x70, 0x62,
  0x6d, 0x5a, 0x70, 0x0a, 0x62, 0x6d, 0x6c, 0x30, 0x4c, 0x6d, 0x6c, 0x76,
  0x4d, 0x42, 0x34, 0x58, 0x44, 0x54, 0x45, 0x7a, 0x4d, 0x54, 0x49, 0x77,
  0x4e, 0x54, 0x45, 0x77, 0x4e, 0x54, 0x6b, 0x30, 0x4f, 0x46, 0x6f, 0x58,
  0x44, 0x54, 0x45, 0x30, 0x4d, 0x54, 0x49, 0x77, 0x4e, 0x54, 0x45, 0x77,
  0x4e, 0x54, 0x6b, 0x30, 0x4f, 0x46, 0x6f, 0x77, 0x67, 0x5a, 0x4d, 0x78,
  0x43, 0x7a, 0x41, 0x4a, 0x42, 0x67, 0x4e, 0x56, 0x0a, 0x42, 0x41, 0x59,
  0x54, 0x41, 0x6b, 0x5a, 0x53, 0x4d, 0x52, 0x59, 0x77, 0x46, 0x41, 0x59,
  0x44, 0x56, 0x51, 0x51, 0x49, 0x44, 0x41, 0x31, 0x4a, 0x62, 0x47, 0x55,
  0x74, 0x5a, 0x47, 0x55, 0x74, 0x52, 0x6e, 0x4a, 0x68, 0x62, 0x6d, 0x4e,
  0x6c, 0x4d, 0x52, 0x4d, 0x77, 0x45, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51,
  0x4b, 0x44, 0x41, 0x70, 0x4a, 0x62, 0x6d, 0x5a, 0x70, 0x62, 0x6d, 0x6c,
  0x30, 0x0a, 0x4c, 0x6d, 0x6c, 0x76, 0x4d, 0x52, 0x51, 0x77, 0x45, 0x67,
  0x59, 0x44, 0x56, 0x51, 0x51, 0x4c, 0x44, 0x41, 0x74, 0x45, 0x5a, 0x58,
  0x5a, 0x6c, 0x62, 0x47, 0x39, 0x77, 0x62, 0x57, 0x56, 0x75, 0x64, 0x44,
  0x45, 0x58, 0x4d, 0x42, 0x55, 0x47, 0x41, 0x31, 0x55, 0x45, 0x41, 0x77,
  0x77, 0x4f, 0x54, 0x47, 0x39, 0x31, 0x61, 0x58, 0x4d, 0x67, 0x52, 0x6b,
  0x56, 0x56, 0x56, 0x6c, 0x4a, 0x4a, 0x0a, 0x52, 0x56, 0x49, 0x78, 0x4b,
  0x44, 0x41, 0x6d, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39,
  0x77, 0x30, 0x42, 0x43, 0x51, 0x45, 0x57, 0x47, 0x57, 0x78, 0x76, 0x64,
  0x57, 0x6c, 0x7a, 0x4c, 0x6d, 0x5a, 0x6c, 0x64, 0x58, 0x5a, 0x79, 0x61,
  0x57, 0x56, 0x79, 0x51, 0x47, 0x6c, 0x75, 0x5a, 0x6d, 0x6c, 0x75, 0x61,
  0x58, 0x51, 0x75, 0x61, 0x57, 0x38, 0x77, 0x67, 0x5a, 0x38, 0x77, 0x0a,
  0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e,
  0x41, 0x51, 0x45, 0x42, 0x42, 0x51, 0x41, 0x44, 0x67, 0x59, 0x30, 0x41,
  0x4d, 0x49, 0x47, 0x4a, 0x41, 0x6f, 0x47, 0x42, 0x41, 0x4e, 0x44, 0x2f,
  0x6f, 0x45, 0x54, 0x50, 0x35, 0x51, 0x37, 0x45, 0x76, 0x79, 0x4a, 0x54,
  0x32, 0x41, 0x35, 0x70, 0x57, 0x68, 0x6f, 0x2b, 0x48, 0x58, 0x6a, 0x4a,
  0x55, 0x6f, 0x57, 0x41, 0x0a, 0x48, 0x4f, 0x58, 0x74, 0x39, 0x53, 0x73,
  0x48, 0x2f, 0x4d, 0x63, 0x72, 0x79, 0x68, 0x68, 0x31, 0x39, 0x35, 0x46,
  0x61, 0x6b, 0x6e, 0x6c, 0x56, 0x39, 0x75, 0x6c, 0x43, 0x34, 0x4f, 0x43,
  0x6a, 0x33, 0x2f, 0x73, 0x2b, 0x74, 0x45, 0x4c, 0x51, 0x53, 0x2f, 0x58,
  0x72, 0x42, 0x55, 0x51, 0x79, 0x4c, 0x45, 0x71, 0x46, 0x30, 0x4f, 0x47,
  0x6a, 0x62, 0x4b, 0x72, 0x77, 0x41, 0x66, 0x63, 0x53, 0x0a, 0x78, 0x41,
  0x37, 0x2f, 0x41, 0x4b, 0x46, 0x30, 0x30, 0x6d, 0x55, 0x67, 0x32, 0x31,
  0x6f, 0x44, 0x65, 0x4d, 0x64, 0x55, 0x6f, 0x62, 0x7a, 0x58, 0x67, 0x2f,
  0x2b, 0x58, 0x65, 0x4c, 0x30, 0x55, 0x31, 0x6c, 0x45, 0x31, 0x75, 0x6d,
  0x41, 0x62, 0x2f, 0x35, 0x53, 0x2f, 0x66, 0x6b, 0x78, 0x45, 0x71, 0x38,
  0x79, 0x32, 0x6b, 0x77, 0x78, 0x71, 0x58, 0x34, 0x61, 0x4f, 0x4b, 0x47,
  0x75, 0x52, 0x0a, 0x37, 0x53, 0x69, 0x36, 0x53, 0x6d, 0x39, 0x50, 0x4d,
  0x7a, 0x39, 0x46, 0x41, 0x67, 0x4d, 0x42, 0x41, 0x41, 0x47, 0x6a, 0x65,
  0x7a, 0x42, 0x35, 0x4d, 0x41, 0x6b, 0x47, 0x41, 0x31, 0x55, 0x64, 0x45,
  0x77, 0x51, 0x43, 0x4d, 0x41, 0x41, 0x77, 0x4c, 0x41, 0x59, 0x4a, 0x59,
  0x49, 0x5a, 0x49, 0x41, 0x59, 0x62, 0x34, 0x51, 0x67, 0x45, 0x4e, 0x42,
  0x42, 0x38, 0x57, 0x48, 0x55, 0x39, 0x77, 0x0a, 0x5a, 0x57, 0x35, 0x54,
  0x55, 0x30, 0x77, 0x67, 0x52, 0x32, 0x56, 0x75, 0x5a, 0x58, 0x4a, 0x68,
  0x64, 0x47, 0x56, 0x6b, 0x49, 0x45, 0x4e, 0x6c, 0x63, 0x6e, 0x52, 0x70,
  0x5a, 0x6d, 0x6c, 0x6a, 0x59, 0x58, 0x52, 0x6c, 0x4d, 0x42, 0x30, 0x47,
  0x41, 0x31, 0x55, 0x64, 0x44, 0x67, 0x51, 0x57, 0x42, 0x42, 0x54, 0x56,
  0x58, 0x63, 0x59, 0x73, 0x71, 0x78, 0x2b, 0x39, 0x4b, 0x6c, 0x76, 0x6f,
  0x0a, 0x54, 0x38, 0x5a, 0x6f, 0x75, 0x4c, 0x73, 0x79, 0x68, 0x39, 0x51,
  0x64, 0x35, 0x54, 0x41, 0x66, 0x42, 0x67, 0x4e, 0x56, 0x48, 0x53, 0x4d,
  0x45, 0x47, 0x44, 0x41, 0x57, 0x67, 0x42, 0x51, 0x33, 0x69, 0x48, 0x58,
  0x44, 0x54, 0x6b, 0x73, 0x54, 0x38, 0x77, 0x4a, 0x2f, 0x44, 0x4c, 0x33,
  0x51, 0x6e, 0x49, 0x56, 0x47, 0x2b, 0x62, 0x39, 0x42, 0x33, 0x7a, 0x41,
  0x4e, 0x42, 0x67, 0x6b, 0x71, 0x0a, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77,
  0x30, 0x42, 0x41, 0x51, 0x55, 0x46, 0x41, 0x41, 0x4f, 0x42, 0x67, 0x51,
  0x41, 0x71, 0x5a, 0x63, 0x6b, 0x78, 0x2b, 0x65, 0x2b, 0x31, 0x64, 0x2b,
  0x64, 0x32, 0x2b, 0x67, 0x78, 0x4a, 0x32, 0x6a, 0x4e, 0x6a, 0x71, 0x46,
  0x69, 0x44, 0x67, 0x64, 0x72, 0x58, 0x63, 0x6d, 0x58, 0x35, 0x6e, 0x41,
  0x62, 0x68, 0x6c, 0x6d, 0x62, 0x38, 0x69, 0x4b, 0x6a, 0x45, 0x0a, 0x48,
  0x49, 0x2b, 0x2b, 0x5a, 0x70, 0x67, 0x39, 0x32, 0x36, 0x35, 0x69, 0x77,
  0x2f, 0x78, 0x79, 0x2f, 0x43, 0x76, 0x58, 0x62, 0x4a, 0x63, 0x4f, 0x48,
  0x46, 0x4c, 0x35, 0x7a, 0x50, 0x33, 0x6c, 0x38, 0x75, 0x6d, 0x32, 0x34,
  0x52, 0x67, 0x51, 0x4d, 0x6d, 0x77, 0x56, 0x6a, 0x32, 0x79, 0x6b, 0x4c,
  0x64, 0x58, 0x42, 0x57, 0x59, 0x47, 0x65, 0x64, 0x4c, 0x4c, 0x31, 0x31,
  0x55, 0x65, 0x43, 0x0a, 0x51, 0x69, 0x6f, 0x57, 0x55, 0x6f, 0x49, 0x4b,
  0x76, 0x43, 0x70, 0x7a, 0x43, 0x66, 0x36, 0x4d, 0x70, 0x6b, 0x41, 0x4d,
  0x53, 0x51, 0x62, 0x37, 0x46, 0x50, 0x74, 0x59, 0x77, 0x45, 0x39, 0x69,
  0x50, 0x4f, 0x44, 0x4b, 0x74, 0x73, 0x68, 0x6d, 0x6a, 0x58, 0x66, 0x41,
  0x61, 0x32, 0x72, 0x53, 0x63, 0x35, 0x65, 0x6c, 0x4d, 0x77, 0x79, 0x7a,
  0x30, 0x30, 0x73, 0x4a, 0x6b, 0x77, 0x3d, 0x3d, 0x0a, 0x2d, 0x2d, 0x2d,
  0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46,
  0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a,
};

const std::vector<char> server_key =
{
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50,
  0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d,
  0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x43, 0x65, 0x41, 0x49, 0x42,
  0x41, 0x44, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47,
  0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x45, 0x46, 0x41, 0x41, 0x53, 0x43,
  0x41, 0x6d, 0x49, 0x77, 0x67, 0x67, 0x4a, 0x65, 0x41, 0x67, 0x45, 0x41,
  0x41, 0x6f, 0x47, 0x42, 0x41, 0x4e, 0x44, 0x2f, 0x6f, 0x45, 0x54, 0x50,
  0x35, 0x51, 0x37, 0x45, 0x76, 0x79, 0x4a, 0x54, 0x0a, 0x32, 0x41, 0x35,
  0x70, 0x57, 0x68, 0x6f, 0x2b, 0x48, 0x58, 0x6a, 0x4a, 0x55, 0x6f, 0x57,
  0x41, 0x48, 0x4f, 0x58, 0x74, 0x39, 0x53, 0x73, 0x48, 0x2f, 0x4d, 0x63,
  0x72, 0x79, 0x68, 0x68, 0x31, 0x39, 0x35, 0x46, 0x61, 0x6b, 0x6e, 0x6c,
  0x56, 0x39, 0x75, 0x6c, 0x43, 0x34, 0x4f, 0x43, 0x6a, 0x33, 0x2f, 0x73,
  0x2b, 0x74, 0x45, 0x4c, 0x51, 0x53, 0x2f, 0x58, 0x72, 0x42, 0x55, 0x51,
  0x79, 0x0a, 0x4c, 0x45, 0x71, 0x46, 0x30, 0x4f, 0x47, 0x6a, 0x62, 0x4b,
  0x72, 0x77, 0x41, 0x66, 0x63, 0x53, 0x78, 0x41, 0x37, 0x2f, 0x41, 0x4b,
  0x46, 0x30, 0x30, 0x6d, 0x55, 0x67, 0x32, 0x31, 0x6f, 0x44, 0x65, 0x4d,
  0x64, 0x55, 0x6f, 0x62, 0x7a, 0x58, 0x67, 0x2f, 0x2b, 0x58, 0x65, 0x4c,
  0x30, 0x55, 0x31, 0x6c, 0x45, 0x31, 0x75, 0x6d, 0x41, 0x62, 0x2f, 0x35,
  0x53, 0x2f, 0x66, 0x6b, 0x78, 0x45, 0x0a, 0x71, 0x38, 0x79, 0x32, 0x6b,
  0x77, 0x78, 0x71, 0x58, 0x34, 0x61, 0x4f, 0x4b, 0x47, 0x75, 0x52, 0x37,
  0x53, 0x69, 0x36, 0x53, 0x6d, 0x39, 0x50, 0x4d, 0x7a, 0x39, 0x46, 0x41,
  0x67, 0x4d, 0x42, 0x41, 0x41, 0x45, 0x43, 0x67, 0x59, 0x42, 0x53, 0x4c,
  0x4c, 0x41, 0x76, 0x58, 0x69, 0x36, 0x4a, 0x36, 0x41, 0x48, 0x65, 0x31,
  0x57, 0x69, 0x57, 0x41, 0x67, 0x5a, 0x54, 0x57, 0x79, 0x6a, 0x72, 0x0a,
  0x58, 0x50, 0x7a, 0x39, 0x55, 0x4b, 0x6f, 0x4d, 0x48, 0x63, 0x76, 0x50,
  0x35, 0x34, 0x77, 0x55, 0x49, 0x37, 0x75, 0x4b, 0x63, 0x70, 0x65, 0x73,
  0x70, 0x78, 0x67, 0x41, 0x62, 0x54, 0x52, 0x76, 0x38, 0x73, 0x50, 0x49,
  0x6a, 0x36, 0x5a, 0x35, 0x65, 0x75, 0x59, 0x56, 0x66, 0x79, 0x44, 0x65,
  0x79, 0x46, 0x47, 0x42, 0x78, 0x74, 0x68, 0x7a, 0x56, 0x4c, 0x6f, 0x54,
  0x78, 0x36, 0x65, 0x5a, 0x0a, 0x46, 0x4d, 0x70, 0x35, 0x47, 0x68, 0x42,
  0x37, 0x57, 0x64, 0x69, 0x33, 0x59, 0x55, 0x77, 0x50, 0x56, 0x66, 0x4c,
  0x53, 0x73, 0x4c, 0x5a, 0x41, 0x42, 0x71, 0x6c, 0x64, 0x4b, 0x36, 0x74,
  0x6e, 0x4d, 0x39, 0x54, 0x6f, 0x4a, 0x50, 0x38, 0x30, 0x39, 0x2f, 0x4d,
  0x6a, 0x66, 0x4e, 0x44, 0x32, 0x64, 0x36, 0x59, 0x2f, 0x52, 0x75, 0x30,
  0x55, 0x36, 0x73, 0x6f, 0x72, 0x71, 0x50, 0x55, 0x76, 0x0a, 0x56, 0x77,
  0x73, 0x49, 0x4b, 0x78, 0x42, 0x71, 0x57, 0x69, 0x62, 0x6e, 0x56, 0x50,
  0x74, 0x35, 0x41, 0x51, 0x4a, 0x42, 0x41, 0x50, 0x53, 0x68, 0x59, 0x34,
  0x72, 0x31, 0x63, 0x47, 0x38, 0x66, 0x56, 0x70, 0x6e, 0x6b, 0x6e, 0x4b,
  0x45, 0x64, 0x67, 0x31, 0x50, 0x47, 0x78, 0x77, 0x46, 0x68, 0x47, 0x37,
  0x56, 0x44, 0x42, 0x36, 0x74, 0x57, 0x51, 0x37, 0x62, 0x6d, 0x6a, 0x35,
  0x4e, 0x51, 0x0a, 0x53, 0x5a, 0x43, 0x64, 0x64, 0x65, 0x51, 0x5a, 0x6d,
  0x47, 0x66, 0x62, 0x4f, 0x6b, 0x48, 0x6c, 0x31, 0x58, 0x4e, 0x5a, 0x79,
  0x67, 0x56, 0x2b, 0x31, 0x31, 0x6c, 0x6c, 0x71, 0x7a, 0x58, 0x53, 0x38,
  0x51, 0x52, 0x37, 0x69, 0x57, 0x54, 0x68, 0x41, 0x4b, 0x30, 0x43, 0x51,
  0x51, 0x44, 0x61, 0x74, 0x6b, 0x6f, 0x4e, 0x71, 0x72, 0x56, 0x38, 0x68,
  0x6a, 0x6e, 0x72, 0x38, 0x61, 0x55, 0x4a, 0x0a, 0x46, 0x50, 0x63, 0x55,
  0x30, 0x2f, 0x4f, 0x79, 0x77, 0x33, 0x37, 0x54, 0x7a, 0x39, 0x6a, 0x4f,
  0x38, 0x64, 0x75, 0x74, 0x47, 0x34, 0x35, 0x7a, 0x59, 0x67, 0x47, 0x78,
  0x52, 0x61, 0x63, 0x33, 0x37, 0x77, 0x4e, 0x39, 0x51, 0x30, 0x38, 0x38,
  0x76, 0x38, 0x37, 0x50, 0x4d, 0x62, 0x6c, 0x72, 0x38, 0x56, 0x38, 0x31,
  0x63, 0x39, 0x5a, 0x51, 0x6b, 0x6e, 0x35, 0x2f, 0x2f, 0x53, 0x50, 0x4b,
  0x0a, 0x56, 0x39, 0x50, 0x35, 0x41, 0x6b, 0x45, 0x41, 0x67, 0x65, 0x39,
  0x2f, 0x4b, 0x66, 0x33, 0x33, 0x2f, 0x47, 0x34, 0x4f, 0x31, 0x36, 0x73,
  0x41, 0x4c, 0x75, 0x75, 0x34, 0x4a, 0x37, 0x56, 0x37, 0x57, 0x70, 0x59,
  0x7a, 0x32, 0x33, 0x47, 0x42, 0x44, 0x31, 0x62, 0x41, 0x6e, 0x4e, 0x4f,
  0x57, 0x43, 0x30, 0x38, 0x6e, 0x34, 0x2f, 0x4a, 0x65, 0x2f, 0x67, 0x74,
  0x43, 0x55, 0x6c, 0x65, 0x31, 0x0a, 0x64, 0x2b, 0x38, 0x57, 0x45, 0x7a,
  0x44, 0x73, 0x42, 0x30, 0x4d, 0x36, 0x4b, 0x7a, 0x65, 0x2f, 0x57, 0x74,
  0x56, 0x79, 0x51, 0x30, 0x6c, 0x43, 0x7a, 0x78, 0x78, 0x62, 0x2b, 0x51,
  0x4a, 0x42, 0x41, 0x4a, 0x79, 0x49, 0x5a, 0x50, 0x33, 0x64, 0x46, 0x4f,
  0x46, 0x58, 0x79, 0x2f, 0x4c, 0x44, 0x55, 0x77, 0x50, 0x70, 0x2f, 0x6d,
  0x44, 0x6f, 0x78, 0x58, 0x31, 0x48, 0x44, 0x2b, 0x6d, 0x57, 0x0a, 0x30,
  0x36, 0x78, 0x68, 0x53, 0x34, 0x46, 0x63, 0x76, 0x4a, 0x70, 0x32, 0x4a,
  0x5a, 0x48, 0x7a, 0x73, 0x52, 0x65, 0x47, 0x4f, 0x44, 0x41, 0x5a, 0x30,
  0x59, 0x64, 0x41, 0x48, 0x45, 0x73, 0x4d, 0x59, 0x70, 0x49, 0x51, 0x41,
  0x62, 0x31, 0x6d, 0x39, 0x35, 0x64, 0x5a, 0x45, 0x62, 0x4b, 0x57, 0x77,
  0x56, 0x76, 0x62, 0x65, 0x6a, 0x6b, 0x43, 0x51, 0x51, 0x44, 0x52, 0x46,
  0x42, 0x39, 0x73, 0x0a, 0x66, 0x39, 0x68, 0x53, 0x33, 0x57, 0x4d, 0x69,
  0x38, 0x65, 0x47, 0x6e, 0x43, 0x4d, 0x33, 0x58, 0x34, 0x4c, 0x32, 0x32,
  0x7a, 0x68, 0x61, 0x46, 0x42, 0x74, 0x68, 0x33, 0x73, 0x51, 0x7a, 0x78,
  0x72, 0x63, 0x4a, 0x35, 0x51, 0x4a, 0x55, 0x4d, 0x78, 0x57, 0x69, 0x44,
  0x6c, 0x45, 0x4f, 0x72, 0x76, 0x71, 0x47, 0x77, 0x4c, 0x48, 0x79, 0x67,
  0x50, 0x4f, 0x38, 0x59, 0x59, 0x38, 0x58, 0x6c, 0x0a, 0x74, 0x79, 0x59,
  0x63, 0x45, 0x64, 0x6c, 0x43, 0x4c, 0x35, 0x36, 0x71, 0x74, 0x41, 0x34,
  0x59, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x50,
  0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d,
  0x2d, 0x2d, 0x2d, 0x0a,
};

const std::vector<char> server_dh1024 =
{
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x44,
  0x48, 0x20, 0x50, 0x41, 0x52, 0x41, 0x4d, 0x45, 0x54, 0x45, 0x52, 0x53,
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x47, 0x48, 0x41, 0x6f,
  0x47, 0x42, 0x41, 0x4c, 0x50, 0x35, 0x33, 0x68, 0x32, 0x31, 0x59, 0x6d,
  0x6a, 0x47, 0x4a, 0x4f, 0x34, 0x53, 0x2f, 0x38, 0x42, 0x7a, 0x44, 0x61,
  0x57, 0x63, 0x4b, 0x6f, 0x46, 0x6c, 0x6a, 0x56, 0x32, 0x46, 0x37, 0x4f,
  0x66, 0x39, 0x4e, 0x50, 0x33, 0x31, 0x33, 0x4b, 0x54, 0x42, 0x2f, 0x51,
  0x55, 0x62, 0x6c, 0x58, 0x70, 0x6e, 0x65, 0x4e, 0x2b, 0x62, 0x0a, 0x32,
  0x41, 0x70, 0x76, 0x4e, 0x31, 0x32, 0x69, 0x33, 0x51, 0x46, 0x75, 0x52,
  0x2b, 0x4a, 0x6e, 0x4e, 0x70, 0x2b, 0x51, 0x2f, 0x6d, 0x47, 0x7a, 0x34,
  0x6b, 0x77, 0x32, 0x2b, 0x45, 0x48, 0x6d, 0x35, 0x67, 0x65, 0x68, 0x38,
  0x6f, 0x35, 0x54, 0x47, 0x6a, 0x57, 0x6a, 0x57, 0x50, 0x69, 0x33, 0x42,
  0x30, 0x78, 0x6c, 0x4c, 0x76, 0x4e, 0x4a, 0x4c, 0x54, 0x31, 0x32, 0x68,
  0x41, 0x56, 0x42, 0x0a, 0x76, 0x31, 0x6f, 0x38, 0x65, 0x50, 0x68, 0x30,
  0x72, 0x5a, 0x65, 0x66, 0x43, 0x47, 0x7a, 0x74, 0x68, 0x32, 0x4a, 0x2f,
  0x6a, 0x4b, 0x4c, 0x4f, 0x41, 0x57, 0x46, 0x36, 0x30, 0x6e, 0x32, 0x53,
  0x33, 0x45, 0x36, 0x34, 0x37, 0x5a, 0x4a, 0x74, 0x74, 0x32, 0x2f, 0x4b,
  0x47, 0x47, 0x6b, 0x76, 0x37, 0x56, 0x33, 0x62, 0x41, 0x67, 0x45, 0x43,
  0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x44, 0x48,
  0x20, 0x50, 0x41, 0x52, 0x41, 0x4d, 0x45, 0x54, 0x45, 0x52, 0x53, 0x2d,
  0x2d, 0x2d, 0x2d, 0x2d, 0x0a,
};


namespace std
{
  std::size_t
  hash<boost::uuids::uuid>::operator()(boost::uuids::uuid const& s) const
  {
    auto hasher = hash<string>{};
    return hasher(boost::lexical_cast<string>(s));
  }
}
