import drake
import drake.cxx

config = None
lib_static = None
lib_dynamic = None

def configure(cxx_toolkit, openssl_config, reactor_config, elle_config,
        cxx_config = None, boost = None, enable_tests = True):

  global config, lib_static, lib_dynamic

  # Global Configuration
  config = drake.cxx.Config()
  config.standard = drake.cxx.Config.cxx_0x
  config.add_local_include_path('sources')
  config.lib_path('lib')
  config += openssl_config

  # Local Configuration
  cxx_config = cxx_config or drake.cxx.Config()
  cxx_config.standard = drake.cxx.Config.cxx_0x
  cxx_config += config
  cxx_config += boost.cfg
  cxx_config += boost.config_system()
  cxx_config += reactor_config
  cxx_config += elle_config
  cxx_config.lib('crypto')
  cxx_config.lib('ssl')

  # Sources
  sources = drake.nodes(
    'sources/cryptography/Clear.hh',
    'sources/cryptography/Code.hh',
    'sources/cryptography/Cryptosystem.cc',
    'sources/cryptography/Cryptosystem.hh',
    'sources/cryptography/Digest.hh',
    'sources/cryptography/Exception.hh',
    'sources/cryptography/Exception.cc',
    'sources/cryptography/Input.cc',
    'sources/cryptography/Input.hh',
    'sources/cryptography/KeyPair.cc',
    'sources/cryptography/KeyPair.hh',
    'sources/cryptography/KeyPair.hxx',
    'sources/cryptography/Output.cc',
    'sources/cryptography/Output.hh',
    'sources/cryptography/Output.hxx',
    'sources/cryptography/Plain.hh',
    'sources/cryptography/PrivateKey.cc',
    'sources/cryptography/PrivateKey.hh',
    'sources/cryptography/PrivateKey.hxx',
    'sources/cryptography/PublicKey.cc',
    'sources/cryptography/PublicKey.hh',
    'sources/cryptography/PublicKey.hxx',
    'sources/cryptography/SecretKey.cc',
    'sources/cryptography/SecretKey.hh',
    'sources/cryptography/SecretKey.hxx',
    'sources/cryptography/Seed.cc',
    'sources/cryptography/Seed.hh',
    'sources/cryptography/Seed.hxx',
    'sources/cryptography/Signature.hh',
    'sources/cryptography/all.hh',
    'sources/cryptography/bn.cc',
    'sources/cryptography/bn.hh',
    'sources/cryptography/bn.hxx',
    'sources/cryptography/cipher.cc',
    'sources/cryptography/cipher.hh',
    'sources/cryptography/cryptography.cc',
    'sources/cryptography/cryptography.hh',
    'sources/cryptography/evp.cc',
    'sources/cryptography/evp.hh',
    'sources/cryptography/finally.hh',
    'sources/cryptography/fwd.hh',
    'sources/cryptography/oneway.cc',
    'sources/cryptography/oneway.hh',
    'sources/cryptography/oneway.hxx',
    'sources/cryptography/random.cc',
    'sources/cryptography/random.hh',
    'sources/cryptography/random.hxx',
    'sources/cryptography/rsa/PrivateKey.cc',
    'sources/cryptography/rsa/PrivateKey.hh',
    'sources/cryptography/rsa/PrivateKey.hxx',
    'sources/cryptography/rsa/PublicKey.cc',
    'sources/cryptography/rsa/PublicKey.hh',
    'sources/cryptography/rsa/PublicKey.hxx',
    'sources/cryptography/rsa/all.hh',
    'sources/cryptography/rsa/fwd.hh',
    'sources/cryptography/rsa/keypair.cc',
    'sources/cryptography/rsa/keypair.hh',
    )

  lib_static = drake.cxx.StaticLib('lib/cryptography', sources, cxx_toolkit, cxx_config)
  lib_dynamic = drake.cxx.DynLib('lib/cryptography', sources, cxx_toolkit, cxx_config)

  # Tests

  check = drake.Rule('check')

  tests = [
    'cryptography/Input',
    'cryptography/KeyPair',
    'cryptography/Output',
    'cryptography/PrivateKey',
    'cryptography/PublicKey',
    'cryptography/SecretKey',
    'cryptography/Seed',
    'cryptography/bn',
    'cryptography/oneway',
    'cryptography/random',
    ]

  class TestRunner(drake.Builder):

    def __init__(self, test):
      self.__test = test
      self.__out = drake.node('%s.out' % test.name())
      self.__err = drake.node('%s.err' % test.name())
      self.__status = drake.node('%s.status' % test.name())
      drake.Builder.__init__(self, [test], [self.__out, self.__err, self.__status])

    @property
    def status(self):
      return self.__status

    def execute(self):
      import subprocess
      path = str(self.__test.path())
      with open(str(self.__out.path()), 'w') as out, \
           open(str(self.__err.path()), 'w') as err, \
           open(str(self.__status.path()), 'w') as rv:
        self.output(path, 'Test %s' % self.__test)
        p = subprocess.Popen(path, stdout = out, stderr = err)
        p.wait()
        status = p.returncode
        print(status, file = rv)
      return status == 0

  boost = boost or drake.cxx.boost.Boost()

  cxx_config_tests = cxx_config + config
  cxx_config_tests += boost.config()
  cxx_config_tests += boost.config_filesystem()
  cxx_config_tests += boost.config_system()
  cxx_config_tests += boost.config_test()

  if enable_tests:
      for test in tests:
        config = drake.cxx.Config(cxx_config_tests)
        config.lib_path_runtime('%s../lib' % ('../../' * test.count('/')))
        test = drake.cxx.Executable('tests/%s' % test,
                                    drake.nodes('tests/%s.cc' % test) + [lib_dynamic],
                                    cxx_toolkit, config)
        runner = TestRunner(test)
        check << runner.status
