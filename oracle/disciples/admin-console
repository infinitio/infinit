#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import argparse
import cmd
import os
import sys

import meta.database
import pythia

SHELL_INTRO = """
    Administrative console to query infinit services.
"""

ARGUMENT_PARSER = argparse.ArgumentParser(
    description=SHELL_INTRO.strip(),
)

ARGUMENT_PARSER.add_argument(
    '--db-host',
    help="Database hostname or ip",
    default="localhost"
)

ARGUMENT_PARSER.add_argument(
    '--db-port',
    help="Database connection port",
    default=27017,
    type=int
)


class DatabaseCommands(type):

    @classmethod
    def __prepare__(cls, name, bases):
        ns = {}
        ns['_argument_parsers'] = {}
        for k in ['users', 'devices', 'networks', 'invitations']:
            ns['_argument_parsers'][k] = cls._generate_argument_parser(k)
            ns['do_%s' % k] = cls._make_collection_command(k)
            ns['help_%s' % k] = cls._make_collection_command_help(k)
        return ns

    @classmethod
    def _generate_argument_parser(cls, collection):
        parser = argparse.ArgumentParser(
            prog=collection,
            description="Retreive %s from database" % collection,
            add_help=False,
        )
        parser.add_argument(
            'field',
            help="The field you want to check",
            default="_id",
            type=str,
            nargs='?',
        )
        parser.add_argument(
            'reg',
            help="The matching pattern",
            default="",
            type=str,
            nargs='?',
        )
        parser.add_argument(
            '--skip',
            help="Skip N records",
            default=0,
            type=int,
            nargs='?',
        )
        parser.add_argument(
            '--limit',
            help="Limit result to N records",
            default=100,
            type=int,
            nargs='?',
        )
        parser.exit = cls._raise_parser_exception
        return parser

    class ParseArgumentsException(BaseException):
        def __init__(self, msg):
            self.msg = msg

    @classmethod
    def _raise_parser_exception(cls, status=None, message=""):
        raise cls.ParseArgumentsException(message)

    @classmethod
    def _make_collection_command(cls, collection):
        def command(self, line):
            if self._db_connection is None:
                print("You have to be connected!")
                return
            try:
                args = self._argument_parsers[collection].parse_args(
                    line.strip().split()
                )
            except cls.ParseArgumentsException as e:
                print(e.msg.strip())
                return

            records = getattr(meta.database, collection)(self._db_connection).find(
                args.reg and {args.field: {'$regex': args.reg}} or {},
                skip=args.skip,
                limit=args.limit,
            )

            print(records.count(), "%s found" % collection)
            for record in records:
                getattr(self, '_' + collection + '_printer')(record)
        return command

    @classmethod
    def _make_collection_command_help(cls, collection):
        def command_help(self):
            self._argument_parsers[collection].print_help()
        return command_help

def make_simple_argument_parser(prog=None, description=None, add_help=False, args=None):
    parser = argparse.ArgumentParser(prog=prog,
                                     description=description,
                                     add_help=add_help)
    for arg in args:
        flags = arg.pop('flags')
        if not (isinstance(flags, list) or isinstance(flags, tuple)):
            flags = (flags,)
        parser.add_argument(*flags, **arg)
    return parser

class AdminShell(cmd.Cmd, metaclass=DatabaseCommands):

    _invite_argument_parser = make_simple_argument_parser(
        prog="invite",
        description="Generate and send an invitation",
        args=[
            {
                'flags': 'email',
                'help': "The email to send an invitation to"
            },
            {
                'flags': ('-f', '--force'),
                'help': "Force invitation, even if already in database",
                'action': "store_true",
            },
            {
                'flags': ('-n', '--no-mail'),
                'help': "Do not send an email",
                'action': "store_true",
            },
        ]
    )

    def __init__(self, args):
        self._connect(args.db_host, args.db_port)
        super(AdminShell, self).__init__()

    def _update_prompt(self):
        status = self._db_connection and "connected" or "not connected"
        self.prompt = '%s:%d (%s)# ' % (self._db_host, self._db_port, status)

    def _connect(self, host, port):
        self._db_host = host
        self._db_port = port
        self._db_connection = None
        try:
            self._db_connection = meta.database.connection(host, port)
        except:
            print("Cannot connect to %s:%d" % (host, port))
        self._update_prompt()

    def _users_printer(self, user):
        print('%s <%s> (_id=%s)' % (user['fullname'], user['email'], user['_id']))
        print('\t- has identity:', user['identity'] is not None)
        print('\t- accounts:')
        for account in user['accounts']:
            print('\t\t* %s (type=%s)' % (account['id'], account['type']))
        print('\t- networks:')
        for network in user['networks']:
            print('\t\t* %s' % network)

    def _networks_printer(self, network):
        print('%s (%s)' % (network['name'], network['_id']))
        print('\t- owner: %s' % network['owner'])
        print('\t- model:', network['model'])
        print('\t- has root block:', network['root_block'] is not None)
        print('\t- has root address:', network['root_address'] is not None)
        print('\t- has descriptor:', network['descriptor'] is not None)
        print('\t- nodes:')
        for id_ in network['nodes']:
            print('\t\t* %s' % id_)
        print('\t- users:')
        for id_ in network['users']:
            print('\t\t* %s' % id_)


    def _devices_printer(self, device):
        print('%s (%s)' % (device['name'], device['_id']))
        print('\t- owner: %s' % device['owner'])
        print('\t- local address:', device['local_address'])
        print('\t- extern address:', device['extern_address'])
        print('\t- has passport:', device['passport'] is not None)

    def do_dbconnect(self, line):
        """usage: connect host:port

        Connect to (another) database.
        """
        host, port = line.strip().split(':')
        self._connect(host, port)

    def _get_args(self, parser, line):
        parser.exit = DatabaseCommands._raise_parser_exception
        try:
            return parser.parse_args(line.strip().split())
        except DatabaseCommands.ParseArgumentsException as e:
            print(e.msg.strip())

    def do_invite(self, line):
        """usage: invite mail

        Invite somebody with its email
        """
        args = self._get_args(self._invite_argument_parser, line)
        if not args:
            return
        request = {
            'email': args.email,
            'force': args.force,
            'dont_send_mail': args.no_mail,
        }
        res = pythia.Admin().post('/user/invite', request)
        if not res['success']:
            print("ERROR:", res['error'])

    def help_invite(self):
        self._invite_argument_parser.print_help()

    def default(self, line):
        if line == 'EOF':
            print('exit')
            raise KeyboardInterrupt()
        print("Command not found:", line)

    def emptyline(self):
        pass

def main(args):
    shell = AdminShell(args)
    try:
        shell.cmdloop(SHELL_INTRO)
    except KeyboardInterrupt:
        pass
    return 0

if __name__ == '__main__':
    args = ARGUMENT_PARSER.parse_args()
    sys.exit(main(args))
