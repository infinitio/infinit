#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import argparse
import cmd
import os
import sys

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../lib/python'))

import meta.database
import pythia

SHELL_INTRO = """
    Administrative console to query infinit services.
"""

ARGUMENT_PARSER = argparse.ArgumentParser(
    description=SHELL_INTRO.strip(),
)

ARGUMENT_PARSER.add_argument(
    '--db-host',
    help="Database hostname or ip",
    default="localhost"
)

ARGUMENT_PARSER.add_argument(
    '--db-port',
    help="Database connection port",
    default=27017,
    type=int
)


class DatabaseCommands(type):

    @classmethod
    def __prepare__(cls, name, bases):
        ns = {}
        ns['_argument_parsers'] = {}
        for k in ['users', 'devices', 'networks', 'invitations', 'transactions']:
            ns['_argument_parsers'][k] = cls._generate_argument_parser(k)
            ns['do_%s' % k] = cls._make_collection_command(k)
            ns['help_%s' % k] = cls._make_collection_command_help(k)
        return ns

    @classmethod
    def _generate_argument_parser(cls, collection):
        parser = argparse.ArgumentParser(
            prog=collection,
            description="Retreive %s from database" % collection,
            add_help=False,
        )
        parser.add_argument(
            'field',
            help="The field you want to check",
            default="_id",
            type=str,
            nargs='?',
        )
        parser.add_argument(
            'reg',
            help="The matching pattern",
            default="",
            type=str,
            nargs='?',
        )
        parser.add_argument(
            '--skip',
            help="Skip N records",
            default=0,
            type=int,
            nargs='?',
        )
        parser.add_argument(
            '--limit',
            help="Limit result to N records",
            default=100,
            type=int,
            nargs='?',
        )
        parser.exit = cls._raise_parser_exception
        return parser

    class ParseArgumentsException(BaseException):
        def __init__(self, msg):
            self.msg = msg

    @classmethod
    def _raise_parser_exception(cls, status=None, message=""):
        raise cls.ParseArgumentsException(message)

    @classmethod
    def _make_collection_command(cls, collection):
        def command(self, line):
            if self._db_connection is None:
                print("You have to be connected!")
                return
            try:
                args = self._argument_parsers[collection].parse_args(
                    line.strip().split()
                )
            except cls.ParseArgumentsException as e:
                print(e.msg.strip())
                return

            records = getattr(meta.database, collection)(self._db_connection).find(
                args.reg and {args.field: {'$regex': args.reg}} or {},
                skip=args.skip,
                limit=args.limit,
            )

            print(records.count(), "%s found" % collection)
            for record in records:
                getattr(self, '_' + collection + '_printer')(record)
        return command

    @classmethod
    def _make_collection_command_help(cls, collection):
        def command_help(self):
            self._argument_parsers[collection].print_help()
        return command_help

def make_simple_argument_parser(prog=None, description=None, add_help=False, args=None):
    parser = argparse.ArgumentParser(prog=prog,
                                     description=description,
                                     add_help=add_help)
    for arg in args:
        flags = arg.pop('flags')
        if not (isinstance(flags, list) or isinstance(flags, tuple)):
            flags = (flags,)
        parser.add_argument(*flags, **arg)
    return parser

class AdminShell(cmd.Cmd, metaclass=DatabaseCommands):

    _invite_argument_parser = make_simple_argument_parser(
        prog="invite",
        description="Generate and send an invitation",
        args=[
            {
                'flags': 'email',
                'help': "The email to send an invitation to"
            },
            {
                'flags': ('-f', '--force'),
                'help': "Force invitation, even if already in database",
                'action': "store_true",
            },
            {
                'flags': ('-n', '--no-mail'),
                'help': "Do not send an email",
                'action': "store_true",
            },
        ]
    )

    _update_invitations_argument_parser = make_simple_argument_parser(
        prog="update_invations",
        description="Set the number of invitation of every"
                    "users to the given count",
        args=[
            {
                'flags': 'count',
                'help': "the number of invitations",
            },
            {
                'flags': 'users',
                'help': "the users to update",
                'nargs': "*",
            },
        ]
    )

    _cancel_transactions_argument_parser = make_simple_argument_parser(
        prog = "cancel_transactions",
        description = "Cancel transactions",
        args = [
            {
                'flags': '--do-it-for-real',
                'action': 'store_true'
            },
        ]
    )

    _ghostify_argument_parser = make_simple_argument_parser(
        prog = "ghostify",
        description = "Reset password",
        args = [
            {
                'flags': 'emails',
                'help': "User to be ghostified",
                'nargs': '+',
            },
        ],
    )

    _activation_code_parser = make_simple_argument_parser(
        prog = "activation-code",
        description = "Manage activation codes",
        args = [
            {
                'flags': ('--create', '-c'),
                'action': 'store_true',
            },
            {
                'flags': ('--number', '-n'),
                'action': 'store',
                'default': 10,
                'type': int,
            },
        ]
    )

    def __init__(self, args):
        self._connect(args.db_host, args.db_port)
        super(AdminShell, self).__init__()

    def _update_prompt(self):
        status = self._db_connection and "connected" or "not connected"
        self.prompt = '%s:%d (%s)# ' % (self._db_host, self._db_port, status)

    def _connect(self, host, port):
        self._db_host = host
        self._db_port = port
        self._db_connection = None
        try:
            self._db_connection = meta.database.Connection(host, port)
            self.database = meta.database.Database(self._db_connection.meta)
        except:
            print("Cannot connect to %s:%d" % (host, port))
        self._update_prompt()

    def _users_printer(self, user):
        print('%s <%s> (_id=%s)' % (user['fullname'], user['email'], user['_id']))
        print('\t- has identity:', user['identity'] is not None)
        print('\t- accounts:')
        for account in user['accounts']:
            print('\t\t* %s (type=%s)' % (account['id'], account['type']))
        print('\t- networks:')
        for network in user['networks']:
            print('\t\t* %s' % network)

    def _networks_printer(self, network):
        print('%s (%s)' % (network['name'], network['_id']))
        print('\t- owner: %s' % network['owner'])
        print('\t- model:', network['model'])
        print('\t- has root block:', network['root_block'] is not None)
        print('\t- has root address:', network['root_address'] is not None)
        print('\t- has descriptor:', network['descriptor'] is not None)
        print('\t- nodes:')
        for id_ in network['nodes']:
            print('\t\t* %s' % id_)
        print('\t- users:')
        for id_ in network['users']:
            print('\t\t* %s' % id_)

    def _transactions_printer(self, tr):
        print("transaction", tr['_id'], "status is", tr['status'])
        print("\t- sender: %s (%s) on device %s" % (
            tr['sender_fullname'], tr['sender_id'], tr['sender_device_id'])
        )
        print("\t- recipient: %s (%s) on device %s" % (
            tr['recipient_fullname'], tr['recipient_id'], tr['recipient_device_id'])
        )

    def _devices_printer(self, device):
        print('%s (%s)' % (device['name'], device['_id']))
        print('\t- owner: %s' % device['owner'])
        print('\t- local address:', device['local_address'])
        print('\t- extern address:', device['extern_address'])
        print('\t- has passport:', device['passport'] is not None)

    def do_dbconnect(self, line):
        """usage: connect host:port

        Connect to (another) database.
        """
        host, port = line.strip().split(':')
        self._connect(host, port)

    def _get_args(self, parser, line):
        parser.exit = DatabaseCommands._raise_parser_exception
        try:
            return parser.parse_args(line.strip().split())
        except DatabaseCommands.ParseArgumentsException as e:
            print(e.msg.strip())

    def do_invite(self, line):
        """usage: invite mail

        Invite somebody with its email
        """
        args = self._get_args(self._invite_argument_parser, line)
        if not args:
            return
        request = {
            'email': args.email,
            'force': args.force,
            'dont_send_mail': args.no_mail,
        }
        res = pythia.Admin().post('/user/invite', request)
        if not res['success']:
            print("ERROR:", res['error'])

    def help_invite(self):
        self._invite_argument_parser.print_help()

    def do_update_invitations(self, line):
        """usage: update_invitations count user1@email.com user2@email.com


        Update the users (all if nothing in users) invitation counter.
        """
        args = self._get_args(self._update_invitations_argument_parser, line)
        if not args:
            return
        print(args)
        count = int(args.count)
        users = 'users' in args and args.users or []

        meta.database.users().update(
            users and {'email': {'$in': users}} or {},
            {'$set': {'remaining_invitations': count}},
            multi = True
        )

    def do_cancel_transactions(self, line):
        args = self._get_args(self._cancel_transactions_argument_parser, line)
        if not args: return
        meta.database.transactions().update(
            {'status': {'$ne': 6}},
            {'$set': {'status': 5}},
            multi = True,
        )
        transactions = meta.database.transactions().find(
            {'status': {'$nin': [5, 6]}},
        )
        for t in transactions:
            print(t)


    def do_ghostify(self, line):
        args = self._get_args(self._ghostify_argument_parser, line)
        if not args: return
        from pythia.constants import ADMIN_TOKEN
        import plasma
        admin = plasma.Meta(host, port)
        admin.token = ADMIN_TOKEN
        for email in args.emails:
            admin.ghostify(email)

    def _gen_activation_code(self, size = 8):
        import random
        import string
        return '@' + ''.join(
            random.choice(string.ascii_lowercase) for x in range(size)
        ).upper()

    def do_activation_code(self, line):
        args = self._get_args(self._activation_code_parser, line)
        if not args: return
        if args.create:
            code = self._gen_activation_code()
            self.database.activations.insert({
                'code': code,
                'number': args.number,
                'registered': [],
            })
            print("code", code)

    def help_ghostify(self):
        self._ghostify_argument_parser.print_help()

    def help_cancel_transactions(self):
        self._cancel_transactions_argument_parser.print_help()

    def help_update_invitations(self):
        self._invite_argument_parser.print_help()

    def default(self, line):
        if line == 'EOF':
            print('exit')
            raise KeyboardInterrupt()
        print("Command not found:", line)

    def emptyline(self):
        pass

def main(args):
    shell = AdminShell(args)
    try:
        shell.cmdloop(SHELL_INTRO)
    except KeyboardInterrupt:
        pass
    return 0

if __name__ == '__main__':
    args = ARGUMENT_PARSER.parse_args()
    sys.exit(main(args))
