#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import os, sys
import time
import subprocess
import argparse

DIR = os.path.abspath(os.path.dirname(__file__))
LIB_DIR = os.path.join(DIR, "..", "lib")

# Export library path to prevent ssl libraries mismatch.
ld_library_path = os.environ.get('LD_LIBRARY_PATH', '').split(':')
ld_library_path.extend([LIB_DIR, '/usr/local/lib'])
os.environ['LD_LIBRARY_PATH'] = ':'.join(ld_library_path)

sys.path.insert(0, os.path.join(LIB_DIR, "python"))

import meta.conf
import apertus.conf

SSD="/sbin/start-stop-daemon"
PWD=os.getenv("PWD")
RUNTIME_DIR=os.path.join(PWD, 'runtime')
INSTALL_DIR=PWD
APERTUS_PORT=apertus.conf.PORT
TROPHO_PORT=meta.conf.TROPHONIUS_PORT
TROPHO_CPORT=meta.conf.TROPHONIUS_CONTROL_PORT
META_FCGI_PORT=9003
META_PORT=meta.conf.META_PORT


parser = argparse.ArgumentParser(description="Services launcher")

parser.add_argument(
   '--stop-prod',
   default = False,
   action = "store_true",
)

parser.add_argument(
   '--start-prod',
   default = False,
   action = "store_true",
)

parser.add_argument(
    '--meta-port',
    type = int,
    default = META_PORT,
)

parser.add_argument(
    '--trophonius-port',
    type = int,
    default = TROPHO_PORT,
)

parser.add_argument(
    '--trophonius-control-port',
    type = int,
    default = TROPHO_CPORT,
)

parser.add_argument(
    '--apertus-host',
    type = str,
    default = "127.0.0.1",
)

parser.add_argument(
    '--apertus-port',
    type = int,
    default = APERTUS_PORT,
)

import shlex

def ssd(command):
	run(" ".join([SSD, "-v", "-d", RUNTIME_DIR] + shlex.split(command)))

def run(command):
    env = {
        'LD_LIBRARY_PATH': ':'.join(['/usr/local/lib', LIB_DIR]),
    }
    try:
        print(' '.join(command.split()))
        subprocess.check_call(shlex.split(command), env=env)
    except Exception as e:
        print(e)

def reset_user_status():
    """XXX We reset all user's status to be "disconnected". We know it's
    true because there is only on trophonius instance at the moment.
    The right way to do it is to disconnect all users (in the database)
    when the trophonius instance goes down.
    """
    import meta.database
    meta.database.users().update(spec={}, document={"$set": {"connected":False, "connected_devices": []}}, multi=True)

META_BIN = os.path.join(DIR, 'meta-server')
APERTUS_BIN = os.path.join(DIR, 'apertus-server')
TROPHONIUS_BIN = os.path.join(DIR, 'trophonius-server')

def main(argv):
    args = parser.parse_args(argv)

    if args.start_prod:
      start_prod(args)
    elif args.stop_prod:
      stop_prod(args)
    else:
      make_dev(args)

def get_local_ip():
    import socket
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(("gmail.com", 80))
    addr = s.getsockname()[0]
    s.close()
    return addr

keys = {
    'meta_bin': META_BIN,
    'meta_port': META_PORT,
    'meta_fport': META_FCGI_PORT,
    'meta_pidfile': os.path.join(RUNTIME_DIR, 'meta.pid'),

    'tropho_bin': TROPHONIUS_BIN,
    'tropho_port': TROPHO_PORT,
    'tropho_cport': TROPHO_CPORT,
    'tropho_pidfile': os.path.join(RUNTIME_DIR, 'tropho.pid'),

    'apertus_bin': APERTUS_BIN,
    'apertus_proxy_port': APERTUS_PORT,
    'apertus_host': get_local_ip(),
    'apertus_pidfile0': os.path.join(RUNTIME_DIR, 'apertus0.pid'),
    'apertus_pidfile1': os.path.join(RUNTIME_DIR, 'apertus1.pid'),
    'apertus_pidfile2': os.path.join(RUNTIME_DIR, 'apertus2.pid'),
    'apertus_pidfile_proxy': os.path.join(RUNTIME_DIR, 'apertus-proxy.pid'),
    'www_dir': os.path.join('.', os.path.relpath(RUNTIME_DIR)),
}

def start_prod(args):
    if not os.path.isdir(RUNTIME_DIR):
        os.mkdir(RUNTIME_DIR)

    ssd("-b -p {apertus_pidfile0} -m -S -x {apertus_bin} --\
          --port 0".format(**keys))

    ssd("-b -p {apertus_pidfile1} -m -S -x {apertus_bin} --\
          --port 0".format(**keys))

    ssd("-b -p {apertus_pidfile2} -m -S -x {apertus_bin} --\
          --port 0".format(**keys))

    ssd("-b -p {apertus_pidfile_proxy} -m -S -x {apertus_bin} --\
          --proxy --port {apertus_proxy_port}".format(**keys))

    ssd("-b -p {tropho_pidfile} -m -S -x {tropho_bin} --\
          --port {tropho_port} --control-port {tropho_cport}".format(**keys))

    run("spawn-fcgi -P {meta_pidfile} -d ./ -a 127.0.0.1 -p {meta_fport} --\
          {meta_bin} --fcgi\
          --port {meta_port}\
          --apertus-port {apertus_proxy_port}\
          --apertus-host {apertus_host}".format(**keys))

    run("sudo nginx -p {www_dir} -c ../prod/nginx.conf".format(**keys))

def stop_prod(args):
    ssd("-p {apertus_pidfile0} -K".format(**keys))
    ssd("-p {apertus_pidfile1} -K".format(**keys))
    ssd("-p {apertus_pidfile2} -K".format(**keys))
    ssd("-p {apertus_pidfile_proxy} -K".format(**keys))
    ssd("-p {tropho_pidfile} -K".format(**keys))
    ssd("-p {meta_pidfile} -K".format(**keys))
    run("sudo nginx -p {www_dir} -c ../prod/nginx.conf -s stop".format(**keys))

def make_dev(args):
    processes = []
    try:
        reset_user_status()
        processes.append(
            (
                META_BIN,
                subprocess.Popen(
                    [
                        META_BIN,
                        '--meta-port', str(args.meta_port),
                        '--trophonius-control-port', str(args.trophonius_control_port),
                        '--apertus-host', args.apertus_host,
                        '--apertus-port', str(args.apertus_port),
                    ],
                    stdout = open("meta.stdout", "w"),
                    stderr = open("meta.stderr", "w"))
            )
        )

        processes.append(
            (
                TROPHONIUS_BIN,
                subprocess.Popen(
                    [
                        TROPHONIUS_BIN,
                        '--port', str(args.trophonius_port),
                        '--control-port', str(args.trophonius_control_port),
                    ],
                    env = dict(INFINIT_META_PORT=str(args.meta_port), **os.environ),
                    stdout = open("tropho.stdout", "w"),
                    stderr = open("tropho.stderr", "w")
                )
            )
        )

        processes.append(
            (
                APERTUS_BIN,
                subprocess.Popen(
                    [
                        APERTUS_BIN,
                        '--port', str(args.apertus_port),
                        '--proxy',
                    ],
                    stdout = open("apertus-proxy.stdout", "w"),
                    stderr = open("apertus-proxy.stderr", "w")
                )
            )
        )
        processes.append(
            (
                APERTUS_BIN,
                subprocess.Popen(
                    [
                        APERTUS_BIN,
                        '--port', str(0)
                    ],
                    stdout = open("apertus1.stdout", "w"),
                    stderr = open("apertus1.stderr", "w")
                )
            )
        )
        processes.append(
            (
                APERTUS_BIN,
                subprocess.Popen(
                    [
                        APERTUS_BIN,
                        '--port', str(0)
                    ],
                    stdout = open("apertus2.stdout", "w"),
                    stderr = open("apertus2.stderr", "w")
                )
            )
        )
        processes.append(
            (
                APERTUS_BIN,
                subprocess.Popen(
                    [
                        APERTUS_BIN,
                        '--port', str(0)
                    ],
                    stdout = open("apertus3.stdout", "w"),
                    stderr = open("apertus3.stderr", "w")
                )
            )
        )

        print(
            "INFINIT_TROPHONIUS_PORT=%s" % args.trophonius_port,
            "INFINIT_META_PORT=%s" % args.meta_port,
        )

        running = True
        while running:
            for name, p in processes:
                p.poll()
                if p.returncode is not None:
                    raise Exception('%s failed with error code %s' % (name, p.returncode))
                time.sleep(0.1)
    except KeyboardInterrupt:
        print("Exiting")
    finally:
        for name, p in processes:
            try:
                p.terminate()
                time.sleep(1)
            except: pass

        for name, p in processes:
            if p.returncode is None:
                try:
                    p.kill()
                except:
                    pass

if __name__ == '__main__':
    try:
        import sys
        main(sys.argv[1:])
    except Exception as e:
        print('%s: fatal error: %s' % (sys.argv[0], e))
        raise e
